<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MARTINE - Version Compl√®te SNCF</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .header {
            background: rgba(255,255,255,0.95);
            backdrop-filter: blur(10px);
            padding: 20px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            border-bottom: 3px solid #667eea;
            position: relative;
        }

        .header h1 {
            text-align: center;
            color: #2c3e50;
            font-size: 28px;
            font-weight: 700;
            margin-bottom: 10px;
        }

        .project-martine {
            background: linear-gradient(45deg, #003366, #0066CC, #CC0000, #E30613);
            background-size: 300% 300%;
            animation: gradient 3s ease infinite;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-weight: 900;
        }

        @keyframes gradient {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .save-status {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255,255,255,0.2);
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 12px;
            color: #333;
            backdrop-filter: blur(5px);
        }

        .processing-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.35);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            backdrop-filter: blur(5px);
        }

        .processing-overlay.active {
            display: flex;
        }

        .processing-card {
            background: white;
            padding: 25px 30px;
            border-radius: 14px;
            box-shadow: 0 12px 40px rgba(0,0,0,0.18);
            min-width: 320px;
            max-width: 480px;
            text-align: center;
        }

        .processing-card h4 {
            margin-bottom: 10px;
            color: #2c3e50;
        }

        .quality-alerts {
            margin-top: 15px;
            text-align: left;
        }

        .quality-alert-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 10px;
            border-radius: 10px;
            background: #f8f9ff;
            border: 1px solid #eef2ff;
            margin-bottom: 8px;
            cursor: pointer;
            transition: transform 0.15s ease;
        }

        .quality-alert-item:hover {
            transform: translateY(-1px);
            background: #eef2ff;
        }

        .quality-alert-item .alert-meta {
            font-size: 12px;
            color: #556;
        }

        .rg-suggestion-panel {
            position: absolute;
            background: #fff;
            border: 1px solid #dfe3ff;
            border-radius: 10px;
            box-shadow: 0 8px 24px rgba(0,0,0,0.12);
            max-height: 190px;
            overflow-y: auto;
            min-width: 220px;
            z-index: 1200;
            padding: 6px;
        }

        .rg-suggestion-item {
            padding: 8px 10px;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            gap: 12px;
            transition: background 0.15s ease;
        }

        .rg-suggestion-item:hover,
        .rg-suggestion-item.active {
            background: #f3f4ff;
        }

        .rg-suggestion-code {
            font-weight: 700;
            color: #2c3e50;
        }

        .rg-suggestion-name {
            color: #555;
            font-size: 13px;
            flex: 1;
            text-align: right;
        }

        .quality-alert-empty {
            text-align: center;
            color: #667;
            padding: 10px;
            background: #f8f9ff;
            border-radius: 10px;
            border: 1px dashed #dfe3ff;
        }

        .processing-progress-text {
            color: #555;
            font-size: 14px;
            margin-bottom: 12px;
        }

        .progress-bar {
            width: 100%;
            background: #eef2ff;
            border-radius: 10px;
            height: 10px;
            overflow: hidden;
        }

        .progress-bar-inner {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            transition: width 0.2s ease;
        }

        .tabs-container {
            display: flex;
            background: rgba(255,255,255,0.9);
            padding: 0 20px;
            overflow-x: auto;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .tab {
            padding: 15px 25px;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            transition: all 0.3s ease;
            white-space: nowrap;
            font-weight: 600;
            color: #666;
            background: none;
            border: none;
        }

        .tab:hover {
            background: rgba(102, 126, 234, 0.1);
            color: #667eea;
        }

        .tab.active {
            color: #667eea;
            border-bottom-color: #667eea;
            background: rgba(102, 126, 234, 0.05);
        }

        .main-content {
            background: rgba(255,255,255,0.95);
            margin: 20px;
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            backdrop-filter: blur(10px);
            min-height: calc(100vh - 200px);
        }

        .tab-content {
            display: none;
            padding: 30px;
        }

        .tab-content.active {
            display: block;
        }

        /* üîß FILTRES AVANC√âS */
        .filters-section {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.05), rgba(118, 75, 162, 0.05));
            border: 2px solid rgba(102, 126, 234, 0.2);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 25px;
        }

        .filters-section h4 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 16px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .filters-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 15px;
        }

        .filter-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .filter-group label {
            font-size: 12px;
            font-weight: 600;
            color: #495057;
            text-transform: uppercase;
        }

        .filter-group input,
        .filter-group select {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 13px;
        }

        .filter-group input:focus,
        .filter-group select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        /* üöÄ ZONE IMPORT OPTIMIS√âE */
        .import-export-section {
            background: white;
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 25px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.08);
        }

        .import-export-section h4 {
            color: #2c3e50;
            margin-bottom: 20px;
            font-size: 18px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .import-methods {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .import-method {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            border: 2px solid transparent;
            transition: all 0.3s ease;
        }

        .import-method:hover {
            border-color: #667eea;
            background: rgba(102, 126, 234, 0.05);
        }

        .import-method h5 {
            color: #2c3e50;
            margin-bottom: 10px;
            font-size: 16px;
        }

        .import-method p {
            color: #666;
            font-size: 14px;
            margin-bottom: 15px;
            line-height: 1.4;
        }

        /* üìÅ ZONE FICHIER CORRIG√âE */
        .file-drop-zone {
            border: 3px dashed #667eea;
            border-radius: 12px;
            padding: 30px 20px;
            text-align: center;
            background: white;
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
        }

        .file-drop-zone:hover {
            border-color: #28a745;
            background: rgba(40, 167, 69, 0.05);
        }

        .file-drop-zone.dragover {
            border-color: #ffc107;
            background: rgba(255, 193, 7, 0.1);
            transform: scale(1.02);
        }

        .file-input-hidden {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            pointer-events: none;
            z-index: 1;
        }

        /* üìã ZONE COPIER-COLLER */
        .paste-area {
            background: white;
            border: 3px dashed #667eea;
            border-radius: 12px;
            padding: 20px;
            margin: 15px 0;
            display: none;
        }

        .paste-area.active {
            display: block;
            border-color: #28a745;
            background: rgba(40, 167, 69, 0.02);
        }

        .paste-textarea {
            width: 100%;
            min-height: 120px;
            padding: 15px;
            border: 2px solid #eee;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            resize: vertical;
            margin-bottom: 15px;
        }

        .paste-textarea:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        /* üîç FEN√äTRE DE PR√âVISUALISATION */
        .preview-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            z-index: 1000;
            backdrop-filter: blur(5px);
        }

        .preview-modal.show {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .preview-content {
            background: white;
            border-radius: 15px;
            padding: 30px;
            max-width: 95%;
            max-height: 90%;
            overflow: auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            display: flex;
            flex-direction: column;
        }

        .preview-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #eee;
        }

        .preview-header h3 {
            color: #2c3e50;
            font-size: 22px;
            margin: 0;
        }

        .close-preview {
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            cursor: pointer;
            font-size: 16px;
        }

        .preview-stats {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }

        .preview-stat {
            text-align: center;
        }

        .preview-stat-number {
            font-size: 24px;
            font-weight: bold;
            color: #667eea;
        }

        .preview-stat-label {
            font-size: 12px;
            color: #666;
            text-transform: uppercase;
        }

        .preview-stat.error .preview-stat-number {
            color: #dc3545;
        }

        .preview-stat.warning .preview-stat-number {
            color: #ffc107;
        }

        .preview-stat.success .preview-stat-number {
            color: #28a745;
        }

        /* üé® STATISTIQUES LUDIQUES */
        .stats-actions {
            display: flex;
            gap: 15px;
            align-items: center;
            justify-content: space-between;
            flex-wrap: wrap;
            margin: 0 30px 20px;
        }

        .fun-badge {
            background: linear-gradient(135deg, #ff9a9e 0%, #fad0c4 100%);
            color: #2c3e50;
            padding: 10px 16px;
            border-radius: 12px;
            font-weight: 700;
            box-shadow: 0 8px 20px rgba(0,0,0,0.08);
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .stat-chip-row {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: stretch;
        }

        .stat-chip {
            background: rgba(255,255,255,0.85);
            border: 2px dashed rgba(102, 126, 234, 0.25);
            border-radius: 12px;
            padding: 12px 14px;
            min-width: 180px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.05);
        }

        .stat-chip-label {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #667eea;
            font-weight: 700;
        }

        .stat-chip-value {
            font-size: 22px;
            font-weight: 800;
            color: #2c3e50;
            margin-top: 2px;
        }

        .stat-chip-subtext {
            font-size: 12px;
            color: #6c757d;
            margin-top: 4px;
        }

        .accent-card {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.12), rgba(118, 75, 162, 0.12));
            border: 1px solid rgba(102, 126, 234, 0.25);
        }

        .rg-change-list {
            margin-top: 12px;
            display: grid;
            gap: 10px;
        }

        .rg-change-item {
            background: rgba(255,255,255,0.85);
            border: 1px solid rgba(0,0,0,0.05);
            border-radius: 10px;
            padding: 12px 14px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.04);
        }

        .rg-change-item strong {
            color: #2c3e50;
        }

        .rg-change-meta {
            display: flex;
            gap: 12px;
            font-size: 12px;
            color: #6c757d;
        }

        .rg-change-meta span {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            padding: 4px 8px;
            border-radius: 20px;
            background: rgba(102, 126, 234, 0.1);
        }

        .rg-change-header {
            display: grid;
            grid-template-columns: auto 1fr auto;
            gap: 10px;
            align-items: center;
            width: 100%;
        }

        .rg-change-toggle {
            border: 1px solid rgba(0,0,0,0.06);
            background: #fff;
            border-radius: 8px;
            padding: 6px 8px;
            cursor: pointer;
            transition: background 0.2s ease, transform 0.1s ease;
        }

        .rg-change-toggle:hover {
            background: #f4f5ff;
            transform: translateY(-1px);
        }

        .rg-change-title {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .rg-change-title strong {
            font-size: 15px;
        }

        .rg-change-actions {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            justify-content: flex-end;
        }

        .rg-change-preview {
            color: #4a5568;
            font-size: 13px;
            background: #f7f9ff;
            border: 1px dashed #e2e7ff;
            padding: 8px 10px;
            border-radius: 8px;
        }

        .rg-change-body {
            border-top: 1px solid #eef2ff;
            padding-top: 8px;
            display: none;
        }

        .rg-line-list {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .rg-line-row {
            padding: 6px 8px;
            border: 1px solid #eef2ff;
            border-radius: 8px;
            background: #fff;
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            color: #333;
            font-size: 13px;
        }

        .rg-line-row strong {
            color: #2c3e50;
        }

        /* üìä TABLEAU DE PR√âVISUALISATION */
        .preview-table-container {
            flex: 1;
            overflow: auto;
            border: 1px solid #ddd;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .preview-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
        }

        .preview-table th {
            background: #667eea;
            color: white;
            padding: 12px 8px;
            text-align: left;
            font-weight: 600;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .preview-table td {
            padding: 10px 8px;
            border-bottom: 1px solid #eee;
            position: relative;
            word-break: break-word;
            white-space: normal;
        }

        .preview-table tr:hover {
            background: rgba(102, 126, 234, 0.05);
        }

        .row-selected {
            outline: 2px solid #28a745;
            outline-offset: -2px;
            background: rgba(40, 167, 69, 0.08) !important;
        }

        .clipboard-inline-panel {
            display: flex;
            flex-direction: column;
            gap: 6px;
            min-width: 220px;
            background: #f8f9ff;
            border: 1px dashed #bfc6ff;
            border-radius: 10px;
            padding: 10px;
        }

        .clipboard-inline-panel textarea {
            width: 100%;
            min-height: 80px;
            resize: vertical;
            border: 1px solid #d7ddff;
            border-radius: 8px;
            padding: 8px;
            font-size: 12px;
            font-family: 'Courier New', monospace;
        }

        .clipboard-inline-actions {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            justify-content: flex-end;
        }

        .clipboard-preview-modal {
            position: fixed;
            inset: 0;
            background: rgba(5, 10, 30, 0.82);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1200;
            padding: 20px;
        }

        .clipboard-preview-modal.show {
            display: flex;
        }

        .clipboard-preview-content {
            background: white;
            width: 95%;
            max-width: 1400px;
            border-radius: 18px;
            padding: 24px;
            box-shadow: 0 24px 60px rgba(0, 0, 0, 0.35);
            display: flex;
            flex-direction: column;
            gap: 18px;
        }

        .clipboard-preview-body {
            display: grid;
            grid-template-columns: minmax(360px, 42%) minmax(360px, 1fr);
            gap: 20px;
        }

        @media (max-width: 1200px) {
            .clipboard-preview-body {
                grid-template-columns: 1fr;
            }
        }

        .clipboard-panel {
            background: #f8f9ff;
            border-radius: 16px;
            padding: 16px;
            box-shadow: inset 0 0 0 1px #e1e5ff;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .clipboard-panel-left {
            min-height: 520px;
        }

        .clipboard-panel h4 {
            margin: 0;
            color: #2c3e50;
        }

        .clipboard-left-layout {
            display: flex;
            flex-direction: column;
            gap: 12px;
            height: 100%;
        }

        .clipboard-search-card {
            background: white;
            border-radius: 14px;
            border: 1px solid #dfe4ff;
            padding: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
        }

        .clipboard-search-card label {
            display: block;
            margin-bottom: 6px;
            font-weight: 600;
            color: #2c3e50;
        }

        .clipboard-search-row {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .clipboard-search-row input {
            flex: 1;
            padding: 8px 10px;
            border-radius: 8px;
            border: 1px solid #c8d0ff;
            font-size: 13px;
        }

        .clipboard-search-row button {
            white-space: nowrap;
        }

        .clipboard-search-summary {
            font-size: 12px;
            color: #5c6482;
            margin-top: 6px;
        }

        .clipboard-search-matches {
            margin-top: 8px;
            max-height: 170px;
            overflow: auto;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .clipboard-search-matches button {
            text-align: left;
            border: 1px solid #dfe4ff;
            border-radius: 10px;
            background: #f4f6ff;
            padding: 8px 10px;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            gap: 2px;
            font-size: 12px;
            color: #2c3e50;
        }

        .clipboard-search-matches button strong {
            font-size: 13px;
            color: #1f2a44;
        }

        .clipboard-search-matches button span {
            color: #5b658c;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .clipboard-search-matches button:hover {
            background: #e8ecff;
        }

        .clipboard-left-controls,
        .clipboard-right-controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
        }

        .clipboard-table-wrapper {
            flex: 1;
            overflow: auto;
            border-radius: 12px;
            background: white;
            border: 1px solid #e1e5ff;
        }

        .clipboard-table {
            width: 100%;
            border-collapse: collapse;
        }

        .clipboard-table th,
        .clipboard-table td {
            padding: 10px;
            border-bottom: 1px solid #eef1ff;
            font-size: 13px;
        }

        .clipboard-right-cell {
            cursor: grab;
            user-select: text;
        }

        .clipboard-right-cell:active {
            cursor: grabbing;
        }

        .clipboard-right-cell.selected {
            background: rgba(102, 126, 234, 0.2);
            outline: 2px solid #667eea;
        }

        .clipboard-left-cell {
            min-width: 140px;
        }

        .clipboard-left-cell.dragover {
            background: rgba(40, 167, 69, 0.15);
            border: 1px dashed #28a745;
        }

        .clipboard-left-cell.updated {
            animation: pulse 1.2s ease;
        }

        .clipboard-right-cell.dragover {
            background: rgba(118, 75, 162, 0.15);
        }

        .clipboard-row-match {
            background: rgba(102, 126, 234, 0.12);
        }

        .clipboard-row-focused {
            outline: 2px solid #ff7f50;
            outline-offset: -2px;
        }

        .clipboard-preview-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
        }

        .clipboard-preview-header h3 {
            margin: 0;
            color: #2c3e50;
        }

        .clipboard-close-btn {
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 50%;
            width: 32px;
            height: 32px;
            font-size: 16px;
            cursor: pointer;
        }

        .clipboard-helper-text {
            font-size: 13px;
            color: #555;
        }

        .clipboard-empty-message {
            text-align: center;
            padding: 20px;
            color: #667;
        }

        .excel-preview-table td.dragover {
            background: rgba(118, 75, 162, 0.15);
        }

        .excel-preview-table td.dragging {
            opacity: 0.7;
        }

        /* ‚úèÔ∏è CELLULES √âDITABLES */
        .editable-cell {
            position: relative;
            cursor: pointer;
            min-height: 20px;
        }

        .editable-cell:hover {
            background: rgba(102, 126, 234, 0.1);
        }

        .editable-cell.editing {
            padding: 0;
        }

        .editable-cell input {
            width: 100%;
            border: none;
            padding: 10px 8px;
            font-size: 13px;
            background: white;
            outline: none;
        }

        .editable-cell input:focus {
            box-shadow: inset 0 0 0 2px #667eea;
        }

        /* üü† INDICATEURS DE VALIDATION */
        .validation-indicator {
            position: absolute;
            top: 2px;
            right: 2px;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            cursor: help;
        }

        .validation-indicator.error {
            background: #dc3545;
            animation: pulse 2s infinite;
        }

        .validation-indicator.warning {
            background: #ffc107;
        }

        .validation-indicator.success {
            background: #28a745;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        /* üîß BOUTONS */
        .btn {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            font-size: 14px;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
        }

        .btn-success {
            background: linear-gradient(135deg, #28a745, #20c997);
            color: white;
        }

        .btn-danger {
            background: linear-gradient(135deg, #dc3545, #c82333);
            color: white;
        }

        .btn-warning {
            background: linear-gradient(135deg, #ffc107, #e0a800);
            color: white;
        }

        .btn-excel {
            background: linear-gradient(135deg, #28a745, #20c997);
            color: white;
        }

        .btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .btn-secondary {
            background: linear-gradient(135deg, #6c757d, #5a6268);
            color: white;
        }

        .btn-compact {
            padding: 8px 12px;
            font-size: 13px;
        }

        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 25px;
            flex-wrap: wrap;
            align-items: center;
        }

        .pending-highlight {
            animation: pulse 0.8s ease-in-out 0s 3;
            outline: 2px solid #ffc107;
            outline-offset: 2px;
        }

        /* üìä TABLEAU PRINCIPAL */
        .table-container {
            background: white;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
            margin-bottom: 25px;
            max-height: 500px;
            overflow-y: auto;
            overflow-x: auto;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 14px;
        }

        th {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 15px 12px;
            text-align: left;
            font-weight: 600;
            position: sticky;
            top: 0;
            z-index: 10;
            word-break: break-word;
            white-space: normal;
        }

        td {
            padding: 12px;
            border-bottom: 1px solid #eee;
            vertical-align: top;
            word-break: break-word;
            white-space: normal;
        }

        tr:hover {
            background: rgba(102, 126, 234, 0.05);
        }

        .row-number {
            background: #f8f9fa;
            font-weight: bold;
            text-align: center;
            color: #667eea;
            width: 50px;
        }

        input.editable,
        textarea.editable {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 13px;
            transition: all 0.3s ease;
            line-height: 1.4;
        }

        textarea.editable {
            resize: vertical;
            min-height: 38px;
            overflow: hidden;
            white-space: pre-wrap;
        }

        input.editable:focus,
        textarea.editable:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        input.editable.has-error,
        textarea.editable.has-error {
            border-color: #dc3545;
            background-color: rgba(220, 53, 69, 0.05);
        }

        input.editable.has-warning,
        textarea.editable.has-warning {
            border-color: #ffc107;
            background-color: rgba(255, 193, 7, 0.05);
        }

        .copy-btn {
            background: #17a2b8;
            color: white;
            border: none;
            padding: 6px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            margin-right: 6px;
            transition: all 0.3s ease;
        }

        .copy-btn:hover {
            background: #138496;
        }

        .delete-btn {
            background: #dc3545;
            color: white;
            border: none;
            padding: 6px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s ease;
        }

        .delete-btn:hover {
            background: #c82333;
        }

        /* üìä STATISTIQUES */
        .stats {
            display: flex;
            gap: 20px;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .stats-item {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1));
            padding: 15px 20px;
            border-radius: 10px;
            font-weight: 600;
            color: #667eea;
            border: 1px solid rgba(102, 126, 234, 0.2);
        }

        .stats-item.pending-expand {
            cursor: pointer;
            position: relative;
            transition: transform 0.15s ease, box-shadow 0.2s ease;
        }

        .stats-item.pending-expand:hover {
            transform: translateY(-1px);
            box-shadow: 0 6px 18px rgba(102, 126, 234, 0.2);
        }

        .stats-item.pending-expand .stat-actions {
            display: none;
            margin-top: 10px;
            gap: 8px;
            flex-wrap: wrap;
        }

        .stats-item.pending-expand.open .stat-actions {
            display: flex;
        }

        .pending-list {
            display: none;
            margin-top: 10px;
            background: #f8f9ff;
            border: 1px solid #eef2ff;
            border-radius: 10px;
            max-height: 200px;
            overflow-y: auto;
            padding: 6px;
            gap: 6px;
        }

        .stats-item.pending-expand.open .pending-list {
            display: flex;
            flex-direction: column;
        }

        .pending-link {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 10px;
            background: #fff;
            border-radius: 8px;
            border: 1px solid #dfe3ff;
            cursor: pointer;
            transition: background 0.15s ease, transform 0.1s ease;
        }

        .pending-link:hover {
            background: #eef2ff;
            transform: translateY(-1px);
        }

        .pending-link small {
            color: #666;
        }

        .stats-item .stat-hint {
            display: block;
            margin-top: 6px;
            font-size: 12px;
            font-weight: 500;
            color: #444;
        }

        .stats-item.pending-expand .stat-hint {
            display: none;
        }

        .stats-item.pending-expand.open .stat-hint {
            display: block;
        }

        .stat-header {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .stat-toggle {
            width: 22px;
            height: 22px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            background: rgba(102, 126, 234, 0.12);
            color: #667eea;
            font-weight: 800;
            font-size: 13px;
            transition: transform 0.2s ease, background 0.2s ease;
        }

        .stats-item.pending-expand.open .stat-toggle {
            transform: rotate(90deg);
            background: rgba(102, 126, 234, 0.2);
        }

        .stats-search-row {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
            margin-top: 15px;
        }

        .stats-search-row input {
            flex: 1 1 240px;
            padding: 10px 12px;
            border-radius: 10px;
            border: 1px solid #dfe3ff;
            font-size: 14px;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.03);
        }

        .stats-search-row input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.12);
        }

        /* üìä DASHBOARD STATISTIQUES */
        .stats-dashboard {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 25px;
            margin-bottom: 30px;
        }

        .stats-card {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
        }

        .stats-card.collapsible {
            padding: 18px;
        }

        .stats-card h3 {
            color: #2c3e50;
            margin-bottom: 20px;
            font-size: 18px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .card-title-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            margin-bottom: 15px;
        }

        .collapsible-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            cursor: pointer;
            padding: 6px 4px;
        }

        .collapsible-header .header-left {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .collapsible-header .header-texts {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .collapsible-header .header-title {
            font-weight: 700;
            color: #2c3e50;
        }

        .collapsible-header .header-subtitle {
            font-size: 12px;
            color: #666;
        }

        .collapsible-header .header-chip {
            background: rgba(102, 126, 234, 0.12);
            color: #667eea;
            padding: 6px 10px;
            border-radius: 10px;
            font-weight: 700;
            font-size: 13px;
        }

        .stats-card.collapsible .stats-card-body {
            margin-top: 12px;
        }

        .stats-card.collapsed .stats-card-body {
            display: none;
        }

        .stats-card.collapsible .stat-toggle {
            transform: rotate(0deg);
        }

        .stats-card.collapsible:not(.collapsed) .stat-toggle {
            transform: rotate(90deg);
            background: rgba(102, 126, 234, 0.2);
        }

        .stats-empty-search {
            text-align: center;
            padding: 18px;
            background: #f8f9ff;
            border: 1px dashed #dfe3ff;
            border-radius: 12px;
            color: #556;
            font-weight: 600;
        }

        .activity-list {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .activity-entry {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px;
            border: 1px solid #eef2ff;
            border-radius: 8px;
            background: #f9f9ff;
        }

        .activity-entry .activity-meta {
            color: #666;
            font-size: 11px;
        }

        .activity-entry .activity-type {
            font-size: 12px;
            padding: 4px 6px;
            border-radius: 6px;
            background: #eef2ff;
            color: #445;
            font-weight: 700;
        }

        .activity-detail {
            max-height: 240px;
            overflow-y: auto;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e9ecef;
            border-radius: 4px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(135deg, #667eea, #764ba2);
            transition: width 0.3s ease;
        }

        /* üîî NOTIFICATIONS */
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, #28a745, #20c997);
            color: white;
            padding: 15px 20px;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            z-index: 1001;
            transform: translateX(100%);
            transition: all 0.3s ease;
        }

        .notification.show {
            transform: translateX(0);
        }

        .notification.error {
            background: linear-gradient(135deg, #dc3545, #c82333);
        }

        .notification.warning {
            background: linear-gradient(135deg, #ffc107, #e0a800);
        }

        /* üí° TOOLTIP */
        .tooltip {
            position: absolute;
            background: #333;
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            white-space: nowrap;
            z-index: 1002;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .tooltip.show {
            opacity: 1;
        }

        .tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: #333 transparent transparent transparent;
        }

        /* üè¢ CR√âDIT PRODUCTEUR */
        .producer-credit {
            position: fixed;
            bottom: 10px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px 12px;
            border-radius: 15px;
            font-size: 11px;
            z-index: 999;
            backdrop-filter: blur(5px);
        }

        /* üì± RESPONSIVE */
        @media (max-width: 768px) {
            .filters-grid {
                grid-template-columns: 1fr;
            }
            
            .import-methods {
                grid-template-columns: 1fr;
            }
            
            .controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            .preview-content {
                max-width: 98%;
                max-height: 95%;
                padding: 15px;
            }
            
            .stats-dashboard {
                grid-template-columns: 1fr;
            }
        }

        /* üìù SP√âCIFIQUE T√ÇCHES */
        .task-form {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .task-field {
            margin-bottom: 15px;
        }

        .task-field label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #495057;
        }

        .task-field input,
        .task-field select {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
        }

        .excel-import {
            border: 1px dashed #cfd8ff;
            border-radius: 12px;
            padding: 18px;
            background: rgba(102, 126, 234, 0.08);
            margin-top: 20px;
        }

        .excel-import h4 {
            margin-bottom: 10px;
            color: #2c3e50;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .excel-paste-area {
            width: 100%;
            min-height: 110px;
            border: 1px solid #cbd5ff;
            border-radius: 10px;
            padding: 12px;
            font-size: 14px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            resize: vertical;
            margin-bottom: 10px;
            background: white;
        }

        .excel-import-actions {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
            margin-bottom: 12px;
        }

        .excel-option {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 13px;
            color: #555;
        }

        .excel-preview-container {
            background: white;
            border-radius: 10px;
            border: 1px solid #e0e7ff;
            padding: 12px;
            overflow-x: auto;
        }

        .excel-preview-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
        }

        .excel-preview-table th,
        .excel-preview-table td {
            border: 1px solid #edf2ff;
            padding: 6px 8px;
            text-align: left;
        }

        .excel-preview-table th {
            background: #f3f5ff;
            position: relative;
            cursor: move;
            user-select: none;
        }

        .drag-handle {
            font-size: 12px;
            color: #667eea;
            margin-right: 6px;
        }

        .excel-preview-table th.dragging {
            opacity: 0.6;
            background: #e0e7ff;
        }

        .excel-preview-meta {
            font-size: 13px;
            color: #555;
            margin: 10px 0;
        }

        .excel-field-hints {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 10px;
        }

        .mapping-chip {
            background: #eef2ff;
            border: 1px solid #d7ddff;
            border-radius: 20px;
            padding: 6px 12px;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 6px;
            color: #3c4a8c;
        }

        .mapping-chip span {
            font-weight: 600;
            color: #2c3e50;
        }

        .excel-mapping-workbench {
            margin-top: 16px;
            border: 1px solid #dfe4ff;
            border-radius: 12px;
            padding: 16px;
            background: rgba(255, 255, 255, 0.9);
        }

        .excel-mapping-title {
            font-size: 13px;
            margin-bottom: 12px;
            color: #2f365f;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .excel-mapping-grid {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }

        .excel-mapping-column {
            flex: 1;
            min-width: 260px;
        }

        .excel-mapping-column h5 {
            margin-bottom: 10px;
            font-size: 14px;
            color: #2c3e50;
        }

        .excel-drop-zones {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .excel-drop-field {
            border: 1px dashed #b9c2ff;
            border-radius: 10px;
            padding: 10px;
            background: #f7f8ff;
            min-height: 64px;
            transition: background 0.2s ease, border-color 0.2s ease;
        }

        .excel-drop-field span {
            display: block;
            font-weight: 600;
            color: #2f365f;
            margin-bottom: 6px;
        }

        .excel-drop-field.drag-over {
            background: #eef2ff;
            border-color: #6b75ff;
            box-shadow: inset 0 0 0 1px #6b75ff33;
        }

        .excel-drop-field.filled {
            border-style: solid;
            background: #fff;
        }

        .excel-column-pool {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .excel-column-pool.drag-over {
            background: #f5f6ff;
            border-radius: 12px;
            padding: 6px;
        }

        .excel-column-card {
            border: 1px solid #cad1ff;
            border-radius: 10px;
            padding: 10px;
            background: #fff;
            cursor: grab;
            min-width: 140px;
            flex: 1 1 180px;
            box-shadow: 0 4px 10px rgba(102, 126, 234, 0.1);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .excel-column-card strong {
            display: block;
            color: #2c3e50;
            margin-bottom: 4px;
        }

        .excel-column-card small {
            display: block;
            color: #5b6096;
            font-size: 12px;
        }

        .excel-column-card.dragging {
            opacity: 0.6;
            transform: scale(0.97);
            box-shadow: 0 8px 14px rgba(0, 0, 0, 0.15);
        }

        .excel-unassign-zone {
            margin-top: 10px;
            border: 1px dashed #ffbdbd;
            border-radius: 10px;
            padding: 10px;
            text-align: center;
            color: #c0392b;
            font-size: 13px;
        }

        .excel-unassign-zone.drag-over {
            background: #fff5f5;
            border-color: #ff6b6b;
        }

        .excel-mapping-empty {
            text-align: center;
            padding: 15px;
            color: #667;
        }

        .excel-preview-empty {
            text-align: center;
            padding: 20px;
            color: #667;
        }

        /* üîç SP√âCIFIQUE RECHERCHE */
        .search-results-header {
            background: #f8f9fa;
            padding: 15px;
            border-bottom: 1px solid #ddd;
            border-radius: 12px 12px 0 0;
        }

        .search-results-header h4 {
            margin: 0;
            color: #2c3e50;
        }

        .result-row {
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

        .result-row:hover {
            background-color: rgba(102, 126, 234, 0.1);
        }

        .highlight-result {
            background-color: rgba(102, 126, 234, 0.2);
            animation: fadeHighlight 2s ease-out;
        }

        @keyframes fadeHighlight {
            0% { background-color: rgba(102, 126, 234, 0.4); }
            100% { background-color: transparent; }
        }
    </style>
</head>
<body>
    <div id="processingOverlay" class="processing-overlay" aria-live="polite">
        <div class="processing-card">
            <h4>Analyse en cours...</h4>
            <div class="processing-progress-text" id="processingText">Pr√©paration des donn√©es</div>
            <div class="progress-bar" aria-hidden="true">
                <div class="progress-bar-inner" id="processingProgressBar"></div>
            </div>
        </div>
    </div>
    <div class="header">
        <div class="save-status" id="saveStatus">üíæ Auto-sauvegarde activ√©e</div>
        <h1>Suivi Mise en Qualit√© - SNCF PROJECT <span class="project-martine">M.A.R.T.I.N.E</span></h1>
        <div class="controls" style="justify-content: center; margin-top: 15px;">
            <button class="btn btn-excel" onclick="exportAllToExcel()">üìä Export Global Excel</button>
            <button class="btn btn-primary" onclick="exportCompleteBackup()">üì§ T√©l√©charger Sauvegarde</button>
            <button class="btn btn-primary" onclick="importCompleteBackup()">üì• Importer Sauvegarde</button>
            <input type="file" id="backupFileInput" accept="application/json" style="display: none;" onchange="handleBackupImport()">
            <button class="btn btn-primary" onclick="expandAllTextFields()">ü™Ñ Afficher tout le texte</button>
        </div>
    </div>

    <div class="tabs-container">
        <button class="tab active" onclick="switchTab('creation')">üìù Cr√©ation</button>
        <button class="tab" onclick="switchTab('modification')">üîÑ Modification RG</button>
        <button class="tab" onclick="switchTab('resiliation')">‚ùå R√©siliation</button>
        <button class="tab" onclick="switchTab('autremodif')">üîß Autre modification</button>
        <button class="tab" onclick="switchTab('modifsurface')">üìê Modification surface</button>
        <button class="tab" onclick="switchTab('verifbaux')">‚úÖ V√©rification baux</button>
        <button class="tab" onclick="switchTab('pni')">üßæ PNI</button>
        <button class="tab" onclick="switchTab('baserg')">üóÇÔ∏è Base RG & UT</button>
        <button class="tab" onclick="switchTab('taches')">üìù T√¢ches √† faire</button>
        <button class="tab" onclick="switchTab('statistiques')">üìä Statistiques</button>
        <button class="tab" onclick="switchTab('recherche')">üîç Recherche</button>
    </div>

    <div class="main-content">
        <!-- ONGLET CR√âATION -->
        <div id="creation" class="tab-content active">
            <!-- FILTRES -->
            <div class="filters-section">
                <h4>üîç Filtres avanc√©s</h4>
                <div class="filters-grid">
                    <div class="filter-group">
                        <label>Num√©ro de bail</label>
                        <input type="text" id="filterCreationBail" placeholder="Filtrer par num√©ro de bail..." oninput="filterTable('creation')">
                    </div>
                    <div class="filter-group">
                        <label>Date de</label>
                        <input type="date" id="filterCreationDateFrom" onchange="filterTable('creation')">
                    </div>
                    <div class="filter-group">
                        <label>Date √†</label>
                        <input type="date" id="filterCreationDateTo" onchange="filterTable('creation')">
                    </div>
                    <div class="filter-group">
                        <label>Statut</label>
                        <select id="filterCreationStatus" onchange="filterTable('creation')">
                            <option value="">Tous</option>
                            <option value="traite">Trait√©</option>
                            <option value="attente">En attente</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label>RG</label>
                        <input type="text" id="filterCreationRG" placeholder="Filtrer par RG..." oninput="filterTable('creation')">
                    </div>
                    <div class="filter-group">
                        <label>UT-BAT</label>
                        <input type="text" id="filterCreationUTBAT" placeholder="Filtrer par UT-BAT..." oninput="filterTable('creation')">
                    </div>
                </div>
            </div>

            <!-- IMPORT/EXPORT -->
            <div class="import-export-section">
                <h4>üöÄ Import/Export Excel avec Validation</h4>
                <div class="import-methods">
                    <div class="import-method">
                        <h5>üìÅ Import fichier Excel</h5>
                        <p>Glissez-d√©posez votre fichier Excel ou cliquez pour s√©lectionner. Validation automatique des donn√©es selon les r√®gles SNCF.</p>
                        <div class="file-drop-zone">
                            <input type="file" class="file-input-hidden" id="fileInputCreation" accept=".xlsx,.xls,.csv" onchange="handleFileImport('creation', this)">
                            <div style="font-size: 48px; color: #667eea; margin-bottom: 15px;">üìÅ</div>
                            <div style="font-size: 16px; font-weight: 600; margin-bottom: 10px;">Cliquez ou glissez votre fichier</div>
                            <div style="color: #666; font-size: 14px;">Formats: .xlsx, .xls, .csv</div>
                        </div>
                    </div>

                    <div class="import-method">
                        <h5>üìã Copier-Coller Excel</h5>
                        <p>Copiez vos donn√©es depuis Excel et collez-les ici. Pr√©visualisation avec correction possible avant import.</p>
                        <button class="btn btn-primary" onclick="togglePasteArea('creation')">üìã Ouvrir zone de collage</button>
                        
                        <div class="paste-area" id="pasteAreaCreation">
                            <h5 style="margin-bottom: 15px; color: #2c3e50;">üìã Zone de collage Excel</h5>
                            <textarea class="paste-textarea" id="pasteTextareaCreation" 
                                      placeholder="S√©lectionnez vos donn√©es dans Excel (Ctrl+C) puis collez ici (Ctrl+V)..."></textarea>
                            <div style="display: flex; gap: 10px;">
                                <button class="btn btn-primary" onclick="analyzePastedData('creation')">üîç Analyser et pr√©visualiser</button>
                                <button class="btn btn-danger" onclick="togglePasteArea('creation')">‚ùå Annuler</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- CONTR√îLES -->
            <div class="controls">
                <button class="btn btn-primary" onclick="addRow('creation')">‚ûï Ajouter ligne</button>
                <button class="btn btn-excel" onclick="exportToExcel('creation')">üìä Exporter Excel</button>
                <button class="btn btn-danger" onclick="deleteSelectedRows('creation')">üóëÔ∏è Supprimer s√©lection</button>
                <button class="btn btn-danger" onclick="clearAll('creation')">üóëÔ∏è Effacer tout</button>
                <div class="clipboard-inline-panel">
                    <textarea id="clipboardInput-creation" placeholder="Copiez/collez vos informations √† distribuer..."></textarea>
                    <div class="clipboard-inline-actions">
                        <button class="btn btn-secondary btn-compact" type="button" onclick="openClipboardPreview('creation')">üìã Pr√©visualiser collage</button>
                    </div>
                </div>
            </div>

            <!-- TABLEAU -->
            <div class="table-container">
                <table id="creationTable">
                    <thead>
                        <tr>
                            <th style="width: 40px;">#</th>
                            <th style="width: 80px;">GA</th>
                            <th style="width: 120px;">Date Demande</th>
                            <th style="width: 120px;">Date Traitement</th>
                            <th style="width: 80px;">RG</th>
                            <th style="width: 200px;">Nom de RG</th>
                            <th style="width: 120px;">Num√©ro de Bail</th>
                            <th style="width: 100px;">UT-BAT</th>
                            <th style="width: 250px;">Commentaires</th>
                            <th style="width: 50px;">Action</th>
                        </tr>
                    </thead>
                    <tbody id="creationTableBody">
                    </tbody>
                </table>
            </div>

            <!-- STATISTIQUES -->
            <div class="stats">
                <div class="stats-item">üìä Total: <span id="creationTotalRows">0</span></div>
                <div class="stats-item">‚úÖ Trait√©s: <span id="creationProcessedRows">0</span></div>
                <div class="stats-item pending-expand" onclick="togglePendingStat(this, 'creation')">
                    <div class="stat-header">
                        <span class="stat-toggle" aria-hidden="true">‚ñ∏</span>
                        <div class="stat-main">‚è≥ En attente: <span id="creationPendingRows">0</span></div>
                    </div>
                    <span class="stat-hint">Cliquer pour ouvrir la prochaine ligne en attente</span>
                    <div class="stat-actions">
                        <button class="btn btn-secondary btn-compact" onclick="event.stopPropagation(); goToNextPending('creation');">üìç Aller aux en attente</button>
                    </div>
                    <div class="pending-list" id="creationPendingList"></div>
                </div>
                <div class="stats-item">üìà Taux: <span id="creationCompletionRate">0%</span></div>
            </div>
        </div>

        <!-- ONGLET MODIFICATION RG -->
        <div id="modification" class="tab-content">
            <!-- FILTRES -->
            <div class="filters-section">
                <h4>üîç Filtres avanc√©s</h4>
                <div class="filters-grid">
                    <div class="filter-group">
                        <label>Num√©ro de bail</label>
                        <input type="text" id="filterModificationBail" placeholder="Filtrer par num√©ro de bail..." oninput="filterTable('modification')">
                    </div>
                    <div class="filter-group">
                        <label>Date de</label>
                        <input type="date" id="filterModificationDateFrom" onchange="filterTable('modification')">
                    </div>
                    <div class="filter-group">
                        <label>Date √†</label>
                        <input type="date" id="filterModificationDateTo" onchange="filterTable('modification')">
                    </div>
                    <div class="filter-group">
                        <label>Statut</label>
                        <select id="filterModificationStatus" onchange="filterTable('modification')">
                            <option value="">Tous</option>
                            <option value="traite">Trait√©</option>
                            <option value="attente">En attente</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label>RG</label>
                        <input type="text" id="filterModificationRG" placeholder="Filtrer par RG..." oninput="filterTable('modification')">
                    </div>
                    <div class="filter-group">
                        <label>UT-BAT</label>
                        <input type="text" id="filterModificationUTBAT" placeholder="Filtrer par UT-BAT..." oninput="filterTable('modification')">
                    </div>
                </div>
            </div>

            <!-- IMPORT/EXPORT -->
            <div class="import-export-section">
                <h4>üöÄ Import/Export Excel avec Validation</h4>
                <div class="import-methods">
                    <div class="import-method">
                        <h5>üìÅ Import fichier Excel</h5>
                        <p>Import de fichiers Excel avec validation des codes RG, GA et num√©ros de bail.</p>
                        <div class="file-drop-zone">
                            <input type="file" class="file-input-hidden" id="fileInputModification" accept=".xlsx,.xls,.csv" onchange="handleFileImport('modification', this)">
                            <div style="font-size: 48px; color: #667eea; margin-bottom: 15px;">üìÅ</div>
                            <div style="font-size: 16px; font-weight: 600; margin-bottom: 10px;">Cliquez ou glissez votre fichier</div>
                            <div style="color: #666; font-size: 14px;">Validation automatique</div>
                        </div>
                    </div>

                    <div class="import-method">
                        <h5>üìã Copier-Coller Excel</h5>
                        <p>Collez vos donn√©es directement depuis Excel avec pr√©visualisation interactive.</p>
                        <button class="btn btn-primary" onclick="togglePasteArea('modification')">üìã Ouvrir zone de collage</button>
                        
                        <div class="paste-area" id="pasteAreaModification">
                            <h5 style="margin-bottom: 15px; color: #2c3e50;">üìã Zone de collage Excel</h5>
                            <textarea class="paste-textarea" id="pasteTextareaModification" 
                                      placeholder="Collez vos donn√©es Excel ici..."></textarea>
                            <div style="display: flex; gap: 10px;">
                                <button class="btn btn-primary" onclick="analyzePastedData('modification')">üîç Analyser et pr√©visualiser</button>
                                <button class="btn btn-danger" onclick="togglePasteArea('modification')">‚ùå Annuler</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- CONTR√îLES -->
            <div class="controls">
                <button class="btn btn-primary" onclick="addRow('modification')">‚ûï Ajouter ligne</button>
                <button class="btn btn-excel" onclick="exportToExcel('modification')">üìä Exporter Excel</button>
                <button class="btn btn-danger" onclick="deleteSelectedRows('modification')">üóëÔ∏è Supprimer s√©lection</button>
                <button class="btn btn-danger" onclick="clearAll('modification')">üóëÔ∏è Effacer tout</button>
                <div class="clipboard-inline-panel">
                    <textarea id="clipboardInput-modification" placeholder="Copiez/collez vos informations √† distribuer..."></textarea>
                    <div class="clipboard-inline-actions">
                        <button class="btn btn-secondary btn-compact" type="button" onclick="openClipboardPreview('modification')">üìã Pr√©visualiser collage</button>
                    </div>
                </div>
            </div>

            <!-- TABLEAU -->
            <div class="table-container">
                <table id="modificationTable">
                    <thead>
                        <tr>
                            <th style="width: 40px;">#</th>
                            <th style="width: 80px;">GA</th>
                            <th style="width: 120px;">Date Demande</th>
                            <th style="width: 120px;">Date Traitement</th>
                            <th style="width: 100px;">UT-BAT</th>
                            <th style="width: 80px;">RG</th>
                            <th style="width: 200px;">Nom de RG</th>
                            <th style="width: 120px;">Num√©ro de Bail</th>
                            <th style="width: 250px;">Commentaires</th>
                            <th style="width: 50px;">Action</th>
                        </tr>
                    </thead>
                    <tbody id="modificationTableBody">
                    </tbody>
                </table>
            </div>

            <!-- STATISTIQUES -->
            <div class="stats">
                <div class="stats-item">üìä Total: <span id="modificationTotalRows">0</span></div>
                <div class="stats-item">‚úÖ Trait√©s: <span id="modificationProcessedRows">0</span></div>
                <div class="stats-item pending-expand" onclick="togglePendingStat(this, 'modification')">
                    <div class="stat-header">
                        <span class="stat-toggle" aria-hidden="true">‚ñ∏</span>
                        <div class="stat-main">‚è≥ En attente: <span id="modificationPendingRows">0</span></div>
                    </div>
                    <span class="stat-hint">D√©plier pour sauter √† la prochaine ligne en attente</span>
                    <div class="stat-actions">
                        <button class="btn btn-secondary btn-compact" onclick="event.stopPropagation(); goToNextPending('modification');">üìç Aller aux en attente</button>
                    </div>
                    <div class="pending-list" id="modificationPendingList"></div>
                </div>
                <div class="stats-item">üìà Taux: <span id="modificationCompletionRate">0%</span></div>
            </div>
        </div>

        <!-- ONGLET R√âSILIATION -->
        <div id="resiliation" class="tab-content">
            <!-- FILTRES -->
            <div class="filters-section">
                <h4>üîç Filtres avanc√©s</h4>
                <div class="filters-grid">
                    <div class="filter-group">
                        <label>Num√©ro de bail</label>
                        <input type="text" id="filterResiliationBail" placeholder="Filtrer par num√©ro de bail..." oninput="filterTable('resiliation')">
                    </div>
                    <div class="filter-group">
                        <label>Date de</label>
                        <input type="date" id="filterResiliationDateFrom" onchange="filterTable('resiliation')">
                    </div>
                    <div class="filter-group">
                        <label>Date √†</label>
                        <input type="date" id="filterResiliationDateTo" onchange="filterTable('resiliation')">
                    </div>
                    <div class="filter-group">
                        <label>Statut</label>
                        <select id="filterResiliationStatus" onchange="filterTable('resiliation')">
                            <option value="">Tous</option>
                            <option value="traite">Trait√©</option>
                            <option value="attente">En attente</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label>UT-BAT</label>
                        <input type="text" id="filterResiliationUTBAT" placeholder="Filtrer par UT-BAT..." oninput="filterTable('resiliation')">
                    </div>
                    <div class="filter-group">
                        <label>Num√©ro Bail</label>
                        <input type="text" id="filterResiliationBail" placeholder="Filtrer par bail..." oninput="filterTable('resiliation')">
                    </div>
                </div>
            </div>

            <!-- IMPORT/EXPORT -->
            <div class="import-export-section">
                <h4>üöÄ Import/Export Excel avec Validation</h4>
                <div class="import-methods">
                    <div class="import-method">
                        <h5>üìÅ Import fichier Excel</h5>
                        <p>Import de donn√©es de r√©siliation avec validation automatique GA et num√©ros de bail.</p>
                        <div class="file-drop-zone">
                            <input type="file" class="file-input-hidden" id="fileInputResiliation" accept=".xlsx,.xls,.csv" onchange="handleFileImport('resiliation', this)">
                            <div style="font-size: 48px; color: #667eea; margin-bottom: 15px;">üìÅ</div>
                            <div style="font-size: 16px; font-weight: 600; margin-bottom: 10px;">Cliquez ou glissez votre fichier</div>
                            <div style="color: #666; font-size: 14px;">Validation GA et Num√©ros de bail</div>
                        </div>
                    </div>

                    <div class="import-method">
                        <h5>üìã Copier-Coller Excel</h5>
                        <p>Collage direct avec pr√©visualisation et correction des donn√©es de r√©siliation.</p>
                        <button class="btn btn-primary" onclick="togglePasteArea('resiliation')">üìã Ouvrir zone de collage</button>
                        
                        <div class="paste-area" id="pasteAreaResiliation">
                            <h5 style="margin-bottom: 15px; color: #2c3e50;">üìã Zone de collage Excel</h5>
                            <textarea class="paste-textarea" id="pasteTextareaResiliation" 
                                      placeholder="Collez vos donn√©es Excel ici..."></textarea>
                            <div style="display: flex; gap: 10px;">
                                <button class="btn btn-primary" onclick="analyzePastedData('resiliation')">üîç Analyser et pr√©visualiser</button>
                                <button class="btn btn-danger" onclick="togglePasteArea('resiliation')">‚ùå Annuler</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- CONTR√îLES -->
            <div class="controls">
                <button class="btn btn-primary" onclick="addRow('resiliation')">‚ûï Ajouter ligne</button>
                <button class="btn btn-excel" onclick="exportToExcel('resiliation')">üìä Exporter Excel</button>
                <button class="btn btn-danger" onclick="deleteSelectedRows('resiliation')">üóëÔ∏è Supprimer s√©lection</button>
                <button class="btn btn-danger" onclick="clearAll('resiliation')">üóëÔ∏è Effacer tout</button>
                <div class="clipboard-inline-panel">
                    <textarea id="clipboardInput-resiliation" placeholder="Copiez/collez vos informations √† distribuer..."></textarea>
                    <div class="clipboard-inline-actions">
                        <button class="btn btn-secondary btn-compact" type="button" onclick="openClipboardPreview('resiliation')">üìã Pr√©visualiser collage</button>
                    </div>
                </div>
            </div>

            <!-- TABLEAU -->
            <div class="table-container">
                <table id="resiliationTable">
                    <thead>
                        <tr>
                            <th style="width: 40px;">#</th>
                            <th style="width: 80px;">GA</th>
                            <th style="width: 120px;">Date Demande</th>
                            <th style="width: 120px;">Date Traitement</th>
                            <th style="width: 120px;">Num√©ro de Bail</th>
                            <th style="width: 100px;">UT-BAT</th>
                            <th style="width: 300px;">Commentaires</th>
                            <th style="width: 50px;">Action</th>
                        </tr>
                    </thead>
                    <tbody id="resiliationTableBody">
                    </tbody>
                </table>
            </div>

            <!-- STATISTIQUES -->
            <div class="stats">
                <div class="stats-item">üìä Total: <span id="resiliationTotalRows">0</span></div>
                <div class="stats-item">‚úÖ Trait√©s: <span id="resiliationProcessedRows">0</span></div>
                <div class="stats-item pending-expand" onclick="togglePendingStat(this, 'resiliation')">
                    <div class="stat-header">
                        <span class="stat-toggle" aria-hidden="true">‚ñ∏</span>
                        <div class="stat-main">‚è≥ En attente: <span id="resiliationPendingRows">0</span></div>
                    </div>
                    <span class="stat-hint">Cliquer pour acc√©der √† la prochaine fiche en attente</span>
                    <div class="stat-actions">
                        <button class="btn btn-secondary btn-compact" onclick="event.stopPropagation(); goToNextPending('resiliation');">üìç Aller aux en attente</button>
                    </div>
                    <div class="pending-list" id="resiliationPendingList"></div>
                </div>
                <div class="stats-item">üìà Taux: <span id="resiliationCompletionRate">0%</span></div>
            </div>
        </div>

        <!-- ONGLET AUTRE MODIFICATION -->
        <div id="autremodif" class="tab-content">
            <!-- FILTRES -->
            <div class="filters-section">
                <h4>üîç Filtres avanc√©s</h4>
                <div class="filters-grid">
                    <div class="filter-group">
                        <label>Num√©ro de bail</label>
                        <input type="text" id="filterAutremodifBail" placeholder="Filtrer par num√©ro de bail..." oninput="filterTable('autremodif')">
                    </div>
                    <div class="filter-group">
                        <label>Date de</label>
                        <input type="date" id="filterAutremodifDateFrom" onchange="filterTable('autremodif')">
                    </div>
                    <div class="filter-group">
                        <label>Date √†</label>
                        <input type="date" id="filterAutremodifDateTo" onchange="filterTable('autremodif')">
                    </div>
                    <div class="filter-group">
                        <label>Statut</label>
                        <select id="filterAutremodifStatus" onchange="filterTable('autremodif')">
                            <option value="">Tous</option>
                            <option value="traite">Trait√©</option>
                            <option value="attente">En attente</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label>Type Modification</label>
                        <input type="text" id="filterAutremodifType" placeholder="Filtrer par type..." oninput="filterTable('autremodif')">
                    </div>
                    <div class="filter-group">
                        <label>UT-BAT</label>
                        <input type="text" id="filterAutremodifUTBAT" placeholder="Filtrer par UT-BAT..." oninput="filterTable('autremodif')">
                    </div>
                </div>
            </div>

            <!-- IMPORT/EXPORT -->
            <div class="import-export-section">
                <h4>üöÄ Import/Export Excel avec Validation</h4>
                <div class="import-methods">
                    <div class="import-method">
                        <h5>üìÅ Import fichier Excel</h5>
                        <p>Import de donn√©es de modifications diverses avec validation automatique.</p>
                        <div class="file-drop-zone">
                            <input type="file" class="file-input-hidden" id="fileInputAutremodif" accept=".xlsx,.xls,.csv" onchange="handleFileImport('autremodif', this)">
                            <div style="font-size: 48px; color: #667eea; margin-bottom: 15px;">üìÅ</div>
                            <div style="font-size: 16px; font-weight: 600; margin-bottom: 10px;">Cliquez ou glissez votre fichier</div>
                            <div style="color: #666; font-size: 14px;">Validation automatique</div>
                        </div>
                    </div>

                    <div class="import-method">
                        <h5>üìã Copier-Coller Excel</h5>
                        <p>Collage direct avec validation des donn√©es de modifications.</p>
                        <button class="btn btn-primary" onclick="togglePasteArea('autremodif')">üìã Ouvrir zone de collage</button>
                        
                        <div class="paste-area" id="pasteAreaAutremodif">
                            <h5 style="margin-bottom: 15px; color: #2c3e50;">üìã Zone de collage Excel</h5>
                            <textarea class="paste-textarea" id="pasteTextareaAutremodif" 
                                      placeholder="Collez vos donn√©es Excel ici..."></textarea>
                            <div style="display: flex; gap: 10px;">
                                <button class="btn btn-primary" onclick="analyzePastedData('autremodif')">üîç Analyser et pr√©visualiser</button>
                                <button class="btn btn-danger" onclick="togglePasteArea('autremodif')">‚ùå Annuler</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- CONTR√îLES -->
            <div class="controls">
                <button class="btn btn-primary" onclick="addRow('autremodif')">‚ûï Ajouter ligne</button>
                <button class="btn btn-excel" onclick="exportToExcel('autremodif')">üìä Exporter Excel</button>
                <button class="btn btn-danger" onclick="deleteSelectedRows('autremodif')">üóëÔ∏è Supprimer s√©lection</button>
                <button class="btn btn-danger" onclick="clearAll('autremodif')">üóëÔ∏è Effacer tout</button>
                <div class="clipboard-inline-panel">
                    <textarea id="clipboardInput-autremodif" placeholder="Copiez/collez vos informations √† distribuer..."></textarea>
                    <div class="clipboard-inline-actions">
                        <button class="btn btn-secondary btn-compact" type="button" onclick="openClipboardPreview('autremodif')">üìã Pr√©visualiser collage</button>
                    </div>
                </div>
            </div>

            <!-- TABLEAU -->
            <div class="table-container">
                <table id="autremodifTable">
                    <thead>
                        <tr>
                            <th style="width: 40px;">#</th>
                            <th style="width: 80px;">GA</th>
                            <th style="width: 120px;">Date Demande</th>
                            <th style="width: 120px;">Date Traitement</th>
                            <th style="width: 120px;">Num√©ro de Bail</th>
                            <th style="width: 100px;">UT-BAT</th>
                            <th style="width: 150px;">Type Modification</th>
                            <th style="width: 250px;">Commentaires</th>
                            <th style="width: 50px;">Action</th>
                        </tr>
                    </thead>
                    <tbody id="autremodifTableBody">
                    </tbody>
                </table>
            </div>

            <!-- STATISTIQUES -->
            <div class="stats">
                <div class="stats-item">üìä Total: <span id="autremodifTotalRows">0</span></div>
                <div class="stats-item">‚úÖ Trait√©s: <span id="autremodifProcessedRows">0</span></div>
                <div class="stats-item pending-expand" onclick="togglePendingStat(this, 'autremodif')">
                    <div class="stat-header">
                        <span class="stat-toggle" aria-hidden="true">‚ñ∏</span>
                        <div class="stat-main">‚è≥ En attente: <span id="autremodifPendingRows">0</span></div>
                    </div>
                    <span class="stat-hint">Afficher la prochaine ligne en attente d'un clic</span>
                    <div class="stat-actions">
                        <button class="btn btn-secondary btn-compact" onclick="event.stopPropagation(); goToNextPending('autremodif');">üìç Aller aux en attente</button>
                    </div>
                    <div class="pending-list" id="autremodifPendingList"></div>
                </div>
                <div class="stats-item">üìà Taux: <span id="autremodifCompletionRate">0%</span></div>
            </div>
        </div>

        <!-- ONGLET MODIFICATION SURFACE -->
        <div id="modifsurface" class="tab-content">
            <!-- FILTRES -->
            <div class="filters-section">
                <h4>üîç Filtres avanc√©s</h4>
                <div class="filters-grid">
                    <div class="filter-group">
                        <label>Num√©ro de bail</label>
                        <input type="text" id="filterModifsurfaceBail" placeholder="Filtrer par num√©ro de bail..." oninput="filterTable('modifsurface')">
                    </div>
                    <div class="filter-group">
                        <label>Date de</label>
                        <input type="date" id="filterModifsurfaceDateFrom" onchange="filterTable('modifsurface')">
                    </div>
                    <div class="filter-group">
                        <label>Date √†</label>
                        <input type="date" id="filterModifsurfaceDateTo" onchange="filterTable('modifsurface')">
                    </div>
                    <div class="filter-group">
                        <label>Statut</label>
                        <select id="filterModifsurfaceStatus" onchange="filterTable('modifsurface')">
                            <option value="">Tous</option>
                            <option value="traite">Trait√©</option>
                            <option value="attente">En attente</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label>UT-BAT</label>
                        <input type="text" id="filterModifsurfaceUTBAT" placeholder="Filtrer par UT-BAT..." oninput="filterTable('modifsurface')">
                    </div>
                </div>
            </div>

            <!-- IMPORT/EXPORT -->
            <div class="import-export-section">
                <h4>üöÄ Import/Export Excel avec Validation</h4>
                <div class="import-methods">
                    <div class="import-method">
                        <h5>üìÅ Import fichier Excel</h5>
                        <p>Import avec calcul automatique des diff√©rences de surface. Les diff√©rences sont calcul√©es automatiquement (+ - -).</p>
                        <div class="file-drop-zone">
                            <input type="file" class="file-input-hidden" id="fileInputModifsurface" accept=".xlsx,.xls,.csv" onchange="handleFileImport('modifsurface', this)">
                            <div style="font-size: 48px; color: #667eea; margin-bottom: 15px;">üìÅ</div>
                            <div style="font-size: 16px; font-weight: 600; margin-bottom: 10px;">Cliquez ou glissez votre fichier</div>
                            <div style="color: #666; font-size: 14px;">Calcul automatique des diff√©rences</div>
                        </div>
                    </div>

                    <div class="import-method">
                        <h5>üìã Copier-Coller Excel</h5>
                        <p>Collage avec validation des surfaces num√©riques et calcul automatique.</p>
                        <button class="btn btn-primary" onclick="togglePasteArea('modifsurface')">üìã Ouvrir zone de collage</button>
                        
                        <div class="paste-area" id="pasteAreaModifsurface">
                            <h5 style="margin-bottom: 15px; color: #2c3e50;">üìã Zone de collage Excel</h5>
                            <textarea class="paste-textarea" id="pasteTextareaModifsurface" 
                                      placeholder="Collez vos donn√©es Excel ici..."></textarea>
                            <div style="display: flex; gap: 10px;">
                                <button class="btn btn-primary" onclick="analyzePastedData('modifsurface')">üîç Analyser et pr√©visualiser</button>
                                <button class="btn btn-danger" onclick="togglePasteArea('modifsurface')">‚ùå Annuler</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- CONTR√îLES -->
            <div class="controls">
                <button class="btn btn-primary" onclick="addRow('modifsurface')">‚ûï Ajouter ligne</button>
                <button class="btn btn-excel" onclick="exportToExcel('modifsurface')">üìä Exporter Excel</button>
                <button class="btn btn-warning" onclick="recalculateAllSurfaces()">üîÑ Recalculer toutes les diff√©rences</button>
                <button class="btn btn-danger" onclick="deleteSelectedRows('modifsurface')">üóëÔ∏è Supprimer s√©lection</button>
                <button class="btn btn-danger" onclick="clearAll('modifsurface')">üóëÔ∏è Effacer tout</button>
                <div class="clipboard-inline-panel">
                    <textarea id="clipboardInput-modifsurface" placeholder="Copiez/collez vos informations √† distribuer..."></textarea>
                    <div class="clipboard-inline-actions">
                        <button class="btn btn-secondary btn-compact" type="button" onclick="openClipboardPreview('modifsurface')">üìã Pr√©visualiser collage</button>
                    </div>
                </div>
            </div>

            <!-- TABLEAU -->
            <div class="table-container">
                <table id="modifsurfaceTable">
                    <thead>
                        <tr>
                            <th style="width: 40px;">#</th>
                            <th style="width: 80px;">GA</th>
                            <th style="width: 120px;">Date Demande</th>
                            <th style="width: 120px;">Date Traitement</th>
                            <th style="width: 120px;">Num√©ro de Bail</th>
                            <th style="width: 100px;">UT-BAT</th>
                            <th style="width: 100px;">-</th>
                            <th style="width: 100px;">+</th>
                            <th style="width: 100px;">Diff√©rence</th>
                            <th style="width: 200px;">Commentaires</th>
                            <th style="width: 50px;">Action</th>
                        </tr>
                    </thead>
                    <tbody id="modifsurfaceTableBody">
                    </tbody>
                </table>
            </div>

            <!-- STATISTIQUES SP√âCIALIS√âES -->
            <div class="stats">
                <div class="stats-item">üìä Total: <span id="modifsurfaceTotalRows">0</span></div>
                <div class="stats-item">‚úÖ Trait√©s: <span id="modifsurfaceProcessedRows">0</span></div>
                <div class="stats-item pending-expand" onclick="togglePendingStat(this, 'modifsurface')">
                    <div class="stat-header">
                        <span class="stat-toggle" aria-hidden="true">‚ñ∏</span>
                        <div class="stat-main">‚è≥ En attente: <span id="modifsurfacePendingRows">0</span></div>
                    </div>
                    <span class="stat-hint">D√©plier pour naviguer vers la prochaine surface en attente</span>
                    <div class="stat-actions">
                        <button class="btn btn-secondary btn-compact" onclick="event.stopPropagation(); goToNextPending('modifsurface');">üìç Aller aux en attente</button>
                    </div>
                    <div class="pending-list" id="modifsurfacePendingList"></div>
                </div>
                <div class="stats-item">üìà Surface totale modifi√©e: <span id="modifsurfaceTotalDifference">0 m¬≤</span></div>
                <div class="stats-item">üìà Taux: <span id="modifsurfaceCompletionRate">0%</span></div>
            </div>
        </div>

        <!-- ONGLET V√âRIFICATION BAUX -->
        <div id="verifbaux" class="tab-content">
            <!-- FILTRES -->
            <div class="filters-section">
                <h4>üîç Filtres avanc√©s</h4>
                <div class="filters-grid">
                    <div class="filter-group">
                        <label>GA</label>
                        <input type="text" id="filterVerifbauxGA" placeholder="Filtrer par GA..." oninput="filterTable('verifbaux')">
                    </div>
                    <div class="filter-group">
                        <label>RG</label>
                        <input type="text" id="filterVerifbauxRG" placeholder="Filtrer par RG..." oninput="filterTable('verifbaux')">
                    </div>
                    <div class="filter-group">
                        <label>√âtat</label>
                        <select id="filterVerifbauxEtat" onchange="filterTable('verifbaux')">
                            <option value="">Tous</option>
                            <option value="OK">OK</option>
                            <option value="NOK">NOK</option>
                            <option value="EN COURS">EN COURS</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label>R√©gion</label>
                        <input type="text" id="filterVerifbauxRegion" placeholder="Filtrer par r√©gion..." oninput="filterTable('verifbaux')">
                    </div>
                    <div class="filter-group">
                        <label>UT-BAT</label>
                        <input type="text" id="filterVerifbauxUTBAT" placeholder="Filtrer par UT-BAT..." oninput="filterTable('verifbaux')">
                    </div>
                    <div class="filter-group">
                        <label>Lieu</label>
                        <input type="text" id="filterVerifbauxLieu" placeholder="Filtrer par lieu..." oninput="filterTable('verifbaux')">
                    </div>
                </div>
            </div>

            <!-- IMPORT/EXPORT -->
            <div class="import-export-section">
                <h4>üöÄ Import/Export Excel avec Validation</h4>
                <div class="import-methods">
                    <div class="import-method">
                        <h5>üìÅ Import fichier Excel</h5>
                        <p>Import avec validation stricte des √©tats (OK/NOK/EN COURS) et v√©rification des codes RG contre la base.</p>
                        <div class="file-drop-zone">
                            <input type="file" class="file-input-hidden" id="fileInputVerifbaux" accept=".xlsx,.xls,.csv" onchange="handleFileImport('verifbaux', this)">
                            <div style="font-size: 16px; font-weight: 600; margin-bottom: 10px;">Cliquez ou glissez votre fichier</div>
                            <div style="color: #666; font-size: 14px;">Validation des √©tats OK/NOK/EN COURS</div>
                        </div>
                    </div>

                    <div class="import-method">
                        <h5>üìã Copier-Coller Excel</h5>
                        <p>Collage avec validation automatique des donn√©es de v√©rification.</p>
                        <button class="btn btn-primary" onclick="togglePasteArea('verifbaux')">üìã Ouvrir zone de collage</button>
                        
                        <div class="paste-area" id="pasteAreaVerifbaux">
                            <h5 style="margin-bottom: 15px; color: #2c3e50;">üìã Zone de collage Excel</h5>
                            <textarea class="paste-textarea" id="pasteTextareaVerifbaux" 
                                      placeholder="Collez vos donn√©es Excel ici..."></textarea>
                            <div style="display: flex; gap: 10px;">
                                <button class="btn btn-primary" onclick="analyzePastedData('verifbaux')">üîç Analyser et pr√©visualiser</button>
                                <button class="btn btn-danger" onclick="togglePasteArea('verifbaux')">‚ùå Annuler</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- CONTR√îLES -->
            <div class="controls">
                <button class="btn btn-primary" onclick="addRow('verifbaux')">‚ûï Ajouter ligne</button>
                <button class="btn btn-excel" onclick="exportToExcel('verifbaux')">üìä Exporter Excel</button>
                <button class="btn btn-warning" onclick="validateAllBauxStates()">üîç Valider tous les √©tats</button>
                <button class="btn btn-success" onclick="markAllAsOK()">‚úÖ Marquer s√©lection OK</button>
                <button class="btn btn-danger" onclick="deleteSelectedRows('verifbaux')">üóëÔ∏è Supprimer s√©lection</button>
                <button class="btn btn-danger" onclick="clearAll('verifbaux')">üóëÔ∏è Effacer tout</button>
                <div class="clipboard-inline-panel">
                    <textarea id="clipboardInput-verifbaux" placeholder="Copiez/collez vos informations √† distribuer..."></textarea>
                    <div class="clipboard-inline-actions">
                        <button class="btn btn-secondary btn-compact" type="button" onclick="openClipboardPreview('verifbaux')">üìã Pr√©visualiser collage</button>
                    </div>
                </div>
            </div>

            <!-- TABLEAU -->
            <div class="table-container">
                <table id="verifbauxTable">
                    <thead>
                        <tr>
                            <th style="width: 40px;">#</th>
                            <th style="width: 80px;">GA</th>
                            <th style="width: 100px;">UT-BAT</th>
                            <th style="width: 80px;">RG</th>
                            <th style="width: 120px;">Num√©ro Bail</th>
                            <th style="width: 100px;">√âtat</th>
                            <th style="width: 150px;">Lieu</th>
                            <th style="width: 150px;">Nom du B√¢timent</th>
                            <th style="width: 100px;">R√©gion</th>
                            <th style="width: 200px;">Commentaire</th>
                            <th style="width: 100px;">Trait√©</th>
                            <th style="width: 70px;">Action</th>
                        </tr>
                    </thead>
                    <tbody id="verifbauxTableBody">
                    </tbody>
                </table>
            </div>

            <!-- STATISTIQUES SP√âCIALIS√âES -->
            <div class="stats">
                <div class="stats-item">üìä Total: <span id="verifbauxTotalRows">0</span></div>
                <div class="stats-item" style="color: #28a745;">‚úÖ OK: <span id="verifbauxOKRows">0</span></div>
                <div class="stats-item" style="color: #dc3545;">‚ùå NOK: <span id="verifbauxNOKRows">0</span></div>
                <div class="stats-item" style="color: #ffc107;">‚è≥ En cours: <span id="verifbauxEnCoursRows">0</span></div>
                    <div class="stats-item">‚úÖ Trait√©s: <span id="verifbauxProcessedRows">0</span></div>
                    <div class="stats-item pending-expand" onclick="togglePendingStat(this, 'verifbaux')">
                        <div class="stat-header">
                            <span class="stat-toggle" aria-hidden="true">‚ñ∏</span>
                            <div class="stat-main">‚è≥ En attente: <span id="verifbauxPendingRows">0</span></div>
                        </div>
                        <span class="stat-hint">D√©plier pour retrouver la prochaine v√©rification √† traiter</span>
                        <div class="stat-actions">
                            <button class="btn btn-secondary btn-compact" onclick="event.stopPropagation(); goToNextPending('verifbaux');">üìç Aller aux en attente</button>
                        </div>
                        <div class="pending-list" id="verifbauxPendingList"></div>
                    </div>
                    <div class="stats-item">üìà Taux de validation: <span id="verifbauxValidationRate">0%</span></div>
                    <div class="stats-item">üìà Taux de traitement: <span id="verifbauxCompletionRate">0%</span></div>
                </div>
            </div>

        <!-- ONGLET PNI -->
        <div id="pni" class="tab-content">
            <!-- FILTRES -->
            <div class="filters-section">
                <h4>üîç Filtres PNI</h4>
                <div class="filters-grid">
                    <div class="filter-group">
                        <label>GA</label>
                        <input type="text" id="filterPniGA" placeholder="Filtrer par GA..." oninput="filterTable('pni')">
                    </div>
                    <div class="filter-group">
                        <label>RG</label>
                        <input type="text" id="filterPniRG" placeholder="Filtrer par RG..." oninput="filterTable('pni')">
                    </div>
                    <div class="filter-group">
                        <label>√âtat</label>
                        <select id="filterPniEtat" onchange="filterTable('pni')">
                            <option value="">Tous</option>
                            <option value="OK">OK</option>
                            <option value="NOK">NOK</option>
                            <option value="EN COURS">EN COURS</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label>UT-BAT</label>
                        <input type="text" id="filterPniUTBAT" placeholder="Filtrer par UT-BAT..." oninput="filterTable('pni')">
                    </div>
                    <div class="filter-group">
                        <label>Lieu</label>
                        <input type="text" id="filterPniLieu" placeholder="Filtrer par lieu..." oninput="filterTable('pni')">
                    </div>
                </div>
            </div>

            <!-- CONTR√îLES -->
            <div class="controls">
                <button class="btn btn-primary" onclick="addRow('pni')">‚ûï Ajouter ligne</button>
                <button class="btn btn-excel" onclick="exportToExcel('pni')">üìä Exporter Excel</button>
                <button class="btn btn-danger" onclick="deleteSelectedRows('pni')">üóëÔ∏è Supprimer s√©lection</button>
                <button class="btn btn-danger" onclick="clearAll('pni')">üóëÔ∏è Effacer tout</button>
                <div class="clipboard-inline-panel">
                    <textarea id="clipboardInput-pni" placeholder="Copiez/collez vos informations √† distribuer..."></textarea>
                    <div class="clipboard-inline-actions">
                        <button class="btn btn-secondary btn-compact" type="button" onclick="openClipboardPreview('pni')">üìã Pr√©visualiser collage</button>
                    </div>
                </div>
            </div>

            <!-- TABLEAU -->
            <div class="table-container">
                <table id="pniTable">
                    <thead>
                        <tr>
                            <th style="width: 40px;">#</th>
                            <th style="width: 80px;">GA</th>
                            <th style="width: 100px;">UT-BAT</th>
                            <th style="width: 80px;">RG</th>
                            <th style="width: 120px;">Num√©ro Bail</th>
                            <th style="width: 100px;">√âtat</th>
                            <th style="width: 150px;">Lieu</th>
                            <th style="width: 150px;">Nom du B√¢timent</th>
                            <th style="width: 100px;">R√©gion</th>
                            <th style="width: 200px;">Commentaire</th>
                            <th style="width: 100px;">Trait√©</th>
                            <th style="width: 70px;">Action</th>
                        </tr>
                    </thead>
                    <tbody id="pniTableBody"></tbody>
                </table>
            </div>

            <!-- STATISTIQUES SP√âCIALIS√âES -->
            <div class="stats">
                <div class="stats-item">üìä Total: <span id="pniTotalRows">0</span></div>
                <div class="stats-item" style="color: #28a745;">‚úÖ OK: <span id="pniOKRows">0</span></div>
                <div class="stats-item" style="color: #dc3545;">‚ùå NOK: <span id="pniNOKRows">0</span></div>
                <div class="stats-item" style="color: #ffc107;">‚è≥ En cours: <span id="pniEnCoursRows">0</span></div>
                <div class="stats-item">‚úÖ Trait√©s: <span id="pniProcessedRows">0</span></div>
                <div class="stats-item pending-expand" onclick="togglePendingStat(this, 'pni')">
                    <div class="stat-header">
                        <span class="stat-toggle" aria-hidden="true">‚ñ∏</span>
                        <div class="stat-main">‚è≥ En attente: <span id="pniPendingRows">0</span></div>
                    </div>
                    <span class="stat-hint">D√©plier pour naviguer vers la prochaine ligne PNI</span>
                    <div class="stat-actions">
                        <button class="btn btn-secondary btn-compact" onclick="event.stopPropagation(); goToNextPending('pni');">üìç Aller aux en attente</button>
                    </div>
                    <div class="pending-list" id="pniPendingList"></div>
                </div>
                <div class="stats-item">üìà Taux de validation: <span id="pniValidationRate">0%</span></div>
                <div class="stats-item">üìà Taux de traitement: <span id="pniCompletionRate">0%</span></div>
            </div>
        </div>

        <!-- ONGLET BASE RG & UT -->
        <div id="baserg" class="tab-content">
            <datalist id="rgDatalist"></datalist>
            <datalist id="rgNomDatalist"></datalist>
            <datalist id="utDatalist"></datalist>
            <datalist id="utNomDatalist"></datalist>
            <!-- IMPORT/EXPORT -->
            <div class="import-export-section">
                <h4>üóÇÔ∏è Gestion de la Base RG & UT - R√©f√©rentiels</h4>
                <div class="import-methods">
                    <div class="import-method">
                        <h5>üìÅ Import fichier RG</h5>
                        <p>Import de la base de r√©f√©rence des codes RG avec validation et d√©tection des doublons.</p>
                        <div class="file-drop-zone">
                            <input type="file" class="file-input-hidden" id="fileInputBaserg" accept=".xlsx,.xls,.csv" onchange="handleFileImport('baserg', this)">
                            <div style="font-size: 48px; color: #667eea; margin-bottom: 15px;">üìÅ</div>
                            <div style="font-size: 16px; font-weight: 600; margin-bottom: 10px;">Cliquez ou glissez votre fichier</div>
                            <div style="color: #666; font-size: 14px;">Base de r√©f√©rence RG</div>
                        </div>
                    </div>

                    <div class="import-method">
                        <h5>üìÅ Import fichier UT</h5>
                        <p>Import de la base UT (code UT et nom UT) pour alimenter les remplissages intelligents.</p>
                        <div class="file-drop-zone">
                            <input type="file" class="file-input-hidden" id="fileInputBaseut" accept=".xlsx,.xls,.csv" onchange="handleFileImport('baseut', this)">
                            <div style="font-size: 48px; color: #667eea; margin-bottom: 15px;">üìÇ</div>
                            <div style="font-size: 16px; font-weight: 600; margin-bottom: 10px;">Cliquez ou glissez votre fichier</div>
                            <div style="color: #666; font-size: 14px;">Deux colonnes : Code UT | Nom UT</div>
                        </div>
                    </div>

                    <div class="import-method">
                        <h5>üìã Copier-Coller Excel</h5>
                        <p>Mise √† jour rapide des bases RG ou UT par copier-coller avec validation automatique.</p>
                        <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                            <button class="btn btn-primary" onclick="togglePasteArea('baserg')">üìã Zone de collage RG</button>
                            <button class="btn btn-secondary" onclick="togglePasteArea('baseut')">üìã Zone de collage UT</button>
                        </div>

                        <div class="paste-area" id="pasteAreaBaserg">
                            <h5 style="margin-bottom: 15px; color: #2c3e50;">üìã Zone de collage Base RG</h5>
                            <textarea class="paste-textarea" id="pasteTextareaBaserg"
                                      placeholder="Collez vos codes RG et leurs noms ici (format: Code | Nom)..."></textarea>
                            <div style="display: flex; gap: 10px;">
                                <button class="btn btn-primary" onclick="analyzePastedData('baserg')">üîç Analyser et pr√©visualiser</button>
                                <button class="btn btn-danger" onclick="togglePasteArea('baserg')">‚ùå Annuler</button>
                            </div>
                        </div>

                        <div class="paste-area" id="pasteAreaBaseut">
                            <h5 style="margin-bottom: 15px; color: #2c3e50;">üìã Zone de collage Base UT</h5>
                            <textarea class="paste-textarea" id="pasteTextareaBaseut"
                                      placeholder="Collez vos codes UT et noms d'UT ici (format: Code UT | Nom UT)..."></textarea>
                            <div style="display: flex; gap: 10px;">
                                <button class="btn btn-primary" onclick="analyzePastedData('baseut')">üîç Analyser et pr√©visualiser</button>
                                <button class="btn btn-danger" onclick="togglePasteArea('baseut')">‚ùå Annuler</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- FILTRES SP√âCIALIS√âS -->
            <div class="filters-section">
                <h4>üîç Recherche dans la Base RG</h4>
                <div class="filters-grid">
                    <div class="filter-group">
                        <label>Code RG</label>
                        <input type="text" id="filterBasergCode" placeholder="Rechercher par code..." oninput="filterTable('baserg')">
                    </div>
                    <div class="filter-group">
                        <label>Nom de RG</label>
                        <input type="text" id="filterBasergNom" placeholder="Rechercher par nom..." oninput="filterTable('baserg')">
                    </div>
                    <div class="filter-group">
                        <label>Statut d'utilisation</label>
                        <select id="filterBasergUsage" onchange="filterTable('baserg')">
                            <option value="">Tous</option>
                            <option value="utilise">Utilis√©</option>
                            <option value="inutilise">Non utilis√©</option>
                        </select>
                    </div>
                </div>
            </div>

            <div class="filters-section">
                <h4>üîç Recherche dans la Base UT</h4>
                <div class="filters-grid">
                    <div class="filter-group">
                        <label>Code UT</label>
                        <input type="text" id="filterBaseutCode" placeholder="Rechercher par code..." oninput="filterTable('baseut')">
                    </div>
                    <div class="filter-group">
                        <label>Nom UT</label>
                        <input type="text" id="filterBaseutNom" placeholder="Rechercher par nom..." oninput="filterTable('baseut')">
                    </div>
                    <div class="filter-group">
                        <label>Statut d'utilisation</label>
                        <select id="filterBaseutUsage" onchange="filterTable('baseut')">
                            <option value="">Tous</option>
                            <option value="utilise">Utilis√©</option>
                            <option value="inutilise">Non utilis√©</option>
                        </select>
                    </div>
                </div>
            </div>

            <!-- CONTR√îLES -->
            <div class="controls">
                <button class="btn btn-primary" onclick="addRow('baserg')">‚ûï Ajouter code RG</button>
                <button class="btn btn-primary" onclick="addRow('baseut')">‚ûï Ajouter code UT</button>
                <button class="btn btn-excel" onclick="exportToExcel('baserg')">üìä Exporter Base RG</button>
                <button class="btn btn-excel" onclick="exportToExcel('baseut')">üìä Exporter Base UT</button>
                <button class="btn btn-warning" onclick="validateAllRGCodes()">üîç V√©rifier codes RG dans tous les onglets</button>
                <button class="btn btn-success" onclick="buildRGDatabase()">üîÑ Reconstruire index RG</button>
                <button class="btn btn-success" onclick="buildUTDatabase()">üîÑ Reconstruire index UT</button>
                <button class="btn btn-danger" onclick="deleteSelectedRows('baserg')">üóëÔ∏è Supprimer s√©lection RG</button>
                <button class="btn btn-danger" onclick="clearAll('baserg')">üóëÔ∏è Effacer tout RG</button>
                <div class="clipboard-inline-panel">
                    <textarea id="clipboardInput-baserg" placeholder="Collez ici les informations RG √† distribuer..."></textarea>
                    <div class="clipboard-inline-actions">
                        <button class="btn btn-secondary btn-compact" type="button" onclick="openClipboardPreview('baserg')">üìã Pr√©visualiser collage RG</button>
                    </div>
                </div>
                <button class="btn btn-danger" onclick="deleteSelectedRows('baseut')">üóëÔ∏è Supprimer s√©lection UT</button>
                <button class="btn btn-danger" onclick="clearAll('baseut')">üóëÔ∏è Effacer Base UT</button>
                <div class="clipboard-inline-panel">
                    <textarea id="clipboardInput-baseut" placeholder="Collez ici les informations UT √† distribuer..."></textarea>
                    <div class="clipboard-inline-actions">
                        <button class="btn btn-secondary btn-compact" type="button" onclick="openClipboardPreview('baseut')">üìã Pr√©visualiser collage UT</button>
                    </div>
                </div>
            </div>

            <!-- TABLEAU BASE RG -->
            <div class="table-container">
                <table id="basergTable">
                    <thead>
                        <tr>
                            <th style="width: 40px;">#</th>
                            <th style="width: 150px;">Code RG</th>
                            <th style="width: 400px;">Nom de RG</th>
                            <th style="width: 100px;">Utilisations</th>
                            <th style="width: 120px;">Derni√®re utilisation</th>
                            <th style="width: 50px;">Action</th>
                        </tr>
                    </thead>
                    <tbody id="basergTableBody">
                    </tbody>
                </table>
            </div>

            <!-- STATISTIQUES BASE RG -->
            <div class="stats">
                <div class="stats-item">üìä Total codes: <span id="basergTotalRows">0</span></div>
                <div class="stats-item">‚úÖ Utilis√©s: <span id="basergUsedRows">0</span></div>
                <div class="stats-item">‚ö†Ô∏è Non utilis√©s: <span id="basergUnusedRows">0</span></div>
                <div class="stats-item">üîç Taux d'utilisation: <span id="basergUsageRate">0%</span></div>
            </div>

            <!-- TABLEAU BASE UT -->
            <div class="table-container">
                <table id="baseutTable">
                    <thead>
                        <tr>
                            <th style="width: 40px;">#</th>
                            <th style="width: 150px;">Code UT</th>
                            <th style="width: 400px;">Nom UT</th>
                            <th style="width: 100px;">Utilisations</th>
                            <th style="width: 120px;">Derni√®re utilisation</th>
                            <th style="width: 50px;">Action</th>
                        </tr>
                    </thead>
                    <tbody id="baseutTableBody">
                    </tbody>
                </table>
            </div>

            <!-- STATISTIQUES BASE UT -->
            <div class="stats">
                <div class="stats-item">üìä Total codes UT: <span id="baseutTotalRows">0</span></div>
                <div class="stats-item">‚úÖ Utilis√©s: <span id="baseutUsedRows">0</span></div>
                <div class="stats-item">‚ö†Ô∏è Non utilis√©s: <span id="baseutUnusedRows">0</span></div>
                <div class="stats-item">üîç Taux d'utilisation: <span id="baseutUsageRate">0%</span></div>
            </div>
        </div>

        <!-- ONGLET T√ÇCHES √Ä FAIRE -->
        <div id="taches" class="tab-content">
            <div class="stats-dashboard">
                <div class="stats-card">
                    <h3>üìù Cr√©er une nouvelle t√¢che</h3>
                    <div class="task-form">
                        <div class="task-field">
                            <label>Onglet de destination :</label>
                            <select id="taskTargetTab" onchange="updateTaskFields()">
                                <option value="">S√©lectionner un onglet...</option>
                                <option value="creation">üìù Cr√©ation</option>
                                <option value="modification">üîÑ Modification RG</option>
                                <option value="resiliation">‚ùå R√©siliation</option>
                                <option value="autremodif">üîß Autre modification</option>
                                <option value="modifsurface">üìê Modification surface</option>
                                <option value="verifbaux">‚úÖ V√©rification baux</option>
                                <option value="pni">üßæ PNI</option>
                            </select>
                        </div>

                        <div class="task-field">
                            <label>Nombre de t√¢ches √† cr√©er :</label>
                            <input id="taskQuantity" type="number" min="1" max="50" value="1" />
                        </div>
                        
                        <div id="taskFieldsContainer">
                            <p style="color: #666; text-align: center; padding: 20px;">
                                S√©lectionnez un onglet pour voir les champs disponibles
                            </p>
                        </div>

                        <div style="display: flex; gap: 10px; margin-top: 20px;">
                            <button class="btn btn-success" id="transferTaskBtn" onclick="transferTask()" disabled>
                                üöÄ Transf√©rer vers l'onglet
                            </button>
                            <button class="btn btn-warning" id="pendingTaskBtn" onclick="saveTaskAsPending()" disabled>
                                ‚è≥ Mettre en attente
                            </button>
                            <button class="btn btn-primary" id="batchTaskBtn" onclick="addTaskToBatch()" disabled>
                                ‚ûï Ajouter au lot
                            </button>
                            <button class="btn btn-danger" onclick="clearTaskForm()">
                                üóëÔ∏è Effacer formulaire
                            </button>
                        </div>

                        <div class="excel-import" id="excelImportSection">
                            <h4>üìã Import rapide par copier/coller Excel</h4>
                            <p style="font-size: 13px; color: #555; margin-bottom: 10px;">
                                Collez vos lignes depuis Excel, r√©organisez les colonnes par glisser-d√©poser puis cr√©ez automatiquement autant de t√¢ches que de lignes import√©es.
                            </p>
                            <div class="excel-field-hints" id="excelFieldHints">
                                <div class="excel-preview-empty" style="padding: 8px;">
                                    S√©lectionnez un onglet pour voir l'ordre attendu des colonnes.
                                </div>
                            </div>
                            <textarea id="excelPasteArea" class="excel-paste-area" placeholder="GA[TAB]Date Demande[TAB]..."></textarea>
                            <div class="excel-import-actions">
                                <button class="btn btn-secondary" id="excelPreviewBtn" onclick="handleExcelPastePreview()">
                                    üëÄ Pr√©visualiser
                                </button>
                                <button class="btn btn-danger" type="button" onclick="resetExcelImportArea()">
                                    ‚ôªÔ∏è Effacer l'import
                                </button>
                                <button class="btn btn-success" id="excelImportBtn" onclick="createTasksFromExcelImport()" disabled>
                                    üì• Cr√©er des t√¢ches depuis l'import
                                </button>
                                <button class="btn btn-secondary" id="excelBatchImportBtn" onclick="addImportToBatch()" disabled>
                                    üì¶ Ajouter l'import au lot actif
                                </button>
                                <label class="excel-option">
                                    <input type="checkbox" id="excelSkipHeader" checked onchange="updateExcelImportButtons()">
                                    Ignorer la premi√®re ligne (ent√™tes)
                                </label>
                            </div>
                            <div class="excel-preview-meta" id="excelPreviewMeta">Aucun aper√ßu pour le moment.</div>
                            <div id="excelPreviewContainer" class="excel-preview-container">
                                <div class="excel-preview-empty">
                                    Collez vos donn√©es pour voir un aper√ßu interactif.
                                </div>
                            </div>
                            <div id="excelMappingWorkbench" class="excel-mapping-workbench">
                                <div class="excel-mapping-empty">
                                    S√©lectionnez un onglet et collez des donn√©es pour organiser vos colonnes par glisser-d√©poser.
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="stats-card">
                    <h3>üìä Statistiques des t√¢ches</h3>
                    <div style="text-align: center; margin-bottom: 20px;">
                        <div style="display: flex; justify-content: space-between; margin-bottom: 15px;">
                            <div>
                                <div class="preview-stat-number warning" id="pendingTasksCount">0</div>
                                <div class="preview-stat-label">En attente</div>
                            </div>
                            <div>
                                <div class="preview-stat-number success" id="completedTasksCount">0</div>
                                <div class="preview-stat-label">Compl√©t√©es</div>
                            </div>
                            <div>
                                <div class="preview-stat-number" id="lotTasksCount">0</div>
                                <div class="preview-stat-label">Dans les lots</div>
                            </div>
                            <div>
                                <div class="preview-stat-number" id="totalTasksCount">0</div>
                                <div class="preview-stat-label">Total</div>
                            </div>
                        </div>
                        <div class="progress-bar">
                            <div class="progress-fill" id="tasksProgress" style="width: 0%"></div>
                        </div>
                    </div>
                    <div style="display: flex; gap: 10px; justify-content: center;">
                        <button class="btn btn-primary" onclick="executeAllPendingTasks()">üöÄ Ex√©cuter toutes les t√¢ches</button>
                        <button class="btn btn-danger" onclick="clearAllPendingTasks()">üóëÔ∏è Effacer toutes les t√¢ches</button>
                        <button class="btn btn-excel" onclick="exportTasksToExcel()">üì§ Exporter les t√¢ches</button>
                    </div>
                </div>
            </div>

            <!-- TABLEAU DES T√ÇCHES EN ATTENTE -->
                <div class="table-container" style="margin-bottom: 20px;">
                <div style="display: flex; justify-content: space-between; align-items: center; gap: 10px; margin-bottom: 10px; flex-wrap: wrap;">
                    <div>
                        <h4 style="margin-bottom: 6px;">üì¶ Lot de t√¢ches √† cr√©er</h4>
                        <div id="activeBatchLabel" style="font-size: 13px; color: #555;">Aucun lot s√©lectionn√©</div>
                    </div>
                    <div style="display: flex; gap: 8px; align-items: center; flex-wrap: wrap;">
                        <input id="batchNameInput" type="text" placeholder="Nom du lot" style="padding: 8px 10px; border-radius: 6px; border: 1px solid #ddd; min-width: 180px;">
                        <button class="btn btn-secondary" onclick="createTaskBatch()">‚ûï Nouveau lot</button>
                        <select id="batchSelector" onchange="selectTaskBatch(this.value)" style="padding: 8px 10px; border-radius: 6px; border: 1px solid #ddd; min-width: 180px;">
                            <option value="">S√©lectionner un lot...</option>
                        </select>
                        <button class="btn btn-danger" onclick="deleteActiveBatch()" style="background: #f44336; border-color: #f44336;">üóëÔ∏è Supprimer le lot</button>
                        <button class="btn btn-success" id="createBatchTasksBtn" onclick="saveBatchAsPending()" disabled>
                            üöÄ Cr√©er toutes les t√¢ches du lot
                        </button>
                        <button class="btn btn-excel" onclick="exportActiveBatch()">üì§ Exporter ce lot</button>
                    </div>
                </div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 40px;">#</th>
                            <th style="width: 180px;">Onglet</th>
                            <th style="width: 320px;">R√©sum√©</th>
                            <th style="width: 140px;">Date ajout</th>
                            <th style="width: 160px;">Action</th>
                        </tr>
                    </thead>
                    <tbody id="taskBatchTableBody">
                        <tr>
                            <td colspan="5" style="text-align: center; padding: 30px; color: #666;">‚ûï Ajoutez des t√¢ches pour constituer un lot.</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <!-- TABLEAU DES T√ÇCHES EN ATTENTE -->
            <div class="table-container">
                <table id="tachesTable">
                    <thead>
                        <tr>
                            <th style="width: 40px;">#</th>
                            <th style="width: 150px;">Onglet destination</th>
                            <th style="width: 300px;">R√©sum√©</th>
                            <th style="width: 120px;">Date cr√©ation</th>
                            <th style="width: 100px;">Priorit√©</th>
                            <th style="width: 200px;">Actions</th>
                        </tr>
                    </thead>
                    <tbody id="tachesTableBody">
                        <tr>
                            <td colspan="6" style="text-align: center; padding: 40px; color: #666;">
                                üìù Aucune t√¢che en attente. Cr√©ez une nouvelle t√¢che ci-dessus !
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <!-- ONGLET STATISTIQUES -->
        <div id="statistiques" class="tab-content">
            <div class="stats-actions">
                <div class="fun-badge">Stats ludiques activ√©es</div>
                <div class="stats-search-row">
                    <input type="text" id="statsSearch" placeholder="Rechercher un onglet de statistiques..." oninput="filterStatsCards(this.value)">
                    <button class="btn btn-secondary btn-compact" onclick="filterStatsCards(document.getElementById('statsSearch').value)">üîé Filtrer</button>
                </div>
                <div class="stat-chip-row">
                    <div class="stat-chip">
                        <div class="stat-chip-label">Progression globale</div>
                        <div class="stat-chip-value" id="chipOverallRate">0%</div>
                        <div class="stat-chip-subtext" id="chipOverallSummary">Aucune donn√©e pour le moment</div>
                    </div>
                    <div class="stat-chip">
                        <div class="stat-chip-label">UT-BAT sous surveillance</div>
                        <div class="stat-chip-value" id="chipRgMultiCount">0</div>
                        <div class="stat-chip-subtext" id="chipRgDetails">Aucun doublon d√©tect√©</div>
                    </div>
                    <div class="stat-chip">
                        <div class="stat-chip-label">Alertes qualit√©</div>
                        <div class="stat-chip-value" id="chipQualityAlerts">0</div>
                        <div class="stat-chip-subtext" id="chipQualitySummary">Pas d'alerte √† signaler</div>
                    </div>
                </div>
                <button class="btn btn-excel" onclick="exportStatsReport()">üìë Exporter toutes les statistiques</button>
            </div>

            <!-- VUE D'ENSEMBLE -->
            <div class="stats-dashboard">
                <div class="stats-card">
                    <h3>üìä Vue d'ensemble globale</h3>
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                        <div style="text-align: center;">
                            <div class="preview-stat-number" id="totalGeneral">0</div>
                            <div class="preview-stat-label">Total entr√©es</div>
                        </div>
                        <div style="text-align: center;">
                            <div class="preview-stat-number success" id="traitesGeneral">0</div>
                            <div class="preview-stat-label">Trait√©s</div>
                        </div>
                        <div style="text-align: center;">
                            <div class="preview-stat-number warning" id="attenteGeneral">0</div>
                            <div class="preview-stat-label">En attente</div>
                        </div>
                        <div style="text-align: center;">
                            <div class="preview-stat-number" id="tauxGeneral">0%</div>
                            <div class="preview-stat-label">Taux global</div>
                        </div>
                    </div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressGeneral" style="width: 0%"></div>
                    </div>
                </div>

                <div class="stats-card">
                    <h3>üéØ Contr√¥les qualit√©</h3>
                    <div id="qualityStatus" style="padding: 20px; text-align: center;">
                        <div style="font-size: 48px; margin-bottom: 15px;">‚è≥</div>
                        <div style="font-size: 18px; font-weight: 600; color: #667eea;">Analyse en cours...</div>
                        <div style="color: #666; margin-top: 10px;">V√©rification automatique des donn√©es</div>
                    </div>
                    <div id="qualityAlertsContainer" class="quality-alerts"></div>
                </div>

                <div class="stats-card">
                    <div class="card-title-row">
                        <h3>üìà Activit√© r√©cente</h3>
                        <button id="activityToggleBtn" class="btn btn-secondary btn-compact" onclick="toggleActivityDetails()">‚ñ∏ D√©tails</button>
                    </div>
                    <div id="recentActivityCompact" class="activity-list">
                        <div style="color: #666; text-align: center; padding: 12px;">
                            Chargement des activit√©s r√©centes...
                        </div>
                    </div>
                    <div id="recentActivityDetail" class="activity-list activity-detail" style="display: none;">
                        <div style="color: #666; text-align: center; padding: 12px;">
                            Chargement des activit√©s d√©taill√©es...
                        </div>
                    </div>
                </div>

                <div class="stats-card accent-card">
                    <div class="card-title-row">
                        <h3>üåÄ Changements de RG surveill√©s</h3>
                        <button id="rgChangeToggleBtn" class="btn btn-secondary btn-compact" onclick="toggleRGChangePanel()">‚ñæ D√©tails</button>
                    </div>
                    <div id="rgChangePanel">
                        <div id="rgChangeMood" class="stat-chip-subtext" style="margin-bottom: 10px;">Analyse en cours...</div>
                        <div class="stat-chip-row" style="margin-bottom: 10px;">
                            <div class="stat-chip">
                                <div class="stat-chip-label">UT-BAT suivis</div>
                                <div class="stat-chip-value" id="rgChangeUTBATCount">0</div>
                                <div class="stat-chip-subtext">Pr√©sents dans les modifications RG</div>
                            </div>
                            <div class="stat-chip">
                                <div class="stat-chip-label">Changements multiples</div>
                                <div class="stat-chip-value" id="rgChangeMultiCount">0</div>
                                <div class="stat-chip-subtext">UT-BAT modifi√©s plusieurs fois</div>
                            </div>
                        </div>
                        <div class="rg-change-list" id="rgChangeDetails">
                            <div style="color: #666;">Aucun UT-BAT avec modifications r√©p√©t√©es pour le moment.</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- STATISTIQUES PAR ONGLET -->
            <div class="stats-dashboard" id="individualStats">
                <!-- G√©n√©r√© dynamiquement -->
            </div>

            <div id="statsSearchEmpty" class="stats-empty-search" style="display: none;">
                üîç Aucun onglet ne correspond √† votre recherche.
            </div>

            <!-- GRAPHIQUES -->
            <div class="stats-dashboard">
                <div class="stats-card">
                    <h3>üìà R√©partition par onglet</h3>
                    <div style="height: 300px; position: relative;">
                        <canvas id="tabsChart"></canvas>
                    </div>
                </div>

                <div class="stats-card">
                    <h3>üìä √âvolution des traitements</h3>
                    <div style="height: 300px; position: relative;">
                        <canvas id="evolutionChart"></canvas>
                    </div>
                </div>

                <div class="stats-card">
                    <h3>üéØ √âtats de v√©rification</h3>
                    <div style="height: 300px; position: relative;">
                        <canvas id="verificationChart"></canvas>
                    </div>
                </div>

                <div class="stats-card">
                    <h3>üìê Modifications de surface</h3>
                    <div style="height: 300px; position: relative;">
                        <canvas id="surfaceChart"></canvas>
                    </div>
                </div>
            </div>
        </div>

        <!-- ONGLET RECHERCHE -->
        <div id="recherche" class="tab-content">
            <div class="import-export-section">
                <h4>üîç Recherche multi-crit√®res avanc√©e</h4>
                <div class="filters-grid" style="grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); margin-bottom: 20px;">
                    <div class="filter-group">
                        <label>GA</label>
                        <input type="text" id="searchGA" placeholder="Rechercher par GA...">
                    </div>
                    <div class="filter-group">
                        <label>Code RG</label>
                        <input type="text" id="searchRG" placeholder="Rechercher par RG...">
                    </div>
                    <div class="filter-group">
                        <label>UT-BAT</label>
                        <input type="text" id="searchUTBAT" placeholder="Rechercher par UT-BAT...">
                    </div>
                    <div class="filter-group">
                        <label>Num√©ro de Bail</label>
                        <input type="text" id="searchBail" placeholder="Rechercher par bail...">
                    </div>
                    <div class="filter-group">
                        <label>Date de</label>
                        <input type="date" id="searchDateFrom">
                    </div>
                    <div class="filter-group">
                        <label>Date √†</label>
                        <input type="date" id="searchDateTo">
                    </div>
                    <div class="filter-group">
                        <label>Onglet</label>
                        <select id="searchTab">
                            <option value="">Tous les onglets</option>
                            <option value="creation">üìù Cr√©ation</option>
                            <option value="modification">üîÑ Modification RG</option>
                            <option value="resiliation">‚ùå R√©siliation</option>
                            <option value="autremodif">üîß Autre modification</option>
                            <option value="modifsurface">üìê Modification surface</option>
                            <option value="verifbaux">‚úÖ V√©rification baux</option>
                            <option value="pni">üßæ PNI</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label>Mot-cl√© libre</label>
                        <input type="text" id="searchKeyword" placeholder="Recherche libre...">
                    </div>
                </div>
                
                <div style="display: flex; gap: 15px; margin-bottom: 25px; flex-wrap: wrap;">
                    <button class="btn btn-primary" onclick="performSearch()">üîç Lancer la recherche</button>
                    <button class="btn btn-warning" onclick="performAdvancedSearch()">üéØ Recherche avanc√©e</button>
                    <button class="btn btn-danger" onclick="clearSearch()">üóëÔ∏è Effacer crit√®res</button>
                    <button class="btn btn-excel" onclick="exportSearchResults()">üìä Exporter r√©sultats</button>
                </div>

                <!-- Options de recherche avanc√©e -->
                <div class="filters-section" id="advancedSearchOptions" style="display: none;">
                    <h4>üéØ Options de recherche avanc√©e</h4>
                    <div class="filters-grid">
                        <div class="filter-group">
                            <label>Type de recherche</label>
                            <select id="searchType">
                                <option value="contains">Contient</option>
                                <option value="exact">Correspond exactement</option>
                                <option value="starts">Commence par</option>
                                <option value="ends">Finit par</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label>Num√©ro de bail (avanc√©)</label>
                            <input type="text" id="advancedSearchBail" placeholder="Filtrer par num√©ro de bail...">
                        </div>
                        <div class="filter-group">
                            <label>Statut des donn√©es</label>
                            <select id="searchStatus">
                                <option value="all">Toutes</option>
                                <option value="processed">Trait√©es seulement</option>
                                <option value="pending">En attente seulement</option>
                            </select>
                        </div>
                    </div>
                </div>
            </div>

            <!-- R√âSULTATS DE RECHERCHE -->
            <div class="table-container" id="searchResults" style="display: none;">
                <div class="search-results-header">
                    <h4>üìä R√©sultats de recherche : <span id="searchResultsCount">0</span> √©l√©ment(s) trouv√©(s)</h4>
                    <div style="margin-top: 10px; font-size: 12px; color: #666;">
                        Temps de recherche: <span id="searchTime">0</span>ms | 
                        Crit√®res: <span id="searchCriteria">Aucun</span>
                    </div>
                </div>
                <table>
                    <thead id="searchResultsHead">
                        <!-- G√©n√©r√© dynamiquement -->
                    </thead>
                    <tbody id="searchResultsBody">
                        <!-- G√©n√©r√© dynamiquement -->
                    </tbody>
                </table>
            </div>

            <!-- RECHERCHES SAUVEGARD√âES -->
            <div class="stats-card" style="margin-top: 20px;">
                <h3>üíæ Recherches sauvegard√©es</h3>
                <div id="savedSearches">
                    <p style="color: #666; text-align: center; padding: 20px;">
                        Aucune recherche sauvegard√©e. Effectuez une recherche et cliquez sur "Sauvegarder" pour la retrouver ici.
                    </p>
                </div>
                <div style="margin-top: 15px;">
                    <button class="btn btn-primary" onclick="saveCurrentSearch()" id="saveSearchBtn" disabled>
                        üíæ Sauvegarder cette recherche
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- FEN√äTRE DE PR√âVISUALISATION -->
    <div class="preview-modal" id="previewModal">
        <div class="preview-content">
            <div class="preview-header">
                <h3 id="previewTitle">üîç Pr√©visualisation des donn√©es</h3>
                <button class="close-preview" onclick="closePreview()">√ó</button>
            </div>
            
            <div class="preview-stats" id="previewStats">
                <div class="preview-stat success">
                    <div class="preview-stat-number" id="previewValidCount">0</div>
                    <div class="preview-stat-label">Valides</div>
                </div>
                <div class="preview-stat error">
                    <div class="preview-stat-number" id="previewErrorCount">0</div>
                    <div class="preview-stat-label">Erreurs</div>
                </div>
                <div class="preview-stat warning">
                    <div class="preview-stat-number" id="previewWarningCount">0</div>
                    <div class="preview-stat-label">Avertissements</div>
                </div>
                <div class="preview-stat">
                    <div class="preview-stat-number" id="previewTotalCount">0</div>
                    <div class="preview-stat-label">Total lignes</div>
                </div>
            </div>
            
            <div class="preview-table-container">
                <table class="preview-table" id="previewTable">
                    <thead id="previewTableHead">
                        <!-- G√©n√©r√© dynamiquement -->
                    </thead>
                    <tbody id="previewTableBody">
                        <!-- G√©n√©r√© dynamiquement -->
                    </tbody>
                </table>
            </div>
            
            <div style="display: flex; justify-content: space-between; gap: 15px; flex-wrap: wrap;">
                <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                    <button class="btn btn-warning" onclick="fixAllErrors()">üîß Corriger automatiquement</button>
                    <button class="btn btn-secondary" onclick="applyPreviewSmartSuggestions()">üí° Propositions intelligentes (UT/RG)</button>
                    <button class="btn btn-secondary" onclick="sortPreviewAndDeduplicate()">üßπ Trier et enlever les doublons</button>
                    <button class="btn btn-danger" onclick="removeErrorRows()">üóëÔ∏è Supprimer lignes en erreur</button>
                </div>
                <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                    <button class="btn btn-success" onclick="importPreviewedData()">‚úÖ Importer les donn√©es</button>
                    <button class="btn btn-primary" onclick="importIgnoreErrors()">‚ö†Ô∏è Importer en ignorant les erreurs</button>
                    <button class="btn btn-danger" onclick="closePreview()">‚ùå Annuler</button>
                </div>
            </div>
        </div>
    </div>

    <div class="clipboard-preview-modal" id="clipboardPreviewModal">
        <div class="clipboard-preview-content">
            <div class="clipboard-preview-header">
                <h3 id="clipboardPreviewTitle">üìã Pr√©visualisation du collage</h3>
                <button class="clipboard-close-btn" onclick="closeClipboardPreview()">√ó</button>
            </div>
            <p class="clipboard-helper-text">
                S√©lectionnez plusieurs cellules avec CTRL, faites-les glisser vers la colonne souhait√©e puis rel√¢chez pour alimenter l'onglet.
            </p>
            <div class="clipboard-preview-body">
                <div class="clipboard-panel clipboard-panel-left">
                    <h4>üìÑ Lignes de l'onglet</h4>
                    <div class="clipboard-left-layout">
                        <div class="clipboard-search-card">
                            <label for="clipboardLeftSearch">üîç Rechercher une ligne dans l'onglet</label>
                            <div class="clipboard-search-row">
                                <input type="text" id="clipboardLeftSearch" placeholder="GA, UT, RG, bail, commentaire..." oninput="filterClipboardLeft(this.value)">
                                <button class="btn btn-secondary btn-compact" type="button" onclick="resetClipboardSearch()">R√©initialiser</button>
                            </div>
                            <div class="clipboard-search-summary" id="clipboardSearchSummary">Tapez un mot-cl√© pour filtrer les lignes visibles.</div>
                            <div class="clipboard-search-matches" id="clipboardSearchMatches">
                                <div class="clipboard-empty-message">Aucun filtre appliqu√©.</div>
                            </div>
                        </div>
                        <div class="clipboard-table-wrapper" id="clipboardLeftContainer">
                            <div class="clipboard-empty-message">Aucune ligne disponible pour le moment.</div>
                        </div>
                    </div>
                </div>
                <div class="clipboard-panel">
                    <h4>üßæ Donn√©es coll√©es</h4>
                    <div class="clipboard-right-controls">
                        <button class="btn btn-secondary btn-compact" type="button" onclick="copyClipboardSelection()">üìã Copier la s√©lection</button>
                    </div>
                    <div class="clipboard-table-wrapper" id="clipboardRightContainer">
                        <div class="clipboard-empty-message">Collez vos informations puis lancez la pr√©visualisation.</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- CR√âDIT PRODUCTEUR -->
    <div class="producer-credit">
        üè¢ D√©velopp√© par Mathis Corp. - SNCF Connect
    </div>

    <script>
        // üîß CONFIGURATION GLOBALE COMPL√àTE
        const tabConfigs = {
            creation: {
                columns: ['GA', 'Date Demande', 'Date Traitement', 'RG', 'Nom de RG', 'Num√©ro de Bail', 'UT-BAT', 'Commentaires'],
                displayName: 'Cr√©ation',
                icon: 'üìù'
            },
            modification: {
                columns: ['GA', 'Date Demande', 'Date Traitement', 'UT-BAT', 'RG', 'Nom de RG', 'Num√©ro de Bail', 'Commentaires'],
                displayName: 'Modification RG',
                icon: 'üîÑ'
            },
            resiliation: {
                columns: ['GA', 'Date Demande', 'Date Traitement', 'Num√©ro de Bail', 'UT-BAT', 'Commentaires'],
                displayName: 'R√©siliation',
                icon: '‚ùå'
            },
            autremodif: {
                columns: ['GA', 'Date Demande', 'Date Traitement', 'Num√©ro de Bail', 'UT-BAT', 'Type Modification', 'Commentaires'],
                displayName: 'Autre modification',
                icon: 'üîß'
            },
            modifsurface: {
                columns: ['GA', 'Date Demande', 'Date Traitement', 'Num√©ro de Bail', 'UT-BAT', '-', '+', 'Diff√©rence', 'Commentaires'],
                displayName: 'Modification surface',
                icon: 'üìê'
            },
            verifbaux: {
                columns: ['GA', 'UT-BAT', 'RG', 'Num√©ro Bail', '√âtat', 'Lieu', 'Nom du B√¢timent', 'R√©gion', 'Commentaire', 'Trait√©'],
                displayName: 'V√©rification baux',
                icon: '‚úÖ'
            },
            pni: {
                columns: ['GA', 'UT-BAT', 'RG', 'Num√©ro Bail', '√âtat', 'Lieu', 'Nom du B√¢timent', 'R√©gion', 'Commentaire', 'Trait√©'],
                displayName: 'PNI',
                icon: 'üßæ'
            },
            baserg: {
                columns: ['Code RG', 'Nom de RG', 'Utilisations', 'Derni√®re utilisation'],
                displayName: 'Base RG & UT',
                icon: 'üóÇÔ∏è'
            },
            baseut: {
                columns: ['Code UT', 'Nom UT', 'Utilisations', 'Derni√®re utilisation'],
                displayName: 'Base UT',
                icon: 'üóÇÔ∏è'
            }
        };

        // üéØ R√àGLES DE VALIDATION SNCF COMPL√àTES
        const validationRules = {
            'GA': {
                pattern: /^[A-Za-z]{2}$/,
                message: 'GA doit contenir exactement 2 lettres (initiales)',
                type: 'strict'
            },
            'Code RG': {
                pattern: /^\d+$/,
                message: 'Code RG doit contenir uniquement des chiffres',
                type: 'strict'
            },
            'RG': {
                pattern: /^\d+$/,
                message: 'RG doit contenir uniquement des chiffres',
                type: 'strict'
            },
            'Code UT': {
                pattern: /^[A-Za-z0-9]+$/,
                message: 'Code UT doit contenir des lettres ou chiffres',
                type: 'flexible'
            },
         'Num√©ro Bail': {
                pattern: /^\d{6}$/,
                message: 'Num√©ro de bail doit contenir 6 chiffres',
                type: 'flexible'
            },
            '√âtat': {
                values: ['OK', 'NOK', 'EN COURS'],
                message: '√âtat doit √™tre OK, NOK ou EN COURS',
                type: 'strict'
            },
            'Trait√©': {
                values: ['OUI', 'NON'],
                message: 'Trait√© doit √™tre Oui ou Non',
                type: 'flexible'
            },
            '-': {
                pattern: /^\d+\.?\d*$/,
                message: 'Surface doit √™tre un nombre positif',
                type: 'flexible'
            },
            '+': {
                pattern: /^\d+\.?\d*$/,
                message: 'Surface doit √™tre un nombre positif',
                type: 'flexible'
            },
            'Type Modification': {
                values: ['Changement locataire', 'Modification bail', 'Avenant', 'Renouvellement', 'Autre'],
                message: 'Type de modification non reconnu',
                type: 'flexible'
            }
        };

        // Variables globales
        let rowCounters = {};
        let rgDatabase = {};
        let utDatabase = {};
        let columnSuggestions = {};
        let currentPreviewData = null;
        let currentTabForPreview = null;
        let searchResults = [];
        let pendingTasks = [];
        let taskDrafts = [];
        let taskBatches = [];
        let activeBatchId = null;
        let completedTasks = [];
        const selectedRowsByTab = {};
        const clipboardDataByTab = {};
        const clipboardTargetMap = new Map();
        const clipboardCellElements = new Map();
        const clipboardRowRegistry = new Map();
        const clipboardSelectedCells = new Set();
        let clipboardDragPayload = [];
        let clipboardActiveTab = null;
        let excelCellDragSource = null;
        let savedSearches = [];
        let autoSaveInterval = null;
        let excelPreviewData = [];
        let excelPreviewColumnOrder = [];
        let excelPreviewDragIndex = null;
        let excelFieldAssignments = [];
        let excelAssignmentsTab = null;
        let excelDraggedColumnIndex = null;
        Object.keys(tabConfigs).forEach(tabName => {
            selectedRowsByTab[tabName] = new Set();
        });
        let chartInstances = {};
        let activityLog = [];
        let activityDetailsExpanded = false;
        let qualityAlertsExpanded = false;
        let rgChangePanelExpanded = true;
        let rgChangeRegistry = {};
        let dismissedRGChanges = new Set();
        let fileDialogLock = false;
        let activeTabName = 'creation';
        let tabCache = null;
        let pendingStatsUpdate = null;

        // Initialisation des compteurs
        Object.keys(tabConfigs).forEach(tabName => {
            rowCounters[tabName] = 0;
        });

        // üîß FONCTIONS UTILITAIRES COMPL√àTES
        function showNotification(message, type = 'success') {
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.innerHTML = `
                <div style="display: flex; align-items: center; gap: 10px;">
                    <div style="font-size: 16px;">${getNotificationIcon(type)}</div>
                    <div>${message}</div>
                </div>
            `;
            document.body.appendChild(notification);

            setTimeout(() => notification.classList.add('show'), 100);
            setTimeout(() => {
                notification.classList.remove('show');
                setTimeout(() => notification.remove(), 300);
            }, 4000);

            // Log de l'activit√©
            logActivity(message, type);
        }

        function getNotificationIcon(type) {
            const icons = {
                'success': '‚úÖ',
                'error': '‚ùå',
                'warning': '‚ö†Ô∏è',
                'info': '‚ÑπÔ∏è'
            };
            return icons[type] || '‚ÑπÔ∏è';
        }

        function logActivity(message, type) {
            activityLog.unshift({
                timestamp: new Date(),
                message: message,
                type: type
            });
            
            // Garder seulement les 50 derni√®res activit√©s
            if (activityLog.length > 50) {
                activityLog = activityLog.slice(0, 50);
            }
            
            updateRecentActivity();
        }

        function updateRecentActivity() {
            const compact = document.getElementById('recentActivityCompact');
            const detail = document.getElementById('recentActivityDetail');
            const toggleBtn = document.getElementById('activityToggleBtn');
            if (!compact || !detail) return;

            if (toggleBtn) {
                toggleBtn.textContent = `${activityDetailsExpanded ? '‚ñæ' : '‚ñ∏'} D√©tails`;
            }

            if (activityLog.length === 0) {
                const empty = '<div style="color: #666; text-align: center; padding: 12px;">Aucune activit√© r√©cente</div>';
                compact.innerHTML = empty;
                detail.innerHTML = empty;
                return;
            }

            const renderEntries = (entries, withDate = false) => entries.map(activity => {
                const timeStr = activity.timestamp.toLocaleTimeString('fr-FR', {
                    hour: '2-digit',
                    minute: '2-digit'
                });
                const dateStr = activity.timestamp.toLocaleDateString('fr-FR', {
                    weekday: 'short',
                    day: '2-digit',
                    month: 'short'
                });
                const icon = getNotificationIcon(activity.type);

                return `
                    <div class="activity-entry">
                        <div style="font-size: 14px;">${icon}</div>
                        <div style="flex: 1;">${activity.message}</div>
                        ${withDate ? `<div class="activity-type">${activity.type}</div>` : ''}
                        <div class="activity-meta">${withDate ? `${dateStr} ¬∑ ${timeStr}` : timeStr}</div>
                    </div>
                `;
            }).join('');

            const compactEntries = activityLog.slice(0, 5);
            const detailEntries = activityLog.slice(0, 20);

            compact.innerHTML = renderEntries(compactEntries);
            detail.innerHTML = renderEntries(detailEntries, true);

            compact.style.display = activityDetailsExpanded ? 'none' : 'flex';
            detail.style.display = activityDetailsExpanded ? 'flex' : 'none';
        }

        function toggleActivityDetails() {
            activityDetailsExpanded = !activityDetailsExpanded;
            updateRecentActivity();
        }

        const cancelIdle = (handle) => {
            if (!handle) return;
            if (window.cancelIdleCallback) {
                cancelIdleCallback(handle);
            } else {
                clearTimeout(handle);
            }
        };

        function toggleRGChangePanel() {
            try {
                rgChangePanelExpanded = !rgChangePanelExpanded;
                const panel = document.getElementById('rgChangePanel');
                const toggle = document.getElementById('rgChangeToggleBtn');
                if (panel) {
                    panel.style.display = rgChangePanelExpanded ? 'block' : 'none';
                }
                if (toggle) {
                    toggle.textContent = `${rgChangePanelExpanded ? '‚ñæ' : '‚ñ∏'} D√©tails`;
                }
            } catch (error) {
                console.error('Erreur bascule panneau changements RG:', error);
            }
        }

        function showSaveStatus(message, type = 'success') {
            const status = document.getElementById('saveStatus');
            if (status) {
                const now = new Date();
                const timeStr = now.toLocaleTimeString('fr-FR', { 
                    hour: '2-digit', 
                    minute: '2-digit', 
                    second: '2-digit' 
                });
                status.textContent = `${message} - ${timeStr}`;
                status.style.color = type === 'error' ? '#dc3545' : '#28a745';
            }
        }

        function generateUniqueId() {
            return 'id_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        }

        function getTabDisplayName(tabName) {
            return tabConfigs[tabName]?.displayName || tabName;
        }

        function getTabIcon(tabName) {
            return tabConfigs[tabName]?.icon || 'üìÑ';
        }

        // üîß GESTION DES ONGLETS
        function getTabCache() {
            if (tabCache) return tabCache;

            const contents = new Map();
            document.querySelectorAll('.tab-content').forEach(content => {
                if (content.id) {
                    contents.set(content.id, content);
                }
            });

            const tabs = new Map();
            document.querySelectorAll('.tab').forEach(tab => {
                const match = tab.getAttribute('onclick')?.match(/switchTab\('([^']+)'\)/);
                if (match && match[1]) {
                    tabs.set(match[1], tab);
                }
            });

            tabCache = { contents, tabs };
            return tabCache;
        }

        function scheduleTabStatsUpdate(tabName) {
            cancelIdle(pendingStatsUpdate);

            const runUpdate = () => {
                if (tabName === 'statistiques') {
                    updateStatsDashboard();
                } else if (tabName === 'baserg') {
                    updateRGUsageStats();
                    updateUTUsageStats();
                } else if (tabName === 'taches') {
                    updateTasksStats();
                } else if (tabName !== 'recherche') {
                    updateStats(tabName);
                }
            };

            if (window.requestIdleCallback) {
                pendingStatsUpdate = requestIdleCallback(runUpdate, { timeout: 120 });
            } else {
                pendingStatsUpdate = setTimeout(runUpdate, 16);
            }
        }

        function switchTab(tabName) {
            try {
                if (tabName === activeTabName) return;

                const { contents, tabs } = getTabCache();

                contents.forEach((content, name) => {
                    content.classList.toggle('active', name === tabName);
                });

                tabs.forEach((tab, name) => {
                    tab.classList.toggle('active', name === tabName);
                });

                activeTabName = tabName;
                scheduleTabStatsUpdate(tabName);

                logActivity(`Navigation vers ${getTabDisplayName(tabName)}`, 'info');

            } catch (error) {
                console.error('Erreur changement onglet:', error);
                showNotification('‚ùå Erreur lors du changement d\'onglet', 'error');
            }
        }

        function showProcessingOverlay(message, progressText = 'Pr√©paration...') {
            const overlay = document.getElementById('processingOverlay');
            const text = document.getElementById('processingText');
            const bar = document.getElementById('processingProgressBar');

            if (text && message) text.textContent = message;
            if (bar) bar.style.width = '0%';
            if (overlay) overlay.classList.add('active');
            updateProcessingProgress(progressText, 0);
        }

        function updateProcessingProgress(progressText, percentage) {
            const text = document.getElementById('processingText');
            const bar = document.getElementById('processingProgressBar');

            if (text && progressText) text.textContent = progressText;
            if (bar && typeof percentage === 'number') {
                bar.style.width = `${Math.min(100, Math.max(0, percentage))}%`;
            }
        }

        function hideProcessingOverlay() {
            const overlay = document.getElementById('processingOverlay');
            if (overlay) overlay.classList.remove('active');
        }

        // üöÄ SYST√àME IMPORT FICHIER CORRIG√â
        function triggerFileInput(tabName) {
            const fileInput = document.getElementById(`fileInput${tabName.charAt(0).toUpperCase() + tabName.slice(1)}`);
            openFilePicker(fileInput);
        }

        function openFilePicker(fileInput) {
            if (!fileInput || fileDialogLock) return;

            fileDialogLock = true;
            fileInput.value = '';

            try {
                fileInput.click();
            } finally {
                setTimeout(() => {
                    fileDialogLock = false;
                }, 800);
            }
        }

        async function handleFileImport(tabName, input) {
            const file = input.files[0];
            if (!file) return;

            if (!window.XLSX) {
                showNotification('‚ùå Biblioth√®que Excel non charg√©e', 'error');
                return;
            }

            showNotification(`üì• Analyse du fichier "${file.name}" en cours...`, 'info');

            const reader = new FileReader();
            reader.onload = async function(e) {
                try {
                    showProcessingOverlay('Analyse du fichier en cours...', 'Pr√©paration des donn√©es...');
                    let workbook;

                    if (file.name.toLowerCase().endsWith('.csv')) {
                        const csvData = e.target.result;
                        workbook = XLSX.read(csvData, { type: 'string' });
                    } else {
                        const data = new Uint8Array(e.target.result);
                        workbook = XLSX.read(data, { type: 'array' });
                    }
                    
                    const firstSheetName = workbook.SheetNames[0];
                    const worksheet = workbook.Sheets[firstSheetName];
                    const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });

                    if (jsonData.length === 0) {
                        showNotification(`‚ùå Le fichier "${file.name}" semble vide`, 'error');
                        hideProcessingOverlay();
                        return;
                    }

                    currentPreviewData = await processImportData(jsonData, tabName);
                    currentTabForPreview = tabName;

                    notifyImportDuplicates(currentPreviewData, tabName);
                    showPreview(tabName);
                    showNotification(`‚úÖ Fichier "${file.name}" analys√© avec succ√®s`, 'success');

                } catch (error) {
                    console.error('Erreur lecture fichier:', error);
                    showNotification(`‚ùå Erreur lors de la lecture du fichier "${file.name}"`, 'error');
                } finally {
                    hideProcessingOverlay();
                }
            };
            
            if (file.name.toLowerCase().endsWith('.csv')) {
                reader.readAsText(file);
            } else {
                reader.readAsArrayBuffer(file);
            }
            
            input.value = '';
        }

        // üìã SYST√àME COPIER-COLLER
        function togglePasteArea(tabName) {
            const pasteArea = document.getElementById(`pasteArea${tabName.charAt(0).toUpperCase() + tabName.slice(1)}`);
            if (pasteArea) {
                pasteArea.classList.toggle('active');
                if (pasteArea.classList.contains('active')) {
                    const textarea = pasteArea.querySelector('textarea');
                    if (textarea) {
                        textarea.focus();
                        textarea.value = '';
                    }
                }
            }
        }

        async function analyzePastedData(tabName) {
            const textarea = document.getElementById(`pasteTextarea${tabName.charAt(0).toUpperCase() + tabName.slice(1)}`);
            if (!textarea || !textarea.value.trim()) {
                showNotification('‚ùå Aucune donn√©e √† analyser', 'error');
                return;
            }

            try {
                showNotification('üîç Analyse des donn√©es coll√©es...', 'info');
                showProcessingOverlay('Analyse des donn√©es coll√©es...', 'Pr√©paration des tableaux...');

                const rawData = textarea.value.trim();
                const lines = rawData.split('\n');
                const parsedData = lines.map(line => {
                    return line.split(/\t|;|,/).map(cell => cell.trim().replace(/"/g, ''));
                });
                
                if (parsedData.length === 0) {
                    showNotification('‚ùå Aucune donn√©e valide trouv√©e', 'error');
                    hideProcessingOverlay();
                    return;
                }

                currentPreviewData = await processImportData(parsedData, tabName);
                currentTabForPreview = tabName;

                notifyImportDuplicates(currentPreviewData, tabName);
                togglePasteArea(tabName);
                showPreview(tabName);
                showNotification(`‚úÖ ${parsedData.length} ligne(s) analys√©e(s)`, 'success');
                
            } catch (error) {
                console.error('Erreur analyse donn√©es coll√©es:', error);
                showNotification('‚ùå Erreur lors de l\'analyse des donn√©es', 'error');
            } finally {
                hideProcessingOverlay();
            }
        }

        // üîç TRAITEMENT ET VALIDATION DES DONN√âES
        function processImportData(rawData, tabName) {
            return new Promise((resolve, reject) => {
                try {
                    const expectedColumns = tabConfigs[tabName]?.columns || [];
                    const processedData = {
                        headers: [],
                        rows: [],
                        validationResults: {
                            valid: 0,
                            errors: 0,
                            warnings: 0,
                            total: 0
                        },
                        utDuplicateCount: 0,
                        utDuplicateCodes: [],
                        rgDuplicateCount: 0,
                        rgDuplicateCodes: []
                    };

                    if (rawData.length === 0) {
                        resolve(processedData);
                        return;
                    }

                    const firstRow = rawData[0];
                    const hasHeaders = detectHeaders(firstRow, expectedColumns);

                    let dataStartIndex = hasHeaders ? 1 : 0;
                    processedData.headers = hasHeaders ? firstRow : expectedColumns.slice(0, firstRow.length);

                    const totalRows = rawData.length - dataStartIndex;
                    const batchSize = 200;
                    let currentIndex = dataStartIndex;

                    const processBatch = () => {
                        const end = Math.min(currentIndex + batchSize, rawData.length);

                        for (let i = currentIndex; i < end; i++) {
                            const rawRow = rawData[i];
                            if (!rawRow || rawRow.every(cell => !cell || cell.toString().trim() === '')) {
                                continue;
                            }

                            const processedRow = {
                                data: [],
                                validations: [],
                                hasErrors: false,
                                hasWarnings: false
                            };

                            for (let j = 0; j < Math.max(rawRow.length, expectedColumns.length); j++) {
                                const cellValue = j < rawRow.length ? rawRow[j] : '';
                                const columnName = j < processedData.headers.length ? processedData.headers[j] : '';
                                const expectedColumn = j < expectedColumns.length ? expectedColumns[j] : '';

                                let cleanValue = cleanCellValue(cellValue, expectedColumn || columnName);
                                const validation = validateCell(cleanValue, expectedColumn || columnName, tabName);

                                processedRow.data.push(cleanValue);
                                processedRow.validations.push(validation);

                                if (validation.status === 'error') {
                                    processedRow.hasErrors = true;
                                    processedData.validationResults.errors++;
                                } else if (validation.status === 'warning') {
                                    processedRow.hasWarnings = true;
                                    processedData.validationResults.warnings++;
                                } else if (validation.status === 'valid') {
                                    processedData.validationResults.valid++;
                                }
                            }

                            processedData.rows.push(processedRow);
                        }

                        processedData.validationResults.total = processedData.rows.length;

                        const processedCount = processedData.rows.length;
                        const progress = totalRows > 0 ? Math.min(100, Math.round((processedCount / totalRows) * 100)) : 100;
                        updateProcessingProgress(`Analyse des lignes ${Math.min(end, rawData.length)}/${rawData.length}`, progress);

                        if (end < rawData.length) {
                            currentIndex = end;
                            setTimeout(processBatch, 0);
                        } else {
                            if (tabName === 'baseut') {
                                const codeIndex = processedData.headers.findIndex(h => h.toLowerCase().includes('code') && h.toLowerCase().includes('ut'));
                                if (codeIndex !== -1) {
                                    const utOccurrences = {};

                                    processedData.rows.forEach(row => {
                                        const normalized = normalizeUTValue(row.data[codeIndex]);
                                        if (!normalized) return;
                                        if (!utOccurrences[normalized]) {
                                            utOccurrences[normalized] = [];
                                        }
                                        utOccurrences[normalized].push(row);
                                    });

                                    const duplicateCodes = [];
                                    let duplicateRows = 0;

                                    Object.entries(utOccurrences)
                                        .filter(([, rows]) => rows.length > 1)
                                        .forEach(([code, rows]) => {
                                            duplicateCodes.push(code);
                                            duplicateRows += rows.length;
                                        });

                                    processedData.utDuplicateCodes = duplicateCodes;
                                    processedData.utDuplicateCount = duplicateRows;

                                    if (duplicateCodes.length > 0) {
                                        const duplicatesSet = new Set(duplicateCodes);

                                        processedData.rows.forEach(row => {
                                            const normalized = normalizeUTValue(row.data[codeIndex]);
                                            if (normalized && duplicatesSet.has(normalized)) {
                                                row.validations[codeIndex] = {
                                                    status: 'warning',
                                                    message: 'Code UT en double d√©tect√©',
                                                    originalValue: row.data[codeIndex]
                                                };
                                                row.hasWarnings = true;
                                            }
                                        });
                                    }
                                }
                            }

                            if (tabName === 'baserg') {
                                const codeIndex = processedData.headers.findIndex(h => h.toLowerCase().includes('code') && h.toLowerCase().includes('rg'));
                                const fallbackIndex = processedData.headers.findIndex(h => h.toLowerCase() === 'rg');
                                const targetIndex = codeIndex !== -1 ? codeIndex : fallbackIndex;

                                if (targetIndex !== -1) {
                                    const rgOccurrences = {};

                                    processedData.rows.forEach(row => {
                                        const normalized = normalizeRGValue(row.data[targetIndex]);
                                        if (!normalized) return;
                                        if (!rgOccurrences[normalized]) {
                                            rgOccurrences[normalized] = [];
                                        }
                                        rgOccurrences[normalized].push(row);
                                    });

                                    const duplicateCodes = [];
                                    let duplicateRows = 0;

                                    Object.entries(rgOccurrences)
                                        .filter(([, rows]) => rows.length > 1)
                                        .forEach(([code, rows]) => {
                                            duplicateCodes.push(code);
                                            duplicateRows += rows.length;
                                        });

                                    processedData.rgDuplicateCodes = duplicateCodes;
                                    processedData.rgDuplicateCount = duplicateRows;

                                    if (duplicateCodes.length > 0) {
                                        const duplicatesSet = new Set(duplicateCodes);

                                        processedData.rows.forEach(row => {
                                            const normalized = normalizeRGValue(row.data[targetIndex]);
                                            if (normalized && duplicatesSet.has(normalized)) {
                                                row.validations[targetIndex] = {
                                                    status: 'warning',
                                                    message: 'Code RG en double d√©tect√©',
                                                    originalValue: row.data[targetIndex]
                                                };
                                                row.hasWarnings = true;
                                            }
                                        });
                                    }
                                }
                            }

                            processedData.validationResults = { valid: 0, errors: 0, warnings: 0, total: processedData.rows.length };

                            processedData.rows.forEach(row => {
                                row.validations.forEach(validation => {
                                    if (!validation) return;
                                    if (validation.status === 'valid') processedData.validationResults.valid++;
                                    if (validation.status === 'warning') processedData.validationResults.warnings++;
                                    if (validation.status === 'error') processedData.validationResults.errors++;
                                });

                                row.hasErrors = row.validations.some(v => v && v.status === 'error');
                                row.hasWarnings = row.validations.some(v => v && v.status === 'warning');
                            });

                            resolve(processedData);
                        }
                    };

                    setTimeout(processBatch, 0);

                } catch (error) {
                    console.error('Erreur traitement donn√©es:', error);
                    showNotification('‚ùå Erreur lors du traitement des donn√©es', 'error');
                    reject(error);
                }
            });
        }

        function notifyImportDuplicates(previewData, tabName) {
            if (!previewData) return;

            if (tabName === 'baseut') {
                const duplicateRows = previewData.utDuplicateCount || 0;
                const duplicateCodes = previewData.utDuplicateCodes?.length || 0;

                if (duplicateRows > 0) {
                    const message = `‚ö†Ô∏è ${duplicateCodes} code(s) UT apparaissent en double (${duplicateRows} ligne(s)). ` +
                        'Utilisez "üßπ Trier et enlever les doublons" pour ne conserver qu\'un exemplaire.';
                    showNotification(message, 'warning');
                }
            }

            if (tabName === 'baserg') {
                const duplicateRows = previewData.rgDuplicateCount || 0;
                const duplicateCodes = previewData.rgDuplicateCodes?.length || 0;

                if (duplicateRows > 0) {
                    const message = `‚ö†Ô∏è ${duplicateCodes} code(s) RG apparaissent en double (${duplicateRows} ligne(s)). ` +
                        'Cliquez sur "üßπ Trier et enlever les doublons" pour nettoyer la pr√©visualisation.';
                    showNotification(message, 'warning');
                }
            }
        }

        function detectHeaders(firstRow, expectedColumns) {
            if (!firstRow || firstRow.length === 0) return false;
            
            const matchScore = firstRow.reduce((score, cell, index) => {
                const cellStr = cell.toString().toLowerCase();
                const expectedStr = expectedColumns[index] ? expectedColumns[index].toLowerCase() : '';
                
                if (cellStr.includes('ga') || cellStr.includes('date') || 
                    cellStr.includes('rg') || cellStr.includes('bail') ||
                    cellStr.includes('surface') || cellStr.includes('√©tat') ||
                    cellStr.includes('commentaire') || cellStr.includes('nom')) {
                    return score + 1;
                }
                
                return score;
            }, 0);
            
            return matchScore >= Math.min(2, firstRow.length * 0.3);
        }

        function deriveInitialsFromName(rawValue) {
            const parts = (rawValue || '')
                .replace(/[^a-zA-Z\s'-]/g, ' ')
                .trim()
                .split(/\s+/)
                .filter(Boolean);

            if (parts.length === 0) return '';
            if (parts.length === 1) return parts[0].substring(0, 2).toUpperCase();

            const lastWord = parts[parts.length - 1].charAt(0);
            const firstWord = parts[0].charAt(0);

            return `${lastWord}${firstWord}`.toUpperCase();
        }

        function cleanCellValue(value, columnName) {
            if (!value && value !== 0) return '';
            
            let cleanValue = value.toString().trim();
            
            if (columnName && (columnName.toLowerCase().includes('date'))) {
                if (typeof value === 'number' && value > 40000 && value < 50000) {
                    // Date Excel
                    const excelDate = new Date((value - 25569) * 86400 * 1000);
                    cleanValue = excelDate.toISOString().split('T')[0];
                } else if (typeof value === 'string') {
                    const dateFormats = [
                        /^(\d{1,2})\/(\d{1,2})\/(\d{4})$/,
                        /^(\d{4})-(\d{1,2})-(\d{1,2})$/,
                        /^(\d{1,2})-(\d{1,2})-(\d{4})$/
                    ];
                    
                    for (let format of dateFormats) {
                        const match = cleanValue.match(format);
                        if (match) {
                            if (format.source.startsWith('^(\\d{4})')) {
                                cleanValue = `${match[1]}-${match[2].padStart(2, '0')}-${match[3].padStart(2, '0')}`;
                            } else {
                                cleanValue = `${match[3]}-${match[2].padStart(2, '0')}-${match[1].padStart(2, '0')}`;
                            }
                            break;
                        }
                    }
                }
            } else if (columnName && (columnName.toLowerCase().includes('surface'))) {
                cleanValue = cleanValue.replace(',', '.');
            } else if (columnName && (columnName.toLowerCase().includes('ga'))) {
                const derived = cleanValue.length !== 2 ? deriveInitialsFromName(cleanValue) : '';
                cleanValue = (cleanValue.length === 2 ? cleanValue : derived || cleanValue).toUpperCase();
            } else if (columnName && (columnName.toLowerCase().includes('√©tat') || columnName.toLowerCase().includes('etat'))) {
                cleanValue = cleanValue.toUpperCase();
                if (cleanValue === 'ENCOURS' || cleanValue === 'EN_COURS') {
                    cleanValue = 'EN COURS';
                }
            }
            
            return cleanValue;
        }

        function validateCell(value, columnName, tabName) {
            const validation = {
                status: 'valid',
                message: '',
                originalValue: value
            };

            if (!columnName || !value) return validation;

            const normalizedValue = value.toString().trim();
            const upperValue = normalizedValue.toUpperCase();

            const allowedGAPhrases = ['TERTIAIRE', 'FERROVIAIRE', 'INDUSTRIELLE'];
            const rule = validationRules[columnName];
            if (rule) {
                if (rule.pattern && value) {
                    if (!rule.pattern.test(value)) {
                        if (columnName === 'GA' && allowedGAPhrases.includes(upperValue)) {
                            validation.status = 'valid';
                        } else {
                            validation.status = rule.type === 'flexible' ? 'warning' : 'error';
                            validation.message = rule.message;
                        }
                    }
                } else if (rule.values && value) {
                    const target = rule.values.map(v => v.toUpperCase());
                    if (!target.includes(upperValue)) {
                        validation.status = rule.type === 'flexible' ? 'warning' : 'error';
                        validation.message = rule.message;
                    }
                }
            }
            
            // Validations sp√©cifiques
            if (columnName.toLowerCase().includes('date') && value) {
                const dateRegex = /^\d{4}-\d{2}-\d{2}$/;
                if (!dateRegex.test(value)) {
                    validation.status = 'warning';
                    validation.message = 'Format de date non standard';
                } else {
                    const date = new Date(value);
                    const now = new Date();
                    if (date > now) {
                        validation.status = 'warning';
                        validation.message = 'Date dans le futur';
                    }
                }
            }
            
            // V√©rification base RG
            if ((columnName === 'RG' || columnName === 'Code RG') && value && Object.keys(rgDatabase).length > 0) {
                if (!rgDatabase[value]) {
                    validation.status = 'warning';
                    validation.message = 'Code RG non trouv√© dans la base';
                }
            }
            
            return validation;
        }

        // üîç FEN√äTRE DE PR√âVISUALISATION
        function showPreview(tabName) {
            try {
                if (!currentPreviewData) return;
                
                const modal = document.getElementById('previewModal');
                const title = document.getElementById('previewTitle');
                const tableHead = document.getElementById('previewTableHead');
                const tableBody = document.getElementById('previewTableBody');
                
                title.textContent = `üîç Pr√©visualisation - ${getTabDisplayName(tabName)}`;
                
                const results = currentPreviewData.validationResults;
                document.getElementById('previewValidCount').textContent = results.valid;
                document.getElementById('previewErrorCount').textContent = results.errors;
                document.getElementById('previewWarningCount').textContent = results.warnings;
                document.getElementById('previewTotalCount').textContent = results.total;
                
                // En-t√™te
                tableHead.innerHTML = '';
                const headerRow = document.createElement('tr');
                headerRow.innerHTML = '<th style="width: 40px;">#</th>';
                
                currentPreviewData.headers.forEach((header, index) => {
                    const th = document.createElement('th');
                    th.textContent = header;
                    th.style.minWidth = '120px';
                    headerRow.appendChild(th);
                });
                
                headerRow.innerHTML += '<th style="width: 80px;">Statut</th>';
                tableHead.appendChild(headerRow);
                
                // Corps du tableau
                tableBody.innerHTML = '';
                currentPreviewData.rows.forEach((row, rowIndex) => {
                    const tr = document.createElement('tr');
                    
                    const numberCell = document.createElement('td');
                    numberCell.textContent = rowIndex + 1;
                    numberCell.className = 'row-number';
                    tr.appendChild(numberCell);
                    
                    row.data.forEach((cellValue, cellIndex) => {
                        const td = document.createElement('td');
                        td.className = 'editable-cell';
                        td.setAttribute('data-row', rowIndex);
                        td.setAttribute('data-col', cellIndex);
                        td.textContent = cellValue;
                        
                        const validation = row.validations[cellIndex];
                        if (validation && validation.status !== 'valid') {
                            const indicator = document.createElement('div');
                            indicator.className = `validation-indicator ${validation.status}`;
                            indicator.title = validation.message;
                            td.appendChild(indicator);
                        }
                        
                        td.addEventListener('click', () => makeEditable(td, rowIndex, cellIndex));
                        tr.appendChild(td);
                    });
                    
                    const statusCell = document.createElement('td');
                    if (row.hasErrors) {
                        statusCell.innerHTML = '<span style="color: #dc3545;">‚ùå</span>';
                        statusCell.title = 'Erreurs d√©tect√©es';
                    } else if (row.hasWarnings) {
                        statusCell.innerHTML = '<span style="color: #ffc107;">‚ö†Ô∏è</span>';
                        statusCell.title = 'Avertissements';
                    } else {
                        statusCell.innerHTML = '<span style="color: #28a745;">‚úÖ</span>';
                        statusCell.title = 'Donn√©es valides';
                    }
                    tr.appendChild(statusCell);
                    
                    tableBody.appendChild(tr);
                });
                
                modal.classList.add('show');
                
            } catch (error) {
                console.error('Erreur affichage pr√©visualisation:', error);
                showNotification('‚ùå Erreur lors de l\'affichage de la pr√©visualisation', 'error');
            }
        }

        function makeEditable(cell, rowIndex, colIndex) {
            if (cell.classList.contains('editing')) return;
            
            const currentValue = cell.textContent;
            cell.classList.add('editing');
            
            const input = document.createElement('textarea');
            input.value = currentValue;
            input.className = 'editable editable-textarea';
            input.rows = 1;
            autoResizeField(input);

            cell.innerHTML = '';
            cell.appendChild(input);
            input.focus();
            input.select();
            
            function finishEditing() {
                const newValue = input.value;
                cell.classList.remove('editing');
                cell.textContent = newValue;
                
                if (currentPreviewData && currentPreviewData.rows[rowIndex]) {
                    const columnName = currentPreviewData.headers[colIndex];
                    const cleanValue = cleanCellValue(newValue, columnName);
                    const validation = validateCell(cleanValue, columnName, currentTabForPreview);
                    
                    currentPreviewData.rows[rowIndex].data[colIndex] = cleanValue;
                    currentPreviewData.rows[rowIndex].validations[colIndex] = validation;
                    
                    cell.innerHTML = '';
                    cell.textContent = cleanValue;
                    
                    if (validation.status !== 'valid') {
                        const indicator = document.createElement('div');
                        indicator.className = `validation-indicator ${validation.status}`;
                        indicator.title = validation.message;
                        cell.appendChild(indicator);
                    }
                    
                    updatePreviewStats();
                }
            }
            
            input.addEventListener('blur', finishEditing);
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    finishEditing();
                } else if (e.key === 'Escape') {
                    cell.classList.remove('editing');
                    cell.textContent = currentValue;
                }
            });
        }

        function updatePreviewStats() {
            try {
                if (!currentPreviewData) return;
                
                let valid = 0, errors = 0, warnings = 0;
                
                currentPreviewData.rows.forEach(row => {
                    row.hasErrors = false;
                    row.hasWarnings = false;
                    
                    row.validations.forEach(validation => {
                        if (validation.status === 'error') {
                            errors++;
                            row.hasErrors = true;
                        } else if (validation.status === 'warning') {
                            warnings++;
                            row.hasWarnings = true;
                        } else if (validation.status === 'valid') {
                            valid++;
                        }
                    });
                });
                
                currentPreviewData.validationResults = {
                    valid: valid,
                    errors: errors,
                    warnings: warnings,
                    total: currentPreviewData.rows.length
                };
                
                document.getElementById('previewValidCount').textContent = valid;
                document.getElementById('previewErrorCount').textContent = errors;
                document.getElementById('previewWarningCount').textContent = warnings;
                document.getElementById('previewTotalCount').textContent = currentPreviewData.rows.length;
                
            } catch (error) {
                console.error('Erreur mise √† jour stats pr√©visualisation:', error);
            }
        }

        function closePreview() {
            const modal = document.getElementById('previewModal');
            modal.classList.remove('show');
            currentPreviewData = null;
            currentTabForPreview = null;
        }

        // üìã COLLABORATION COPIER/COLLER
        function parseClipboardMatrix(value) {
            if (!value) return [];
            return value
                .split(/\r?\n/)
                .map(line => line.split(/\t|;|,/).map(cell => cell.trim()))
                .filter(row => row.some(cell => cell !== ''));
        }

        function openClipboardPreview(tabName) {
            const textarea = document.getElementById(`clipboardInput-${tabName}`);
            if (!textarea) {
                showNotification('‚ùå Zone de collage introuvable', 'error');
                return;
            }
            const data = parseClipboardMatrix(textarea.value);
            if (!data.length) {
                showNotification('‚ùå Aucune donn√©e √† pr√©visualiser', 'error');
                return;
            }
            clipboardDataByTab[tabName] = data;
            clipboardActiveTab = tabName;
            clipboardDragPayload = [];
            clipboardSelectedCells.forEach(cell => cell.classList.remove('selected'));
            clipboardSelectedCells.clear();
            const searchInput = document.getElementById('clipboardLeftSearch');
            if (searchInput) {
                searchInput.value = '';
            }
            buildClipboardLeftTable(tabName);
            buildClipboardRightTable(tabName);
            if (searchInput) {
                requestAnimationFrame(() => searchInput.focus());
            }
            const summary = document.getElementById('clipboardSearchSummary');
            if (summary) {
                summary.textContent = 'Tapez un mot-cl√© pour filtrer les lignes visibles.';
            }
            const matches = document.getElementById('clipboardSearchMatches');
            if (matches) {
                matches.innerHTML = '<div class="clipboard-empty-message">Aucun filtre appliqu√©.</div>';
            }
            const modal = document.getElementById('clipboardPreviewModal');
            const title = document.getElementById('clipboardPreviewTitle');
            if (title) {
                title.textContent = `üìã Collage pour ${getTabDisplayName(tabName)}`;
            }
            modal.classList.add('show');
        }

        function buildClipboardLeftTable(tabName) {
            const container = document.getElementById('clipboardLeftContainer');
            clipboardTargetMap.clear();
            clipboardRowRegistry.clear();
            if (!container) return;
            const sourceTable = document.getElementById(`${tabName}Table`);
            if (!sourceTable) {
                container.innerHTML = '<div class="clipboard-empty-message">Aucun tableau associ√© √† cet onglet.</div>';
                return;
            }
            const columns = tabConfigs[tabName]?.columns || [];
            const rows = sourceTable.querySelectorAll('tbody tr');
            if (!rows.length) {
                container.innerHTML = '<div class="clipboard-empty-message">Aucune ligne disponible dans l\'onglet.</div>';
                return;
            }
            const table = document.createElement('table');
            table.className = 'clipboard-table';
            const thead = document.createElement('thead');
            const headRow = document.createElement('tr');
            headRow.innerHTML = '<th style="width:60px;">#</th>';
            columns.forEach(column => {
                const th = document.createElement('th');
                th.textContent = column;
                headRow.appendChild(th);
            });
            thead.appendChild(headRow);
            table.appendChild(thead);
            const tbody = document.createElement('tbody');
            rows.forEach((row, rowIndex) => {
                const tr = document.createElement('tr');
                const rowNumber = row.querySelector('.row-number')?.textContent?.trim() || (rowIndex + 1).toString();
                const rowKey = `clipboard-row-${tabName}-${rowIndex}`;
                const numberCell = document.createElement('td');
                numberCell.textContent = rowNumber;
                tr.appendChild(numberCell);
                const inputs = row.querySelectorAll('input, textarea, select');
                columns.forEach((column, columnIndex) => {
                    const td = document.createElement('td');
                    td.className = 'clipboard-left-cell';
                    const targetInput = inputs[columnIndex];
                    const currentValue = targetInput ? (targetInput.value || targetInput.textContent || '') : '';
                    td.textContent = currentValue;
                    const targetId = `clip-${tabName}-${rowIndex}-${columnIndex}`;
                    td.dataset.targetId = targetId;
                    td.dataset.tabName = tabName;
                    clipboardTargetMap.set(targetId, { input: targetInput, displayCell: td, rowElement: row });
                    td.addEventListener('dragover', handleClipboardLeftDragOver);
                    td.addEventListener('dragleave', handleClipboardLeftDragLeave);
                    td.addEventListener('drop', handleClipboardLeftDrop);
                    tr.appendChild(td);
                });
                const previewPieces = Array.from(inputs)
                    .slice(0, 3)
                    .map(input => (input.value || input.textContent || '').trim())
                    .filter(Boolean)
                    .slice(0, 2);
                tr.dataset.rowKey = rowKey;
                tr.id = rowKey;
                tr.dataset.rowNumber = rowNumber;
                tr.dataset.previewValue = previewPieces.join(' ‚Ä¢ ');
                tr.dataset.searchValue = tr.textContent.toLowerCase();
                clipboardRowRegistry.set(rowKey, tr);
                tbody.appendChild(tr);
            });
            table.appendChild(tbody);
            container.innerHTML = '';
            container.appendChild(table);
            const searchInput = document.getElementById('clipboardLeftSearch');
            const initialTerm = searchInput ? searchInput.value : '';
            filterClipboardLeft(initialTerm);
        }

        function buildClipboardRightTable(tabName) {
            const container = document.getElementById('clipboardRightContainer');
            clipboardCellElements.clear();
            if (!container) return;
            const data = clipboardDataByTab[tabName] || [];
            if (!data.length) {
                container.innerHTML = '<div class="clipboard-empty-message">Collez vos informations pour commencer.</div>';
                return;
            }
            const maxColumns = data.reduce((max, row) => Math.max(max, row.length), 0);
            const table = document.createElement('table');
            table.className = 'clipboard-table';
            const thead = document.createElement('thead');
            const headRow = document.createElement('tr');
            for (let col = 0; col < maxColumns; col++) {
                const th = document.createElement('th');
                th.textContent = `Col ${col + 1}`;
                headRow.appendChild(th);
            }
            thead.appendChild(headRow);
            table.appendChild(thead);
            const tbody = document.createElement('tbody');
            data.forEach((row, rowIndex) => {
                const tr = document.createElement('tr');
                for (let colIndex = 0; colIndex < maxColumns; colIndex++) {
                    const td = document.createElement('td');
                    td.className = 'clipboard-right-cell';
                    td.contentEditable = true;
                    const cellValue = row[colIndex] || '';
                    td.textContent = cellValue;
                    const cellKey = `${tabName}-${rowIndex}-${colIndex}`;
                    td.dataset.cellKey = cellKey;
                    td.dataset.clipboardTab = tabName;
                    clipboardCellElements.set(cellKey, td);
                    td.draggable = true;
                    td.addEventListener('dragstart', handleClipboardRightCellDragStart);
                    td.addEventListener('dragend', handleClipboardRightCellDragEnd);
                    td.addEventListener('dragover', handleClipboardRightCellDragOver);
                    td.addEventListener('dragleave', handleClipboardRightCellDragLeave);
                    td.addEventListener('drop', handleClipboardRightCellDrop);
                    td.addEventListener('input', () => updateClipboardCellValue(tabName, rowIndex, colIndex, td.textContent));
                    td.addEventListener('click', event => handleClipboardRightCellClick(event, td));
                    tr.appendChild(td);
                }
                tbody.appendChild(tr);
            });
            table.appendChild(tbody);
            container.innerHTML = '';
            container.appendChild(table);
        }

        function updateClipboardCellValue(tabName, rowIndex, columnIndex, value) {
            if (!clipboardDataByTab[tabName]) clipboardDataByTab[tabName] = [];
            if (!clipboardDataByTab[tabName][rowIndex]) clipboardDataByTab[tabName][rowIndex] = [];
            clipboardDataByTab[tabName][rowIndex][columnIndex] = value;
        }

        function handleClipboardRightCellClick(event, cell) {
            if (!(event.ctrlKey || event.metaKey)) return;
            event.preventDefault();
            if (clipboardSelectedCells.has(cell)) {
                clipboardSelectedCells.delete(cell);
                cell.classList.remove('selected');
            } else {
                clipboardSelectedCells.add(cell);
                cell.classList.add('selected');
            }
        }

        function handleClipboardRightCellDragStart(event) {
            const cell = event.currentTarget;
            const cellKey = cell.dataset.cellKey;
            if (!cellKey) return;
            if (clipboardSelectedCells.has(cell)) {
                clipboardDragPayload = Array.from(clipboardSelectedCells).map(selected => selected.dataset.cellKey);
            } else {
                clipboardDragPayload = [cellKey];
            }
            event.dataTransfer.effectAllowed = 'copyMove';
            event.dataTransfer.setData('text/plain', clipboardDragPayload.join('|'));
            cell.classList.add('dragging');
        }

        function handleClipboardRightCellDragEnd(event) {
            event.currentTarget.classList.remove('dragging');
        }

        function handleClipboardRightCellDragOver(event) {
            event.preventDefault();
            event.currentTarget.classList.add('dragover');
        }

        function handleClipboardRightCellDragLeave(event) {
            event.currentTarget.classList.remove('dragover');
        }

        function handleClipboardRightCellDrop(event) {
            event.preventDefault();
            const targetCell = event.currentTarget;
            targetCell.classList.remove('dragover');
            const payloadKeys = clipboardDragPayload.length ? clipboardDragPayload : (event.dataTransfer.getData('text/plain')?.split('|') || []);
            if (payloadKeys.length !== 1) {
                clipboardDragPayload = [];
                return;
            }
            const sourceKey = payloadKeys[0];
            const sourceCell = clipboardCellElements.get(sourceKey);
            if (!sourceCell || sourceCell === targetCell) {
                clipboardDragPayload = [];
                return;
            }
            const sourceValue = sourceCell.textContent;
            const targetValue = targetCell.textContent;
            sourceCell.textContent = targetValue;
            targetCell.textContent = sourceValue;
            const [tabName, rowIndex, colIndex] = sourceKey.split('-');
            updateClipboardCellValue(tabName, Number(rowIndex), Number(colIndex), targetValue);
            const [targetTab, targetRow, targetCol] = (targetCell.dataset.cellKey || '').split('-');
            if (targetTab) {
                updateClipboardCellValue(targetTab, Number(targetRow), Number(targetCol), sourceValue);
            }
            clipboardDragPayload = [];
        }

        function handleClipboardLeftDragOver(event) {
            event.preventDefault();
            event.currentTarget.classList.add('dragover');
        }

        function handleClipboardLeftDragLeave(event) {
            event.currentTarget.classList.remove('dragover');
        }

        function getClipboardPayloadValues() {
            const keys = clipboardDragPayload.length
                ? clipboardDragPayload
                : Array.from(clipboardSelectedCells).map(cell => cell.dataset.cellKey);
            if (!keys.length) return [];
            return keys.map(key => (clipboardCellElements.get(key)?.textContent || '').trim()).filter(value => value !== '');
        }

        function handleClipboardLeftDrop(event) {
            event.preventDefault();
            const cell = event.currentTarget;
            cell.classList.remove('dragover');
            const targetId = cell.dataset.targetId;
            if (!targetId) return;
            const values = getClipboardPayloadValues();
            const combined = values.length ? values.join(' / ') : '';
            applyClipboardValueToTarget(targetId, combined);
            clipboardDragPayload = [];
            cell.textContent = combined;
            cell.classList.add('updated');
            setTimeout(() => cell.classList.remove('updated'), 900);
        }

        function applyClipboardValueToTarget(targetId, value) {
            const targetInfo = clipboardTargetMap.get(targetId);
            if (!targetInfo || !targetInfo.input) return;
            targetInfo.input.value = value;
            targetInfo.input.dispatchEvent(new Event('input', { bubbles: true }));
            if (targetInfo.rowElement) {
                targetInfo.rowElement.classList.add('pending-highlight');
                setTimeout(() => targetInfo.rowElement.classList.remove('pending-highlight'), 1200);
            }
        }

        function filterClipboardLeft(term = '') {
            const rows = document.querySelectorAll('#clipboardLeftContainer tbody tr');
            const normalized = (term || '').toLowerCase().trim();
            const summary = document.getElementById('clipboardSearchSummary');
            const matchesContainer = document.getElementById('clipboardSearchMatches');
            const matches = [];

            rows.forEach(row => {
                const rowValue = row.dataset.searchValue || '';
                const isMatch = !normalized || rowValue.includes(normalized);
                row.style.display = isMatch ? '' : 'none';
                if (normalized) {
                    row.classList.toggle('clipboard-row-match', isMatch);
                } else {
                    row.classList.remove('clipboard-row-match');
                }
                if (normalized && isMatch) {
                    matches.push({
                        key: row.dataset.rowKey,
                        label: row.dataset.rowNumber || '',
                        preview: row.dataset.previewValue || ''
                    });
                }
            });

            if (summary) {
                if (!rows.length) {
                    summary.textContent = 'Aucune ligne disponible dans cet onglet.';
                } else if (normalized) {
                    summary.textContent = `${matches.length} ligne(s) correspondent √† "${term}"`;
                } else {
                    summary.textContent = 'Tapez un mot-cl√© pour filtrer les lignes visibles.';
                }
            }

            if (matchesContainer) {
                matchesContainer.innerHTML = '';
                if (!rows.length) {
                    matchesContainer.innerHTML = '<div class="clipboard-empty-message">Ajoutez des lignes dans l\'onglet pour commencer.</div>';
                } else if (!normalized) {
                    matchesContainer.innerHTML = '<div class="clipboard-empty-message">Aucun filtre appliqu√©.</div>';
                } else if (!matches.length) {
                    matchesContainer.innerHTML = '<div class="clipboard-empty-message">Aucun r√©sultat. Essayez un autre mot-cl√©.</div>';
                } else {
                    matches.slice(0, 8).forEach(match => {
                        const button = document.createElement('button');
                        button.type = 'button';
                        button.innerHTML = `<strong>Ligne ${match.label}</strong><span>${match.preview || 'Aucune donn√©e visible'}</span>`;
                        button.addEventListener('click', () => focusClipboardRow(match.key));
                        matchesContainer.appendChild(button);
                    });
                    focusClipboardRow(matches[0].key, true);
                }
            }
        }

        function focusClipboardRow(rowKey, silent = false) {
            if (!rowKey) return;
            const rowElement = clipboardRowRegistry.get(rowKey) || document.querySelector(`#clipboardLeftContainer [data-row-key="${rowKey}"]`);
            if (!rowElement) return;
            const wrapper = document.getElementById('clipboardLeftContainer');
            if (wrapper) {
                const rowRect = rowElement.getBoundingClientRect();
                const wrapperRect = wrapper.getBoundingClientRect();
                const offset = rowRect.top - wrapperRect.top;
                wrapper.scrollTop += offset - wrapper.clientHeight / 2 + rowElement.offsetHeight / 2;
            }
            if (!silent) {
                rowElement.classList.add('clipboard-row-focused');
                setTimeout(() => rowElement.classList.remove('clipboard-row-focused'), 1200);
            }
        }

        function resetClipboardSearch() {
            const searchInput = document.getElementById('clipboardLeftSearch');
            if (!searchInput) return;
            searchInput.value = '';
            filterClipboardLeft('');
            searchInput.focus();
        }

        function copyClipboardSelection() {
            if (clipboardSelectedCells.size === 0) {
                showNotification('‚ÑπÔ∏è Aucune cellule s√©lectionn√©e', 'info');
                return;
            }
            const text = Array.from(clipboardSelectedCells)
                .map(cell => cell.textContent.trim())
                .join('\n');
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(text)
                    .then(() => showNotification('üìã S√©lection copi√©e dans le presse-papiers'))
                    .catch(() => showNotification('‚ö†Ô∏è Impossible de copier automatiquement', 'warning'));
            } else {
                showNotification('‚ö†Ô∏è Navigateur incompatible avec la copie automatique', 'warning');
            }
        }

        function closeClipboardPreview() {
            const modal = document.getElementById('clipboardPreviewModal');
            if (!modal) return;
            modal.classList.remove('show');
            clipboardActiveTab = null;
            clipboardDragPayload = [];
            clipboardSelectedCells.forEach(cell => cell.classList.remove('selected'));
            clipboardSelectedCells.clear();
        }

        function setupClipboardAutoPreview() {
            const selector = 'textarea[id^="clipboardInput-"]';
            const areas = document.querySelectorAll(selector);
            areas.forEach(area => {
                if (area.dataset.clipboardPreviewReady === 'true') return;
                area.dataset.clipboardPreviewReady = 'true';
                area.addEventListener('paste', (event) => {
                    const tabName = area.id.replace('clipboardInput-', '');
                    const triggerPreview = () => {
                        if ((area.value || '').trim()) {
                            openClipboardPreview(tabName);
                        }
                    };
                    if (event && event.clipboardData) {
                        requestAnimationFrame(triggerPreview);
                    } else {
                        setTimeout(triggerPreview, 0);
                    }
                });
            });
        }

        // üîß ACTIONS DE PR√âVISUALISATION
        function fixAllErrors() {
            try {
                if (!currentPreviewData) return;
                
                let fixed = 0;
                
                currentPreviewData.rows.forEach((row, rowIndex) => {
                    row.data.forEach((cellValue, colIndex) => {
                        const validation = row.validations[colIndex];
                        const columnName = currentPreviewData.headers[colIndex];
                        
                        if (validation.status === 'error' || validation.status === 'warning') {
                            let fixedValue = cellValue;
                            
                            if (columnName === 'GA' && cellValue.length !== 2) {
                                const derived = deriveInitialsFromName(cellValue);
                                if (derived) {
                                    fixedValue = derived;
                                } else if (cellValue.length > 2) {
                                    fixedValue = cellValue.substring(0, 2).toUpperCase();
                                } else if (cellValue.length === 1) {
                                    fixedValue = cellValue.toUpperCase() + 'X';
                                }
                            } else if (columnName.includes('RG') && !/^\d+$/.test(cellValue) && cellValue) {
                                fixedValue = cellValue.replace(/\D/g, '');
                            } else if (columnName.includes('Num√©ro') && columnName.includes('Bail')) {
                                fixedValue = cellValue.replace(/\D/g, '').padStart(6, '0').substring(0, 6);
                            } else if (columnName === '√âtat' || columnName === 'Etat') {
                                const upperValue = cellValue.toUpperCase();
                                if (upperValue.includes('OK') && !upperValue.includes('NOK')) {
                                    fixedValue = 'OK';
                                } else if (upperValue.includes('NOK')) {
                                    fixedValue = 'NOK';
                                } else if (upperValue.includes('COURS') || upperValue.includes('PROGRESS')) {
                                    fixedValue = 'EN COURS';
                                }
                            }
                            
                            if (fixedValue !== cellValue) {
                                currentPreviewData.rows[rowIndex].data[colIndex] = fixedValue;
                                const newValidation = validateCell(fixedValue, columnName, currentTabForPreview);
                                currentPreviewData.rows[rowIndex].validations[colIndex] = newValidation;
                                fixed++;
                            }
                        }
                    });
                });
                
                if (fixed > 0) {
                    showNotification(`üîß ${fixed} cellule(s) corrig√©e(s) automatiquement`);
                    showPreview(currentTabForPreview);
                } else {
                    showNotification('‚ÑπÔ∏è Aucune correction automatique possible', 'warning');
                }
                
            } catch (error) {
                console.error('Erreur correction automatique:', error);
                showNotification('‚ùå Erreur lors de la correction automatique', 'error');
            }
        }

        function removeErrorRows() {
            try {
                if (!currentPreviewData) return;
                
                const initialCount = currentPreviewData.rows.length;
                currentPreviewData.rows = currentPreviewData.rows.filter(row => !row.hasErrors);
                const finalCount = currentPreviewData.rows.length;
                const removed = initialCount - finalCount;
                
                if (removed > 0) {
                    showNotification(`üóëÔ∏è ${removed} ligne(s) en erreur supprim√©e(s)`);
                    updatePreviewStats();
                    showPreview(currentTabForPreview);
                } else {
                    showNotification('‚ÑπÔ∏è Aucune ligne en erreur √† supprimer', 'warning');
                }

            } catch (error) {
                console.error('Erreur suppression lignes erreur:', error);
                showNotification('‚ùå Erreur lors de la suppression', 'error');
            }
        }

        function getPreviewCodeInfo() {
            if (!currentPreviewData) return null;

            const headers = currentPreviewData.headers.map(h => (h || '').toString().toLowerCase());
            const normalizedHeaders = headers.map(h => h.replace(/[\s_\-]+/g, ''));

            const analyzeDataForCodes = () => {
                if (!currentPreviewData.rows || currentPreviewData.rows.length === 0) return null;

                const columnStats = {};
                currentPreviewData.rows.forEach(row => {
                    (row.data || []).forEach((cell, idx) => {
                        const raw = (cell || '').toString().trim();
                        if (!raw) return;

                        const normalized = raw.toUpperCase().replace(/[\s_\-]+/g, '');
                        if (!columnStats[idx]) {
                            columnStats[idx] = { filled: 0, uniques: new Set() };
                        }
                        columnStats[idx].filled++;
                        columnStats[idx].uniques.add(normalized);
                    });
                });

                let bestIndex = -1;
                let bestScore = 0;

                Object.entries(columnStats).forEach(([idx, info]) => {
                    const score = info.uniques.size;
                    if (score > bestScore) {
                        bestScore = score;
                        bestIndex = parseInt(idx, 10);
                    }
                });

                if (bestIndex === -1) return null;

                return { index: bestIndex, normalizer: normalizeUTValue, label: 'codes d√©tect√©s' };
            };

            const findUTIndex = () => {
                let idx = normalizedHeaders.findIndex(h => h.includes('codeut'));
                if (idx === -1) idx = normalizedHeaders.findIndex(h => h === 'utbat' || h === 'ut');
                if (idx === -1) idx = normalizedHeaders.findIndex(h => h.includes('ut'));
                return idx;
            };

            const findRGIndex = () => {
                let idx = normalizedHeaders.findIndex(h => h.includes('coderg'));
                if (idx === -1) idx = normalizedHeaders.findIndex(h => h === 'rg');
                if (idx === -1) idx = normalizedHeaders.findIndex(h => h.includes('rg'));
                return idx;
            };

            const utIndex = findUTIndex();
            const rgIndex = findRGIndex();

            let codeIndex = -1;
            let normalizer = (value) => (value || '').toString().trim();
            let label = 'entr√©es';

            const fallback = () => {
                const analyzed = analyzeDataForCodes();
                if (!analyzed) return null;
                return {
                    codeIndex: analyzed.index,
                    normalizer: analyzed.normalizer,
                    label: analyzed.label
                };
            };

            let detected = null;

            if (currentTabForPreview === 'baseut') {
                if (utIndex !== -1) {
                    detected = { codeIndex: utIndex, normalizer: normalizeUTValue, label: 'codes UT / UT-BAT' };
                } else {
                    detected = fallback();
                }
            }

            if (!detected && currentTabForPreview === 'baserg') {
                if (rgIndex !== -1) {
                    detected = { codeIndex: rgIndex, normalizer: normalizeRGValue, label: 'codes RG' };
                } else {
                    detected = fallback();
                }
            }

            if (!detected && utIndex !== -1 && currentTabForPreview !== 'baserg') {
                detected = { codeIndex: utIndex, normalizer: normalizeUTValue, label: 'codes UT / UT-BAT' };
            }

            if (!detected && rgIndex !== -1) {
                detected = { codeIndex: rgIndex, normalizer: normalizeRGValue, label: 'codes RG' };
            }

            if (!detected) {
                detected = fallback();
            }

            if (!detected || detected.codeIndex === -1) {
                showNotification('‚ùå Impossible d‚Äôidentifier la colonne code pour d√©tecter les doublons', 'error');
                return null;
            }

            ({ codeIndex, normalizer, label } = detected);

            if (codeIndex === -1) {
                showNotification('‚ùå Impossible d‚Äôidentifier la colonne code pour d√©tecter les doublons', 'error');
                return null;
            }

            return { codeIndex, normalizer, label };
        }

        function sortPreviewAndDeduplicate() {
            try {
                const codeInfo = getPreviewCodeInfo();
                if (!codeInfo) return;

                const { codeIndex, normalizer, label } = codeInfo;

                const sortableRows = currentPreviewData.rows.map((row, idx) => ({
                    row,
                    idx,
                    key: normalizer(row.data[codeIndex]),
                    raw: (row.data[codeIndex] || '').toString().trim()
                }));

                sortableRows.sort((a, b) => {
                    if (a.key && b.key) {
                        if (a.key === b.key) return a.idx - b.idx;
                        return a.key.localeCompare(b.key, 'fr', { sensitivity: 'base' });
                    }
                    if (a.key) return -1;
                    if (b.key) return 1;
                    return a.idx - b.idx;
                });

                const seen = new Set();
                const deduped = [];
                let removed = 0;

                sortableRows.forEach(item => {
                    if (!item.key) {
                        deduped.push(item);
                        return;
                    }

                    if (seen.has(item.key)) {
                        removed++;
                        return;
                    }

                    seen.add(item.key);
                    deduped.push(item);
                });

                currentPreviewData.rows = deduped.map(item => item.row);
                updatePreviewStats();
                showPreview(currentTabForPreview);

                const message = removed > 0
                    ? `‚ÜïÔ∏è Tableau tri√© et ${removed} doublon(s) ${label} supprim√©(s)`
                    : '‚ÜïÔ∏è Tableau tri√© (aucun doublon suppl√©mentaire trouv√©)';
                showNotification(message, removed > 0 ? 'success' : 'info');

            } catch (error) {
                console.error('Erreur tri/d√©doublonnage:', error);
                showNotification('‚ùå Erreur lors du tri ou du nettoyage des doublons', 'error');
            }
        }

        function applyPreviewSmartSuggestions() {
            try {
                if (!currentPreviewData) return;

                const headers = currentPreviewData.headers.map(h => (h || '').toString().toLowerCase());
                const rgIndex = headers.findIndex(h => h.includes('rg'));
                const rgNomIndex = headers.findIndex(h => h.includes('nom') && h.includes('rg'));
                const utIndex = headers.findIndex(h => h.includes('ut'));
                const utNomIndex = headers.findIndex(h => h.includes('nom') && h.includes('ut'));

                let applied = 0;

                currentPreviewData.rows.forEach(row => {
                    // Codes RG depuis les noms
                    if (rgIndex !== -1) {
                        const rawRG = row.data[rgIndex];
                        const rawNomRG = rgNomIndex !== -1 ? row.data[rgNomIndex] : '';
                        const normalizedRG = normalizeRGValue(rawRG);

                        if (!normalizedRG && rawNomRG) {
                            const match = findBestRGNameMatch(rawNomRG) || findBestRGMatch(rawNomRG);
                            if (match) {
                                const display = rgDatabase[match]?.codeAffiche || match;
                                row.data[rgIndex] = display;
                                row.validations[rgIndex] = validateCell(display, currentPreviewData.headers[rgIndex], currentTabForPreview);
                                applied++;
                            }
                        }

                        if (normalizedRG && rgNomIndex !== -1 && !rawNomRG) {
                            const nom = rgDatabase[normalizeRGValue(rawRG)]?.nom;
                            if (nom) {
                                row.data[rgNomIndex] = nom;
                                row.validations[rgNomIndex] = validateCell(nom, currentPreviewData.headers[rgNomIndex], currentTabForPreview);
                                applied++;
                            }
                        }
                    }

                    // Codes UT depuis les noms
                    if (utIndex !== -1) {
                        const rawUT = row.data[utIndex];
                        const rawNomUT = utNomIndex !== -1 ? row.data[utNomIndex] : '';
                        const normalizedUT = normalizeUTValue(rawUT);

                        if (!normalizedUT && rawNomUT) {
                            const match = findBestUTNameMatch(rawNomUT) || findBestUTMatch(rawNomUT);
                            if (match) {
                                const display = utDatabase[match]?.codeAffiche || match;
                                row.data[utIndex] = display;
                                row.validations[utIndex] = validateCell(display, currentPreviewData.headers[utIndex], currentTabForPreview);
                                applied++;
                            }
                        }

                        if (normalizedUT && utNomIndex !== -1 && !rawNomUT) {
                            const nom = utDatabase[normalizeUTValue(rawUT)]?.nom;
                            if (nom) {
                                row.data[utNomIndex] = nom;
                                row.validations[utNomIndex] = validateCell(nom, currentPreviewData.headers[utNomIndex], currentTabForPreview);
                                applied++;
                            }
                        }
                    }
                });

                if (applied > 0) {
                    updatePreviewStats();
                    showPreview(currentTabForPreview);
                    showNotification(`üí° ${applied} proposition(s) intelligente(s) appliqu√©e(s)`, 'success');
                } else {
                    showNotification('‚ÑπÔ∏è Aucune proposition trouv√©e pour UT/RG', 'warning');
                }

            } catch (error) {
                console.error('Erreur propositions intelligentes preview:', error);
                showNotification('‚ùå Erreur lors des propositions intelligentes', 'error');
            }
        }

        async function importPreviewedData() {
            try {
                if (!currentPreviewData || !currentTabForPreview) return;

                const errorCount = currentPreviewData.validationResults.errors;
                if (errorCount > 0) {
                    if (!confirm(`‚ö†Ô∏è Il y a encore ${errorCount} erreur(s). Voulez-vous vraiment importer ?`)) {
                        return;
                    }
                }
                
                await importDataToTable(currentPreviewData, currentTabForPreview);

            } catch (error) {
                console.error('Erreur import donn√©es pr√©visualis√©es:', error);
                showNotification('‚ùå Erreur lors de l\'import', 'error');
            }
        }

        async function importIgnoreErrors() {
            try {
                if (!currentPreviewData || !currentTabForPreview)
return;
                
                const errorCount = currentPreviewData.validationResults.errors;
                if (errorCount > 0) {
                    if (!confirm(`‚ö†Ô∏è ${errorCount} erreur(s) seront ignor√©es. Continuer ?`)) {
                        return;
                    }
                }
                
                await importDataToTable(currentPreviewData, currentTabForPreview);

            } catch (error) {
                console.error('Erreur import avec erreurs ignor√©es:', error);
                showNotification('‚ùå Erreur lors de l\'import', 'error');
            }
        }

        async function importDataToTable(previewData, tabName) {
            try {
                const tbody = document.getElementById(`${tabName}TableBody`);
                if (!tbody) {
                    showNotification('‚ùå Tableau cible non trouv√©', 'error');
                    return;
                }

                const validRows = previewData.rows.filter(row => row.data.some(cell => cell && cell.toString().trim()));
                const total = validRows.length;
                const chunkSize = 250;
                let imported = 0;

                showProcessingOverlay('Importation en cours...', `D√©but de l'import (${total} lignes)`);

                const schedule = window.requestIdleCallback
                    ? (cb) => requestIdleCallback(cb, { timeout: 60 })
                    : (cb) => setTimeout(cb, 0);

                while (imported < total) {
                    const fragment = document.createDocumentFragment();
                    const end = Math.min(imported + chunkSize, total);

                    for (let i = imported; i < end; i++) {
                        addRowWithData(tabName, validRows[i].data, {
                            fragment,
                            skipStats: true,
                            skipLog: true,
                            skipFocus: true,
                            skipValidation: true
                        });
                    }

                    tbody.appendChild(fragment);
                    imported = end;

                    const progress = total > 0 ? Math.round((imported / total) * 100) : 100;
                    updateProcessingProgress(`Importation des lignes ${Math.min(imported, total)}/${total}` , progress);

                    await new Promise(resolve => schedule(resolve));
                }

                updateStats(tabName);
                saveAllData();
                closePreview();
                hideProcessingOverlay();

                showNotification(`‚úÖ ${imported} ligne(s) import√©e(s) avec succ√®s`);
                logActivity(`Import de ${imported} lignes dans ${getTabDisplayName(tabName)}`, 'success');

            } catch (error) {
                console.error('Erreur import vers tableau:', error);
                showNotification('‚ùå Erreur lors de l\'import vers le tableau', 'error');
                hideProcessingOverlay();
            }
        }

        // üìä GESTION DES TABLEAUX
        function autoResizeField(field) {
            if (field.tagName === 'TEXTAREA') {
                field.style.height = 'auto';
                field.style.height = Math.max(field.scrollHeight, 38) + 'px';
            }
        }

        function expandAllTextFields() {
            try {
                const textAreas = Array.from(document.querySelectorAll('textarea.editable-textarea'));
                if (!textAreas.length) return;

                const total = textAreas.length;
                const showLoader = total > 80;
                let processed = 0;

                if (showLoader) {
                    showProcessingOverlay('Ajustement des champs texte...', 'Pr√©paration des champs...');
                }

                const processChunk = () => {
                    const start = performance.now();

                    while (processed < total && performance.now() - start < (showLoader ? 14 : 8)) {
                        autoResizeField(textAreas[processed]);
                        processed++;
                    }

                    if (showLoader) {
                        const percent = Math.round((processed / total) * 100);
                        updateProcessingProgress(`Ajustement des champs ${processed}/${total}`, percent);
                    }

                    if (processed < total) {
                        requestAnimationFrame(processChunk);
                    } else {
                        if (showLoader) {
                            hideProcessingOverlay();
                        }
                        showNotification(`ü™Ñ ${total} champ(s) texte ajust√©(s)`);
                    }
                };

                requestAnimationFrame(processChunk);
            } catch (error) {
                console.error('Erreur ajustement champs texte:', error);
            }
        }

        function createEditableField(column, tabName, value = '') {
            if (column === 'Trait√©') {
                const select = document.createElement('select');
                select.className = 'editable';

                ['','Oui','Non'].forEach(optionValue => {
                    const option = document.createElement('option');
                    option.value = optionValue;
                    option.textContent = optionValue;
                    select.appendChild(option);
                });

                const normalized = (value || '').toString().trim().toLowerCase();
                if (normalized === 'oui' || normalized === 'non') {
                    select.value = normalized.charAt(0).toUpperCase() + normalized.slice(1);
                }

                return select;
            }
            const inputType = getInputType(column);
            const field = inputType === 'text' ? document.createElement('textarea') : document.createElement('input');

            field.className = inputType === 'text' ? 'editable editable-textarea' : 'editable';
            field.placeholder = `Saisir ${column.toLowerCase()}...`;
            field.value = value;

            if (field.tagName === 'INPUT') {
                field.type = inputType;
            }

            if (field.tagName === 'TEXTAREA') {
                field.rows = 1;
                autoResizeField(field);
            }

            return field;
        }

        function buildRowElement(tabName, data = [], options = {}) {
            const { skipValidation = false } = options;
            const columns = tabConfigs[tabName]?.columns || [];
            const rowNum = ++rowCounters[tabName];

            const row = document.createElement('tr');

            const numberCell = document.createElement('td');
            numberCell.className = 'row-number';
            numberCell.textContent = rowNum;
            row.appendChild(numberCell);

            columns.forEach((column, index) => {
                const cell = document.createElement('td');
                const input = createEditableField(column, tabName, data[index] || '');

                if (tabName === 'modifsurface' && column === 'Diff√©rence') {
                    const surfaceAvant = parseFloat(data[columns.indexOf('-')] || 0);
                    const surfaceApres = parseFloat(data[columns.indexOf('+')] || 0);
                    input.value = (surfaceApres - surfaceAvant).toFixed(2);
                    input.readOnly = true;
                    input.style.backgroundColor = '#f8f9fa';
                }

                if (tabName === 'baserg' && column === 'Code RG') {
                    input.addEventListener('input', () => updateRGDatabase());
                } else if (tabName === 'baserg' && column === 'Nom de RG') {
                    input.addEventListener('input', () => updateRGDatabase());
                } else if (tabName === 'baseut' && column === 'Code UT') {
                    input.addEventListener('input', () => updateUTDatabase());
                } else if (tabName === 'baseut' && column === 'Nom UT') {
                    input.addEventListener('input', () => updateUTDatabase());
                } else if (tabName === 'baserg' && (column === 'Utilisations' || column === 'Derni√®re utilisation')) {
                    input.readOnly = true;
                    input.style.backgroundColor = '#f8f9fa';
                    if (column === 'Utilisations') {
                        input.value = data[index] || '0';
                    }
                } else if (tabName === 'baseut' && (column === 'Utilisations' || column === 'Derni√®re utilisation')) {
                    input.readOnly = true;
                    input.style.backgroundColor = '#f8f9fa';
                    if (column === 'Utilisations') {
                        input.value = data[index] || '0';
                    }
                }

                if (tabName === 'modifsurface' && (column === '-' || column === '+')) {
                    input.addEventListener('input', () => calculateSurfaceDifference(row));
                }

                if (column === 'RG' || column === 'Code RG') {
                    setupRGAutoCompletion(input, row, tabName);
                } else if (column === 'Nom de RG') {
                    setupNomRGAutoCompletion(input, row, tabName);
                } else if (column === 'UT-BAT') {
                    input.setAttribute('list', 'utDatalist');
                    input.addEventListener('blur', () => autoFillNomFromUT(input.value, input, { commit: true }));
                }

                attachColumnAutocomplete(input, column);

                input.addEventListener('input', () => {
                    autoResizeField(input);
                    applySmartSuggestion(input, column);
                    validateInputInRealTime(input, column, tabName);
                    saveAllData();
                    updateStats(tabName);
                });

                if (!skipValidation) {
                    validateInputInRealTime(input, column, tabName);
                }
                autoResizeField(input);

                cell.appendChild(input);
                row.appendChild(cell);
            });

            const actionCell = document.createElement('td');
            if (tabName === 'verifbaux') {
                const copyBtn = document.createElement('button');
                copyBtn.className = 'copy-btn';
                copyBtn.textContent = 'üìã PNI';
                copyBtn.title = 'Copier vers PNI';
                copyBtn.onclick = () => copyVerifRowToPNI(row);
                actionCell.appendChild(copyBtn);
            }
            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'delete-btn';
            deleteBtn.textContent = 'üóëÔ∏è';
            deleteBtn.onclick = () => deleteRow(row, tabName);
            actionCell.appendChild(deleteBtn);
            row.appendChild(actionCell);

            applyIntelligentRGFill(row, tabName);
            applyIntelligentUTFill(row, tabName);

            registerRowSelection(row, tabName);

            return row;
        }

        function ensureSelectionSet(tabName) {
            if (!selectedRowsByTab[tabName]) {
                selectedRowsByTab[tabName] = new Set();
            }
            return selectedRowsByTab[tabName];
        }

        function registerRowSelection(row, tabName) {
            if (!row) return;
            row.addEventListener('click', event => handleRowSelection(event, row, tabName));
        }

        function handleRowSelection(event, row, tabName) {
            if (!(event.ctrlKey || event.metaKey)) return;
            event.preventDefault();
            const selection = ensureSelectionSet(tabName);
            if (selection.has(row)) {
                selection.delete(row);
                row.classList.remove('row-selected');
            } else {
                selection.add(row);
                row.classList.add('row-selected');
            }
        }

        function deleteSelectedRows(tabName) {
            const selection = ensureSelectionSet(tabName);
            if (selection.size === 0) {
                showNotification('‚ÑπÔ∏è Aucune ligne s√©lectionn√©e', 'info');
                return;
            }
            if (!confirm(`Supprimer ${selection.size} ligne(s) s√©lectionn√©e(s) ?`)) {
                return;
            }
            const rowsToDelete = Array.from(selection);
            selection.clear();
            rowsToDelete.forEach(row => row.remove());
            updateStats(tabName);
            saveAllData();
            showNotification(`üóëÔ∏è ${rowsToDelete.length} ligne(s) supprim√©e(s)`);
            logActivity(`${rowsToDelete.length} lignes supprim√©es dans ${getTabDisplayName(tabName)}`, 'warning');
        }

        function clearRowSelection(tabName) {
            const selection = ensureSelectionSet(tabName);
            selection.forEach(row => row.classList.remove('row-selected'));
            selection.clear();
        }

        function removeRowFromSelection(row, tabName) {
            const selection = ensureSelectionSet(tabName);
            if (selection.has(row)) {
                selection.delete(row);
            }
        }

        function addRow(tabName) {
            try {
                const tbody = document.getElementById(`${tabName}TableBody`);
                if (!tbody) return;

                const row = buildRowElement(tabName);
                tbody.appendChild(row);

                const firstInput = row.querySelector('input');
                if (firstInput) {
                    firstInput.focus();
                }

                updateStats(tabName);
                if (tabName === 'baserg') {
                    updateRGDatabase();
                } else if (tabName === 'baseut') {
                    updateUTDatabase();
                }
                logActivity(`Nouvelle ligne ajout√©e dans ${getTabDisplayName(tabName)}`, 'info');

            } catch (error) {
                console.error('Erreur ajout ligne:', error);
                showNotification('‚ùå Erreur lors de l\'ajout de ligne', 'error');
            }
        }

        function addRowWithData(tabName, data, options = {}) {
            const { fragment = null, skipStats = false, skipLog = false, skipFocus = false, skipValidation = false } = options;
            try {
                const tbody = document.getElementById(`${tabName}TableBody`);
                if (!tbody) return;

                const row = buildRowElement(tabName, data, { skipValidation });

                if (fragment) {
                    fragment.appendChild(row);
                } else {
                    tbody.appendChild(row);
                }

                if (!skipFocus) {
                    const firstInput = row.querySelector('input');
                    if (firstInput) {
                        firstInput.focus();
                    }
                }

                if (!skipStats) {
                    updateStats(tabName);
                    if (tabName === 'baserg') {
                        updateRGDatabase();
                    } else if (tabName === 'baseut') {
                        updateUTDatabase();
                    }
                } else if (tabName === 'baserg' && !skipValidation) {
                    updateRGDatabase();
                } else if (tabName === 'baseut' && !skipValidation) {
                    updateUTDatabase();
                }

                if (!skipLog) {
                    logActivity(`Ligne import√©e dans ${getTabDisplayName(tabName)}`, 'info');
                }

            } catch (error) {
                console.error('Erreur ajout ligne avec donn√©es:', error);
                showNotification('‚ùå Erreur lors de l\'ajout de ligne', 'error');
            }
        }

        function validateInputInRealTime(input, columnName, tabName) {
            try {
                const value = input.value;
                const validation = validateCell(value, columnName, tabName);
                
                input.classList.remove('has-error', 'has-warning');
                
                if (validation.status === 'error') {
                    input.classList.add('has-error');
                    input.title = validation.message;
                } else if (validation.status === 'warning') {
                    input.classList.add('has-warning');
                    input.title = validation.message;
                } else {
                    input.title = '';
                }
                
            } catch (error) {
                console.error('Erreur validation temps r√©el:', error);
            }
        }

        function deleteRow(row, tabName) {
            try {
                if (confirm('√ätes-vous s√ªr de vouloir supprimer cette ligne ?')) {
                    row.remove();
                    removeRowFromSelection(row, tabName);
                    updateStats(tabName);
                    saveAllData();
                    showNotification('üóëÔ∏è Ligne supprim√©e');
                    logActivity(`Ligne supprim√©e dans ${getTabDisplayName(tabName)}`, 'warning');
                }
            } catch (error) {
                console.error('Erreur suppression ligne:', error);
                showNotification('‚ùå Erreur lors de la suppression', 'error');
            }
        }

        function getInputType(columnName) {
            const column = columnName.toLowerCase();
            if (column.includes('date')) return 'date';
            if (column.includes('surface') || column === '-' || column === '+') return 'number';
            return 'text';
        }

        function calculateSurfaceDifference(row) {
            try {
                const inputs = row.querySelectorAll('input, textarea, select');
                const columns = tabConfigs['modifsurface'].columns;
                
                const surfaceAvantIndex = columns.indexOf('-');
                const surfaceApresIndex = columns.indexOf('+');
                const differenceIndex = columns.indexOf('Diff√©rence');
                
                if (surfaceAvantIndex >= 0 && surfaceApresIndex >= 0 && differenceIndex >= 0) {
                    const surfaceAvantInput = inputs[surfaceAvantIndex];
                    const surfaceApresInput = inputs[surfaceApresIndex];
                    const differenceInput = inputs[differenceIndex];
                    
                    if (surfaceAvantInput && surfaceApresInput && differenceInput) {
                        const avant = parseFloat(surfaceAvantInput.value) || 0;
                        const apres = parseFloat(surfaceApresInput.value) || 0;
                        const difference = apres - avant;
                        differenceInput.value = difference.toFixed(2);
                        
                        // Colorer selon le signe
                        if (difference > 0) {
                            differenceInput.style.color = '#28a745';
                        } else if (difference < 0) {
                            differenceInput.style.color = '#dc3545';
                        } else {
                            differenceInput.style.color = '#666';
                        }
                    }
                }
            } catch (error) {
                console.error('Erreur calcul diff√©rence surface:', error);
            }
        }

        function recalculateAllSurfaces() {
            try {
                const tbody = document.getElementById('modifsurfaceTableBody');
                if (!tbody) return;
                
                const rows = tbody.querySelectorAll('tr');
                let recalculated = 0;
                
                rows.forEach(row => {
                    calculateSurfaceDifference(row);
                    recalculated++;
                });
                
                if (recalculated > 0) {
                    showNotification(`üîÑ ${recalculated} diff√©rence(s) de surface recalcul√©e(s)`);
                    updateStats('modifsurface');
                    saveAllData();
                }
                
            } catch (error) {
                console.error('Erreur recalcul surfaces:', error);
                showNotification('‚ùå Erreur lors du recalcul des surfaces', 'error');
            }
        }

        // üìä STATISTIQUES COMPL√àTES
        function updateStats(tabName) {
            try {
                if (tabName === 'baserg') { updateRGUsageStats(); return; }
                if (tabName === 'baseut') { updateUTUsageStats(); return; }
                const tbody = document.getElementById(`${tabName}TableBody`);
                if (!tbody) return;
                
                const rows = tbody.querySelectorAll('tr');
                const total = rows.length;
                let processed = 0;
                let pending = 0;
                
                if (['verifbaux', 'pni'].includes(tabName)) {
                    let ok = 0, nok = 0, enCours = 0;
                    let treated = 0;

                    rows.forEach(row => {
                        const inputs = row.querySelectorAll('input, textarea, select');
                        const etatIndex = tabConfigs[tabName].columns.indexOf('√âtat');
                        const traiteIndex = tabConfigs[tabName].columns.indexOf('Trait√©');
                        const etatInput = inputs[etatIndex];
                        const traiteInput = inputs[traiteIndex];
                        const etat = etatInput ? etatInput.value.toUpperCase() : '';
                        const traite = traiteInput ? traiteInput.value.toLowerCase() : '';

                        if (etat === 'OK') ok++;
                        else if (etat === 'NOK') nok++;
                        else if (etat === 'EN COURS') enCours++;

                        if (traite === 'oui') {
                            treated++;
                        }
                    });

                    const pendingRows = Math.max(total - treated, 0);

                    document.getElementById(`${tabName}TotalRows`).textContent = total;
                    document.getElementById(`${tabName}OKRows`).textContent = ok;
                    document.getElementById(`${tabName}NOKRows`).textContent = nok;
                    document.getElementById(`${tabName}EnCoursRows`).textContent = enCours;
                    const validationRate = total > 0 ? Math.round(((ok + nok) / total) * 100) : 0;
                    document.getElementById(`${tabName}ValidationRate`).textContent = validationRate + '%';
                    document.getElementById(`${tabName}ProcessedRows`).textContent = treated;
                    document.getElementById(`${tabName}PendingRows`).textContent = pendingRows;

                    const completionRate = total > 0 ? Math.round((treated / total) * 100) : 0;
                    document.getElementById(`${tabName}CompletionRate`).textContent = completionRate + '%';

                } else if (tabName === 'modifsurface') {
                    let totalDifference = 0;
                    
                    rows.forEach(row => {
                        const inputs = row.querySelectorAll('input, textarea, select');
                        const dateTraitementIndex = tabConfigs[tabName].columns.indexOf('Date Traitement');
                        const differenceIndex = tabConfigs[tabName].columns.indexOf('Diff√©rence');
                        
                        const dateTraitement = inputs[dateTraitementIndex] ? inputs[dateTraitementIndex].value : '';
                        const difference = inputs[differenceIndex] ? parseFloat(inputs[differenceIndex].value) || 0 : 0;
                        
                        if (dateTraitement) {
                            processed++;
                        } else {
                            pending++;
                        }
                        
                        totalDifference += difference;
                    });
                    
                    const completionRate = total > 0 ? Math.round((processed / total) * 100) : 0;
                    
                    document.getElementById(`${tabName}TotalRows`).textContent = total;
                    document.getElementById(`${tabName}ProcessedRows`).textContent = processed;
                    document.getElementById(`${tabName}PendingRows`).textContent = pending;
                    document.getElementById(`${tabName}TotalDifference`).textContent = totalDifference.toFixed(2) + ' m¬≤';
                    document.getElementById(`${tabName}CompletionRate`).textContent = completionRate + '%';
                    
                } else if (tabName === 'baserg') {
                    updateRGUsageStats();
                } else {
                    rows.forEach(row => {
                        const inputs = row.querySelectorAll('input, textarea, select');
                        const hasData = Array.from(inputs).some(input => input.value.trim() !== '');
                        
                        if (hasData) {
                            const dateTraitementIndex = tabConfigs[tabName].columns.indexOf('Date Traitement');
                            const dateTraitement = inputs[dateTraitementIndex] ? inputs[dateTraitementIndex].value : '';
                            
                            if (dateTraitement) {
                                processed++;
                            } else {
                                pending++;
                            }
                        }
                    });
                    
                    const completionRate = total > 0 ? Math.round((processed / total) * 100) : 0;
                    
                    const totalElement = document.getElementById(`${tabName}TotalRows`);
                    const processedElement = document.getElementById(`${tabName}ProcessedRows`);
                    const pendingElement = document.getElementById(`${tabName}PendingRows`);
                    const rateElement = document.getElementById(`${tabName}CompletionRate`);
                    
                    if (totalElement) totalElement.textContent = total;
                    if (processedElement) processedElement.textContent = processed;
                    if (pendingElement) pendingElement.textContent = pending;
                    if (rateElement) rateElement.textContent = completionRate + '%';
                }

                if (document.getElementById(`${tabName}PendingList`)) {
                    renderPendingList(tabName);
                }

            } catch (error) {
                console.error('Erreur mise √† jour statistiques:', error);
            }
        }

        function isRowPending(row, tabName) {
            const inputs = row.querySelectorAll('input, textarea, select');
            const hasData = Array.from(inputs).some(input => input.value.trim() !== '');
            if (!hasData) return false;

            if (['verifbaux', 'pni'].includes(tabName)) {
                const traiteIndex = tabConfigs[tabName].columns.indexOf('Trait√©');
                const traiteValue = inputs[traiteIndex] ? inputs[traiteIndex].value.toLowerCase() : '';
                return traiteValue !== 'oui';
            }

            const dateTraitementIndex = tabConfigs[tabName].columns.indexOf('Date Traitement');
            if (dateTraitementIndex >= 0) {
                const dateTraitement = inputs[dateTraitementIndex] ? inputs[dateTraitementIndex].value : '';
                return !dateTraitement;
            }

            return false;
        }

        function collectPendingRows(tabName) {
            const tbody = document.getElementById(`${tabName}TableBody`);
            if (!tbody) return [];

            const columns = tabConfigs[tabName]?.columns || [];
            const rows = Array.from(tbody.querySelectorAll('tr'));

            const bailIndexPrimary = columns.indexOf('Num√©ro de Bail');
            const bailIndexFallback = columns.indexOf('Num√©ro Bail');

            return rows
                .map((row, index) => {
                    if (!isRowPending(row, tabName)) return null;

                    const inputs = row.querySelectorAll('input, textarea, select');
                    const gaIndex = columns.indexOf('GA');
                    const bailIndex = bailIndexPrimary >= 0 ? bailIndexPrimary : bailIndexFallback;
                    const rgIndex = columns.indexOf('RG');

                    const ga = gaIndex >= 0 && inputs[gaIndex] ? inputs[gaIndex].value : '';
                    const bail = bailIndex >= 0 && inputs[bailIndex] ? inputs[bailIndex].value : '';
                    const rg = rgIndex >= 0 && inputs[rgIndex] ? inputs[rgIndex].value : '';

                    const titleParts = [`Ligne ${index + 1}`];
                    if (ga) titleParts.push(`GA ${ga}`);
                    if (bail) titleParts.push(`Bail ${bail}`);

                    return {
                        index,
                        title: titleParts.join(' ‚Ä¢ '),
                        subtitle: rg ? `RG ${rg}` : 'Cliquez pour ouvrir',
                        ga,
                        bail,
                        rg
                    };
                })
                .filter(Boolean);
        }

        function renderPendingList(tabName) {
            const container = document.getElementById(`${tabName}PendingList`);
            if (!container) return;

            const pendingRows = collectPendingRows(tabName);

            if (pendingRows.length === 0) {
                container.innerHTML = '<div class="pending-link"><span>Aucune ligne en attente</span><small>Tout est trait√©</small></div>';
                return;
            }

            container.innerHTML = pendingRows.map(item => `
                <div class="pending-link" onclick="event.stopPropagation(); focusPendingRow('${tabName}', ${item.index});">
                    <span>${item.title}</span>
                    <small>${item.subtitle}</small>
                </div>
            `).join('');
        }

        function focusPendingRow(tabName, rowIndex) {
            try {
                switchTab(tabName);

                requestAnimationFrame(() => {
                    const tbody = document.getElementById(`${tabName}TableBody`);
                    if (!tbody) return;

                    const rows = tbody.querySelectorAll('tr');
                    const target = rows[rowIndex];
                    if (!target) return;

                    target.classList.add('pending-highlight');
                    target.scrollIntoView({ behavior: 'smooth', block: 'center' });

                    const focusable = target.querySelector('input, textarea, select');
                    if (focusable) focusable.focus();

                    setTimeout(() => target.classList.remove('pending-highlight'), 2000);
                });

            } catch (error) {
                console.error('Erreur focus ligne en attente:', error);
            }
        }

        function goToNextPending(tabName) {
            try {
                switchTab(tabName);

                requestAnimationFrame(() => {
                    const tbody = document.getElementById(`${tabName}TableBody`);
                    if (!tbody) return;

                    const pendingRow = Array.from(tbody.querySelectorAll('tr')).find(row => isRowPending(row, tabName));

                    if (!pendingRow) {
                        showNotification(`‚ÑπÔ∏è Aucune ligne en attente dans ${getTabDisplayName(tabName)}`);
                        return;
                    }

                    pendingRow.classList.add('pending-highlight');
                    pendingRow.scrollIntoView({ behavior: 'smooth', block: 'center' });

                    const focusable = pendingRow.querySelector('input, textarea, select');
                    if (focusable) focusable.focus();

                    setTimeout(() => pendingRow.classList.remove('pending-highlight'), 2000);
                    showNotification(`üìç Prochaine ligne en attente affich√©e dans ${getTabDisplayName(tabName)}`);
                });
            } catch (error) {
                console.error('Erreur navigation vers ligne en attente:', error);
                showNotification('‚ùå Impossible de trouver une ligne en attente', 'error');
            }
        }

        function togglePendingStat(element, tabName) {
            try {
                const alreadyOpen = element.classList.contains('open');
                document.querySelectorAll('.stats-item.pending-expand.open').forEach(item => {
                    if (item !== element) item.classList.remove('open');
                });

                element.classList.toggle('open', !alreadyOpen);

                if (!alreadyOpen) {
                    renderPendingList(tabName);
                    const hint = element.querySelector('.stat-hint');
                    if (hint) {
                        hint.textContent = `Cliquer sur "Aller aux en attente" pour ouvrir ${getTabDisplayName(tabName)}`;
                    }
                }
            } catch (error) {
                console.error('Erreur lors de l\'ouverture des stats en attente:', error);
            }
        }

        document.addEventListener('click', (event) => {
            const target = event.target;
            const isStat = target.closest('.stats-item.pending-expand');
            if (!isStat) {
                document.querySelectorAll('.stats-item.pending-expand.open').forEach(item => item.classList.remove('open'));
            }
        });

        function updateRGUsageStats() {
            try {
                const tbody = document.getElementById('basergTableBody');
                if (!tbody) return;

                const rows = tbody.querySelectorAll('tr');
                const total = rows.length;
                let used = 0;

                // Compter les utilisations et dates d'utilisation
                const usageCounts = {};
                const tabUsageDates = {};

                ['creation', 'modification', 'verifbaux', 'pni'].forEach(tabName => {
                    const tabBody = document.getElementById(`${tabName}TableBody`);
                    if (!tabBody) return;

                    const tabRows = tabBody.querySelectorAll('tr');
                    tabRows.forEach(row => {
                        const inputs = row.querySelectorAll('input, textarea, select');
                        const rgIndex = tabConfigs[tabName].columns.indexOf('RG');
                        const dateIndex = tabConfigs[tabName].columns.indexOf('Date Traitement');

                        if (rgIndex >= 0 && inputs[rgIndex]) {
                            const rgValue = inputs[rgIndex].value.trim();
                            if (rgValue) {
                                usageCounts[rgValue] = (usageCounts[rgValue] || 0) + 1;

                                if (dateIndex >= 0 && inputs[dateIndex] && inputs[dateIndex].value) {
                                    const usageDate = reviveDate(inputs[dateIndex].value);
                                    if (usageDate && (!tabUsageDates[rgValue] || tabUsageDates[rgValue] < usageDate)) {
                                        tabUsageDates[rgValue] = usageDate;
                                    }
                                }
                            }
                        }
                    });
                });

                // Mettre √† jour l'affichage
                rows.forEach(row => {
                    const inputs = row.querySelectorAll('input, textarea, select');
                    const codeRG = inputs[0] ? inputs[0].value : '';
                    const usageCount = usageCounts[codeRG] || 0;

                    if (usageCount > 0) {
                        used++;
                    }

                    if (inputs[2]) {
                        inputs[2].value = usageCount;
                        inputs[2].readOnly = true;
                        inputs[2].style.backgroundColor = '#f8f9fa';
                    }

                    if (inputs[3]) {
                        const lastUse = tabUsageDates[codeRG];
                        inputs[3].value = lastUse ? lastUse.toISOString().split('T')[0] : '';
                        inputs[3].readOnly = true;
                        inputs[3].style.backgroundColor = '#f8f9fa';
                    }
                });

                const usageRate = total > 0 ? Math.round((used / total) * 100) : 0;

                document.getElementById('basergTotalRows').textContent = total;
                document.getElementById('basergUsedRows').textContent = used;
                document.getElementById('basergUnusedRows').textContent = total - used;
                document.getElementById('basergUsageRate').textContent = usageRate + '%';

            } catch (error) {
                console.error('Erreur stats usage RG:', error);
            }
        }

        function updateUTUsageStats() {
            try {
                const tbody = document.getElementById('baseutTableBody');
                if (!tbody) return;

                const rows = tbody.querySelectorAll('tr');
                const total = rows.length;
                let used = 0;

                const usageCounts = {};
                const usageDates = {};

                Object.keys(tabConfigs)
                    .filter(tab => tab !== 'baserg' && tab !== 'baseut')
                    .forEach(tabName => {
                        const tabBody = document.getElementById(`${tabName}TableBody`);
                        if (!tabBody) return;

                        const tabRows = tabBody.querySelectorAll('tr');
                        tabRows.forEach(row => {
                            const inputs = row.querySelectorAll('input, textarea, select');
                            const utIndex = tabConfigs[tabName].columns.indexOf('UT-BAT');
                            const dateIndex = tabConfigs[tabName].columns.indexOf('Date Traitement');

                            if (utIndex >= 0 && inputs[utIndex]) {
                                const utValue = normalizeUTValue(inputs[utIndex].value);
                                if (utValue) {
                                    usageCounts[utValue] = (usageCounts[utValue] || 0) + 1;

                                    if (dateIndex >= 0 && inputs[dateIndex] && inputs[dateIndex].value) {
                                        const usageDate = reviveDate(inputs[dateIndex].value);
                                        if (usageDate && (!usageDates[utValue] || usageDates[utValue] < usageDate)) {
                                            usageDates[utValue] = usageDate;
                                        }
                                    }
                                }
                            }
                        });
                    });

                rows.forEach(row => {
                    const inputs = row.querySelectorAll('input, textarea, select');
                    const codeIndex = 0;
                    const usageIndex = 2;
                    const dateIndex = 3;
                    const code = inputs[codeIndex] ? normalizeUTValue(inputs[codeIndex].value) : '';

                    if (code && usageCounts[code]) {
                        used++;
                        if (inputs[usageIndex]) inputs[usageIndex].value = usageCounts[code] || 0;
                        if (inputs[dateIndex] && usageDates[code]) inputs[dateIndex].value = new Date(usageDates[code]).toISOString().split('T')[0];
                        if (inputs[usageIndex]) inputs[usageIndex].readOnly = true;
                        if (inputs[usageIndex]) inputs[usageIndex].style.backgroundColor = '#f8f9fa';
                        if (inputs[dateIndex]) inputs[dateIndex].readOnly = true;
                        if (inputs[dateIndex]) inputs[dateIndex].style.backgroundColor = '#f8f9fa';
                    } else {
                        if (inputs[usageIndex]) inputs[usageIndex].value = inputs[usageIndex].value || '0';
                    }
                });

                const usageRate = total > 0 ? Math.round((used / total) * 100) : 0;

                document.getElementById('baseutTotalRows').textContent = total;
                document.getElementById('baseutUsedRows').textContent = used;
                document.getElementById('baseutUnusedRows').textContent = total - used;
                document.getElementById('baseutUsageRate').textContent = usageRate + '%';

            } catch (error) {
                console.error('Erreur stats usage UT:', error);
            }
        }

        function getTabStatistics() {
            const perTab = [];
            let totalGeneral = 0;
            let traitesGeneral = 0;
            let attenteGeneral = 0;

            Object.keys(tabConfigs).forEach(tabName => {
                if (tabName === 'baserg' || tabName === 'baseut') return;

                const tbody = document.getElementById(`${tabName}TableBody`);
                if (!tbody) return;

                const rows = tbody.querySelectorAll('tr');
                const total = rows.length;
                let processed = 0;

                rows.forEach(row => {
                    const inputs = row.querySelectorAll('input, textarea, select');
                    const traiteIndex = ['verifbaux', 'pni'].includes(tabName)
                        ? tabConfigs[tabName].columns.indexOf('Trait√©')
                        : tabConfigs[tabName].columns.indexOf('Date Traitement');

                    const traiteValue = inputs[traiteIndex] ? inputs[traiteIndex].value : '';
                    const isProcessed = ['verifbaux', 'pni'].includes(tabName)
                        ? traiteValue.trim().toLowerCase() === 'oui'
                        : !!traiteValue;

                    if (isProcessed) {
                        processed++;
                    }
                });

                const pending = total - processed;
                const rate = total > 0 ? Math.round((processed / total) * 100) : 0;

                totalGeneral += total;
                traitesGeneral += processed;
                attenteGeneral += pending;

                perTab.push({ tabName, total, processed, pending, rate });
            });

            const tauxGeneral = totalGeneral > 0 ? Math.round((traitesGeneral / totalGeneral) * 100) : 0;

            return {
                general: {
                    total: totalGeneral,
                    traites: traitesGeneral,
                    attente: attenteGeneral,
                    taux: tauxGeneral
                },
                perTab
            };
        }

        function getRGChangeInsights() {
            try {
                const tbody = document.getElementById('modificationTableBody');
                const defaultInsights = { totalEntries: 0, utbatCount: 0, multiCount: 0, topChanges: [], details: {} };

                if (!tbody) return defaultInsights;

                const utbatIndex = tabConfigs['modification'].columns.indexOf('UT-BAT');
                const rgIndex = tabConfigs['modification'].columns.indexOf('RG');
                const bailIndex = tabConfigs['modification'].columns.indexOf('Num√©ro de Bail');
                const gaIndex = tabConfigs['modification'].columns.indexOf('GA');
                const rows = tbody.querySelectorAll('tr');
                const utbatMap = {};
                const linesByUtbat = {};

                rows.forEach((row, rowIndex) => {
                    const inputs = row.querySelectorAll('input, textarea, select');
                    const utbatRaw = inputs[utbatIndex] ? inputs[utbatIndex].value.trim() : '';
                    const utbat = utbatRaw.toUpperCase();
                    const rgValue = inputs[rgIndex] ? inputs[rgIndex].value.trim() : '';
                    const bailValue = bailIndex >= 0 && inputs[bailIndex] ? inputs[bailIndex].value.trim() : '';
                    const bailKey = bailValue.trim().toUpperCase();
                    const gaValue = gaIndex >= 0 && inputs[gaIndex] ? inputs[gaIndex].value.trim() : '';

                    if (!utbat || dismissedRGChanges.has(utbat)) return;

                    if (!utbatMap[utbat]) {
                        utbatMap[utbat] = { bails: {} };
                    }

                    const bailGroup = bailKey || '__NO_BAIL__';
                    if (!utbatMap[utbat].bails[bailGroup]) {
                        utbatMap[utbat].bails[bailGroup] = { count: 0, rgs: new Set(), displayBail: bailValue };
                    }

                    utbatMap[utbat].bails[bailGroup].count++;
                    if (rgValue) {
                        utbatMap[utbat].bails[bailGroup].rgs.add(rgValue);
                    }

                    if (!linesByUtbat[utbat]) {
                        linesByUtbat[utbat] = [];
                    }

                    linesByUtbat[utbat].push({
                        tabName: 'modification',
                        rowIndex,
                        utbat,
                        utbatDisplay: utbatRaw || utbat,
                        rg: rgValue,
                        bail: bailValue,
                        bailKey: bailGroup,
                        ga: gaValue
                    });
                });

                const detailMap = {};
                const multiChanges = [];

                Object.entries(utbatMap).forEach(([utbat, meta]) => {
                    const bailEntries = Object.entries(meta.bails).filter(([bailKey, stats]) =>
                        bailKey !== '__NO_BAIL__' && (stats.count > 1 || stats.rgs.size > 1)
                    );

                    if (bailEntries.length === 0) return;

                    const allowedBails = new Set(bailEntries.map(([bailKey]) => bailKey));
                    detailMap[utbat] = (linesByUtbat[utbat] || []).filter(line => allowedBails.has(line.bailKey));

                    bailEntries.forEach(([bailKey, stats]) => {
                        multiChanges.push({
                            utbat,
                            bail: stats.displayBail || (bailKey === '__NO_BAIL__' ? 'Bail manquant' : bailKey),
                            occurrences: stats.count,
                            variations: stats.rgs.size
                        });
                    });
                });

                const topChanges = multiChanges
                    .sort((a, b) => (b.occurrences - a.occurrences) || (b.variations - a.variations));

                rgChangeRegistry = detailMap;

                return {
                    totalEntries: rows.length,
                    utbatCount: Object.keys(detailMap).length,
                    multiCount: multiChanges.length,
                    topChanges,
                    details: detailMap
                };
            } catch (error) {
                console.error('Erreur calcul insights RG:', error);
                return { totalEntries: 0, utbatCount: 0, multiCount: 0, topChanges: [], details: {} };
            }
        }

        function updateRGChangeWidget(insights) {
            try {
                const data = insights || getRGChangeInsights();
                const utbatElement = document.getElementById('rgChangeUTBATCount');
                const multiElement = document.getElementById('rgChangeMultiCount');
                const moodElement = document.getElementById('rgChangeMood');
                const listContainer = document.getElementById('rgChangeDetails');
                const panel = document.getElementById('rgChangePanel');
                const toggle = document.getElementById('rgChangeToggleBtn');

                if (utbatElement) utbatElement.textContent = data.utbatCount;
                if (multiElement) multiElement.textContent = data.multiCount;

                if (panel) {
                    panel.style.display = rgChangePanelExpanded ? 'block' : 'none';
                }

                if (toggle) {
                    toggle.textContent = `${rgChangePanelExpanded ? '‚ñæ' : '‚ñ∏'} D√©tails`;
                }

                if (moodElement) {
                    if (data.multiCount === 0) {
                        moodElement.textContent = 'Tout est stable, aucun doublon d√©tect√© üéØ';
                    } else if (data.multiCount < 3) {
                        moodElement.textContent = 'Quelques UT-BAT n√©cessitent une double v√©rification üëÄ';
                    } else {
                        moodElement.textContent = 'Beaucoup de rotations RG sur les m√™mes UT-BAT ‚ö†Ô∏è';
                    }
                }

                if (!listContainer) return;

                listContainer.innerHTML = '';

                if (data.topChanges.length === 0) {
                    listContainer.innerHTML = '<div style="color: #666;">Aucun UT-BAT avec modifications r√©p√©t√©es pour le moment.</div>';
                    return;
                }

                const exportAllBtn = document.createElement('button');
                exportAllBtn.className = 'btn btn-excel btn-compact';
                exportAllBtn.style.marginBottom = '8px';
                exportAllBtn.textContent = 'üì§ Exporter ces changements';
                exportAllBtn.onclick = () => exportRGChanges();
                listContainer.appendChild(exportAllBtn);


                data.topChanges.forEach(change => {
                    const item = document.createElement('div');
                    item.className = 'rg-change-item';
                    const details = rgChangeRegistry[change.utbat] || [];

                    const previewLines = details.slice(0, 2).map(line => {
                        const parts = [`L${line.rowIndex + 1}`];
                        if (line.ga) parts.push(`GA ${line.ga}`);
                        parts.push(line.bail ? `Bail ${line.bail}` : 'Bail manquant');
                        return `${parts.join(' ‚Ä¢ ')}${line.rg ? ` ‚Ä¢ RG ${line.rg}` : ''}`;
                    }).join(' | ');

                    const header = document.createElement('div');
                    header.className = 'rg-change-header';

                    const toggleBtn = document.createElement('button');
                    toggleBtn.className = 'rg-change-toggle';
                    toggleBtn.textContent = '‚ñ∏';

                    const title = document.createElement('div');
                    title.className = 'rg-change-title';
                    title.innerHTML = `
                        <strong>UT-BAT ${change.utbat}</strong>
                        <div class="rg-change-meta">
                            <span>üîÅ ${change.occurrences} passages</span>
                            <span>üé≠ ${change.variations} RG distincts</span>
                            <span>üè∑Ô∏è Bail ${change.bail || 'non renseign√©'}</span>
                        </div>
                    `;

                    const actions = document.createElement('div');
                    actions.className = 'rg-change-actions';

                    const btnVoir = document.createElement('button');
                    btnVoir.className = 'btn btn-secondary btn-compact';
                    btnVoir.textContent = 'üîé Voir les lignes';
                    btnVoir.onclick = () => focusRGChange(change.utbat);

                    const btnDismiss = document.createElement('button');
                    btnDismiss.className = 'btn btn-warning btn-compact';
                    btnDismiss.textContent = 'üóÇÔ∏è Retirer le doublon';
                    btnDismiss.onclick = () => dismissRGChange(change.utbat);

                    const btnExport = document.createElement('button');
                    btnExport.className = 'btn btn-excel btn-compact';
                    btnExport.textContent = 'üìë Export';
                    btnExport.onclick = () => exportRGChange(change.utbat);

                    actions.append(btnVoir, btnDismiss, btnExport);

                    header.append(toggleBtn, title, actions);

                    const preview = document.createElement('div');
                    preview.className = 'rg-change-preview';
                    preview.innerHTML = `<strong>${details.length}</strong> ligne(s) concern√©es${previewLines ? ` ‚Ä¢ ${previewLines}` : ''}`;

                    const fullDetails = document.createElement('div');
                    fullDetails.className = 'rg-change-body';
                    fullDetails.innerHTML = details.length === 0
                        ? '<div style="color:#666;">Aucun d√©tail disponible</div>'
                        : `<div class="rg-line-list">${details.map(line => {
                            const parts = [`<strong>L${line.rowIndex + 1}</strong>`];
                            if (line.ga) parts.push(`<span>GA ${line.ga}</span>`);
                            parts.push(`<span>${line.bail ? `Bail ${line.bail}` : 'Bail manquant'}</span>`);
                            if (line.rg) parts.push(`<span>RG ${line.rg}</span>`);
                            return `<div class=\"rg-line-row\">${parts.join(' ‚Ä¢ ')}<\/div>`;
                        }).join('')}</div>`;

                    const toggleDetails = () => {
                        const expanded = fullDetails.style.display === 'block';
                        fullDetails.style.display = expanded ? 'none' : 'block';
                        toggleBtn.textContent = expanded ? '‚ñ∏' : '‚ñæ';
                    };

                    toggleBtn.onclick = toggleDetails;
                    preview.onclick = toggleDetails;

                    item.append(header, preview, fullDetails);
                    listContainer.appendChild(item);
                });

            } catch (error) {
                console.error('Erreur mise √† jour suivi changements RG:', error);
            }
        }

        function focusRGChange(utbat) {
            try {
                const normalized = (utbat || '').trim().toUpperCase();
                const lines = (rgChangeRegistry[normalized] || []).slice();
                if (lines.length === 0) {
                    showNotification('‚ÑπÔ∏è Aucune ligne rep√©r√©e pour cet UT-BAT');
                    return;
                }

                // Bascule directement sur l'onglet Recherche pour afficher la liste compl√®te
                switchTab('recherche');

                const sortedLines = lines.sort((a, b) => a.rowIndex - b.rowIndex);
                const preparedResults = [];
                const startTime = performance.now();

                sortedLines.forEach(line => {
                    const tbody = document.getElementById(`${line.tabName}TableBody`);
                    if (!tbody) return;

                    const rows = tbody.querySelectorAll('tr');
                    const row = rows[line.rowIndex];
                    if (!row) return;

                    const inputs = row.querySelectorAll('input, textarea, select');
                    const rowData = Array.from(inputs).map(input => input.value);

                    preparedResults.push({
                        tabName: line.tabName,
                        tabDisplayName: getTabDisplayName(line.tabName),
                        rowIndex: line.rowIndex,
                        data: rowData,
                        columns: tabConfigs[line.tabName]?.columns || []
                    });
                });

                if (preparedResults.length === 0) {
                    showNotification('‚ÑπÔ∏è Impossible de charger les lignes concern√©es');
                    return;
                }

                const searchParams = {
                    ga: '',
                    rg: '',
                    utbat: normalized.toLowerCase(),
                    bail: '',
                    advancedBail: '',
                    dateFrom: '',
                    dateTo: '',
                    tab: sortedLines[0].tabName || 'modification',
                    keyword: 'changement rg surveill√©'
                };

                searchResults = preparedResults;
                const searchTime = Math.round(performance.now() - startTime);
                displaySearchResults(searchTime, searchParams);

                const resultsContainer = document.getElementById('searchResults');
                if (resultsContainer) {
                    resultsContainer.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }

                showNotification(`üîé ${preparedResults.length} ligne(s) pour UT-BAT ${normalized}`);
            } catch (error) {
                console.error('Erreur navigation changement RG:', error);
                showNotification('‚ùå Erreur lors de la navigation', 'error');
            }
        }

        function dismissRGChange(utbat) {
            try {
                const normalized = (utbat || '').trim().toUpperCase();
                if (!normalized) return;

                dismissedRGChanges.add(normalized);

                if (rgChangeRegistry[normalized]) {
                    delete rgChangeRegistry[normalized];
                }

                const refreshedInsights = getRGChangeInsights();
                updateRGChangeWidget(refreshedInsights);
                updateStatChips(getTabStatistics().general, refreshedInsights, getQualityCounts());
                saveAllData();

                showNotification(`‚úÖ UT-BAT ${normalized} retir√© des doublons apr√®s v√©rification`);
            } catch (error) {
                console.error('Erreur suppression doublon RG:', error);
                showNotification('‚ùå Impossible de retirer ce doublon', 'error');
            }
        }

        function getCompleteRGChangeDetails() {
            const latestDetails = getRGChangeInsights().details || {};
            const merged = {};

            const mergeSource = (source) => {
                Object.entries(source || {}).forEach(([utbat, lines]) => {
                    const key = (utbat || '').trim().toUpperCase();
                    if (!key) return;
                    if (!merged[key]) merged[key] = [];
                    merged[key].push(...(lines || []));
                });
            };

            mergeSource(rgChangeRegistry);
            mergeSource(latestDetails);

            Object.entries(merged).forEach(([utbat, lines]) => {
                const seen = new Set();
                merged[utbat] = (lines || [])
                    .filter(line => line && typeof line.rowIndex === 'number')
                    .sort((a, b) => a.rowIndex - b.rowIndex)
                    .filter(line => {
                        const key = `${line.tabName || 'modification'}-${line.rowIndex}`;
                        if (seen.has(key)) return false;
                        seen.add(key);
                        return true;
                    });
            });

            return merged;
        }

        function exportRGChange(utbat) {
            try {
                if (!window.XLSX) {
                    showNotification('‚ùå Biblioth√®que Excel non disponible', 'error');
                    return;
                }

                const normalized = (utbat || '').trim().toUpperCase();
                const detailMap = getCompleteRGChangeDetails();
                const lines = (detailMap[normalized] || []).slice();

                if (lines.length === 0) {
                    showNotification('‚ÑπÔ∏è Aucun d√©tail √† exporter pour cet UT-BAT');
                    return;
                }

                const rows = lines.map(line => ({
                    "UT-BAT": line.utbat,
                    "Ligne": line.rowIndex + 1,
                    "GA": line.ga || '',
                    "Num√©ro de Bail": line.bail || '',
                    "RG": line.rg || ''
                }));

                const wb = XLSX.utils.book_new();
                const ws = XLSX.utils.json_to_sheet(rows);
                XLSX.utils.book_append_sheet(wb, ws, `UTBAT_${normalized}`.substring(0, 31));
                const fileName = `Changements_RG_${normalized}_${new Date().toISOString().split('T')[0]}.xlsx`;
                XLSX.writeFile(wb, fileName);
                showNotification(`üì§ Export des changements RG pour ${normalized} (${rows.length} ligne(s))`);
            } catch (error) {
                console.error('Erreur export changement RG:', error);
                showNotification('‚ùå Erreur export changement RG', 'error');
            }
        }

        function exportRGChanges() {
            try {
                if (!window.XLSX) {
                    showNotification('‚ùå Biblioth√®que Excel non disponible', 'error');
                    return;
                }

                const detailMap = getCompleteRGChangeDetails();
                const entries = Object.entries(detailMap).filter(([, lines]) => (lines || []).length > 0);
                if (entries.length === 0) {
                    showNotification('‚ÑπÔ∏è Aucun changement RG surveill√© √† exporter');
                    return;
                }

                const wb = XLSX.utils.book_new();
                const globalRows = [];

                entries.forEach(([utbat, lines]) => {
                    const ordered = (lines || []).slice().sort((a, b) => a.rowIndex - b.rowIndex);
                    const rows = ordered.map(line => ({
                        "UT-BAT": line.utbat,
                        "Ligne": line.rowIndex + 1,
                        "GA": line.ga || '',
                        "Num√©ro de Bail": line.bail || '',
                        "RG": line.rg || ''
                    }));

                    globalRows.push(...rows);

                    const ws = XLSX.utils.json_to_sheet(rows);
                    XLSX.utils.book_append_sheet(wb, ws, `UTBAT_${utbat}`.substring(0, 31));
                });

                const orderedGlobalRows = globalRows.slice().sort((a, b) => {
                    return (a["UT-BAT"] || '').localeCompare(b["UT-BAT"] || '')
                        || (a["Num√©ro de Bail"] || '').localeCompare(b["Num√©ro de Bail"] || '')
                        || ((a["Ligne"] || 0) - (b["Ligne"] || 0));
                });

                const summarySheet = XLSX.utils.json_to_sheet(orderedGlobalRows);
                XLSX.utils.book_append_sheet(wb, summarySheet, 'Doublons');

                const fileName = `Changements_RG_surveilles_${new Date().toISOString().split('T')[0]}.xlsx`;
                XLSX.writeFile(wb, fileName);
                showNotification(`üìä Export des changements RG surveill√©s g√©n√©r√© (${entries.length} UT-BAT, ${globalRows.length} ligne(s))`);
            } catch (error) {
                console.error('Erreur export global changements RG:', error);
                showNotification('‚ùå Erreur export global RG', 'error');
            }
        }

        function updateStatChips(generalStats, rgInsights, qualityCounts) {
            try {
                const overallRateElement = document.getElementById('chipOverallRate');
                const overallSummaryElement = document.getElementById('chipOverallSummary');
                const rgMultiElement = document.getElementById('chipRgMultiCount');
                const rgDetailsElement = document.getElementById('chipRgDetails');
                const qualityAlertsElement = document.getElementById('chipQualityAlerts');
                const qualitySummaryElement = document.getElementById('chipQualitySummary');

                const rate = generalStats?.taux ?? 0;
                const total = generalStats?.total ?? 0;

                if (overallRateElement) {
                    overallRateElement.textContent = `${rate}%`;
                }

                if (overallSummaryElement) {
                    overallSummaryElement.textContent = total > 0
                        ? `${generalStats.traites} trait√©s sur ${total} entr√©es`
                        : 'Aucune donn√©e pour le moment';
                }

                if (rgMultiElement) {
                    rgMultiElement.textContent = rgInsights?.multiCount ?? 0;
                }

                if (rgDetailsElement) {
                    const utbatInfo = rgInsights?.utbatCount || 0;
                    const detailTop = rgInsights?.topChanges?.[0];
                    rgDetailsElement.textContent = rgInsights && rgInsights.multiCount > 0
                        ? `${detailTop?.utbat || 'UT-BAT'} surveill√© (${utbatInfo} UT-BAT touch√©s)`
                        : 'Aucun doublon d√©tect√©';
                }

                if (qualityAlertsElement) {
                    const alerts = (qualityCounts?.errors || 0) + (qualityCounts?.warnings || 0);
                    qualityAlertsElement.textContent = alerts;
                }

                if (qualitySummaryElement) {
                    if (!qualityCounts) {
                        qualitySummaryElement.textContent = 'Pas d\'alerte √† signaler';
                    } else {
                        const { errors = 0, warnings = 0 } = qualityCounts;
                        if (errors === 0 && warnings === 0) {
                            qualitySummaryElement.textContent = 'Pas d\'alerte √† signaler';
                        } else {
                            qualitySummaryElement.textContent = `${errors} erreur(s) / ${warnings} avertissement(s)`;
                        }
                    }
                }
            } catch (error) {
                console.error('Erreur mise √† jour des pastilles ludiques:', error);
            }
        }

        function normalizeRGValue(value) {
            if (value === null || value === undefined) return '';
            const cleaned = value
                .toString()
                .trim()
                .toUpperCase()
                .replace(/[\s_\-]+/g, '');

            return cleaned.replace(/^0+(?=[A-Z0-9])/, '');
        }

        function normalizeUTValue(value) {
            if (value === null || value === undefined) return '';
            return value
                .toString()
                .trim()
                .toUpperCase()
                .replace(/[\s_\-]+/g, '');
        }

        function updateRGDatabase() {
            try {
                const tbody = document.getElementById('basergTableBody');
                if (!tbody) return;

                rgDatabase = {};
                const rows = tbody.querySelectorAll('tr');

                rows.forEach(row => {
                    const inputs = row.querySelectorAll('input, textarea, select');
                    const codeRG = inputs[0] ? inputs[0].value.trim() : '';
                    const normalizedCode = normalizeRGValue(codeRG);
                    const nomRG = inputs[1] ? inputs[1].value.trim() : '';

                    if (normalizedCode) {
                        rgDatabase[normalizedCode] = {
                            codeAffiche: codeRG || normalizedCode,
                            nom: nomRG,
                            utilisations: 0,
                            derniereUtilisation: null
                        };
                    }
                });

                updateRGUsageStats();
                refreshRGSuggestions();
                applyIntelligentRGFillAll();

            } catch (error) {
                console.error('Erreur mise √† jour base RG:', error);
            }
        }

        function updateUTDatabase() {
            try {
                const tbody = document.getElementById('baseutTableBody');
                if (!tbody) return;

                utDatabase = {};
                const rows = tbody.querySelectorAll('tr');

                rows.forEach(row => {
                    const inputs = row.querySelectorAll('input, textarea, select');
                    const codeUT = inputs[0] ? inputs[0].value.trim() : '';
                    const normalizedCode = normalizeUTValue(codeUT);
                    const nomUT = inputs[1] ? inputs[1].value.trim() : '';

                    if (normalizedCode) {
                        utDatabase[normalizedCode] = {
                            codeAffiche: codeUT || normalizedCode,
                            nom: nomUT,
                            utilisations: 0,
                            derniereUtilisation: null
                        };
                    }
                });

                updateUTUsageStats();
                refreshUTSuggestions();
                applyIntelligentUTFillAll();

            } catch (error) {
                console.error('Erreur mise √† jour base UT:', error);
            }
        }

        function ensureRGSuggestionLists() {
            let codeList = document.getElementById('rgDatalist');
            if (!codeList) {
                codeList = document.createElement('datalist');
                codeList.id = 'rgDatalist';
                document.body.appendChild(codeList);
            }

            let nameList = document.getElementById('rgNomDatalist');
            if (!nameList) {
                nameList = document.createElement('datalist');
                nameList.id = 'rgNomDatalist';
                document.body.appendChild(nameList);
            }
        }

        function ensureUTSuggestionLists() {
            let codeList = document.getElementById('utDatalist');
            if (!codeList) {
                codeList = document.createElement('datalist');
                codeList.id = 'utDatalist';
                document.body.appendChild(codeList);
            }

            let nameList = document.getElementById('utNomDatalist');
            if (!nameList) {
                nameList = document.createElement('datalist');
                nameList.id = 'utNomDatalist';
                document.body.appendChild(nameList);
            }
        }

        function refreshRGSuggestions() {
            ensureRGSuggestionLists();

            const codeList = document.getElementById('rgDatalist');
            const nameList = document.getElementById('rgNomDatalist');

            codeList.innerHTML = '';
            nameList.innerHTML = '';

            Object.entries(rgDatabase).forEach(([code, data]) => {
                const option = document.createElement('option');
                option.value = data.codeAffiche || code;
                option.label = data.nom || '';
                codeList.appendChild(option);

                if (data.nom) {
                    const nameOption = document.createElement('option');
                    nameOption.value = data.nom;
                    nameOption.label = code;
                    nameList.appendChild(nameOption);
                }
            });
        }

        function refreshUTSuggestions() {
            ensureUTSuggestionLists();

            const codeList = document.getElementById('utDatalist');
            const nameList = document.getElementById('utNomDatalist');

            codeList.innerHTML = '';
            nameList.innerHTML = '';

            Object.entries(utDatabase).forEach(([code, data]) => {
                const option = document.createElement('option');
                option.value = data.codeAffiche || code;
                option.label = data.nom || '';
                codeList.appendChild(option);

                if (data.nom) {
                    const nameOption = document.createElement('option');
                    nameOption.value = data.nom;
                    nameOption.label = code;
                    nameList.appendChild(nameOption);
                }
            });
        }

        function findBestRGMatch(value) {
            const normalized = normalizeRGValue(value || '');
            if (!normalized) return null;
            if (rgDatabase[normalized]) return normalized;

            const displayMatch = Object.entries(rgDatabase).find(([, data]) => normalizeRGValue(data.codeAffiche) === normalized);
            if (displayMatch) return displayMatch[0];

            const startsWithMatch = Object.keys(rgDatabase)
                .find(code => normalizeRGValue(code).startsWith(normalized) || normalized.startsWith(normalizeRGValue(code)));
            if (startsWithMatch) return startsWithMatch;

            const partialMatch = Object.entries(rgDatabase)
                .find(([code, data]) => normalizeRGValue(code).includes(normalized) || normalizeRGValue(data.codeAffiche || '').includes(normalized));
            if (partialMatch) return partialMatch[0];

            return Object.keys(rgDatabase).find(code => normalizeRGValue(code) === normalized) || null;
        }

        function findBestUTMatch(value) {
            const normalized = normalizeUTValue(value || '');
            if (!normalized) return null;
            if (utDatabase[normalized]) return normalized;

            const displayMatch = Object.entries(utDatabase).find(([, data]) => normalizeUTValue(data.codeAffiche) === normalized);
            if (displayMatch) return displayMatch[0];

            const startsWithMatch = Object.keys(utDatabase)
                .find(code => normalizeUTValue(code).startsWith(normalized) || normalized.startsWith(normalizeUTValue(code)));
            if (startsWithMatch) return startsWithMatch;

            const partialMatch = Object.entries(utDatabase)
                .find(([code, data]) => normalizeUTValue(code).includes(normalized) || normalizeUTValue(data.codeAffiche || '').includes(normalized));
            if (partialMatch) return partialMatch[0];

            return Object.keys(utDatabase).find(code => normalizeUTValue(code) === normalized) || null;
        }

        function findBestRGNameMatch(value) {
            const normalized = (value || '').trim().toLowerCase();
            if (!normalized) return null;

            let match = Object.entries(rgDatabase).find(([, data]) => (data.nom || '').toLowerCase() === normalized);
            if (match) return match[0];

            match = Object.entries(rgDatabase).find(([, data]) => (data.nom || '').toLowerCase().startsWith(normalized));
            return match ? match[0] : null;
        }

        function findBestUTNameMatch(value) {
            const normalized = (value || '').trim().toLowerCase();
            if (!normalized) return null;

            let match = Object.entries(utDatabase).find(([, data]) => (data.nom || '').toLowerCase() === normalized);
            if (match) return match[0];

            match = Object.entries(utDatabase).find(([, data]) => (data.nom || '').toLowerCase().startsWith(normalized));
            return match ? match[0] : null;
        }

        function getNomRGInput(row, tabName) {
            const columns = tabConfigs[tabName]?.columns || [];
            const nomIndex = columns.indexOf('Nom de RG');
            if (nomIndex < 0) return null;

            const inputs = row.querySelectorAll('input, textarea, select');
            return inputs[nomIndex] || null;
        }

        function getRGInput(row, tabName) {
            const columns = tabConfigs[tabName]?.columns || [];
            const rgIndex = columns.indexOf('RG');
            if (rgIndex < 0) return null;

            const inputs = row.querySelectorAll('input, textarea, select');
            return inputs[rgIndex] || null;
        }

        function getUTInput(row, tabName) {
            const columns = tabConfigs[tabName]?.columns || [];
            const utIndex = columns.indexOf('UT-BAT');
            if (utIndex < 0) return null;

            const inputs = row.querySelectorAll('input, textarea, select');
            return inputs[utIndex] || null;
        }

        let currentRGSuggestionPanel = null;

        function commitRGSelection(match, row, tabName) {
            const rgInput = getRGInput(row, tabName);
            const nomInput = getNomRGInput(row, tabName);
            const data = rgDatabase[match] || {};

            if (rgInput) {
                rgInput.value = data.codeAffiche || match;
                addColumnSuggestion(tabName === 'baserg' ? 'Code RG' : 'RG', rgInput.value);
            }

            if (nomInput) {
                nomInput.value = data.nom || '';
                nomInput.dataset.autoFilled = 'true';
                addColumnSuggestion('Nom de RG', nomInput.value);
            }

            saveAllData();
            updateStats(tabName);
            hideRGSuggestionPanel();

            return match;
        }

        function autoFillNomFromRG(rgValue, row, tabName, options = {}) {
            if (Object.keys(rgDatabase).length === 0) return null;

            const match = findBestRGMatch(rgValue);
            if (!match) return null;

            if (options.commit) {
                return commitRGSelection(match, row, tabName);
            }

            const nomInput = getNomRGInput(row, tabName);
            if (nomInput && !nomInput.value && rgDatabase[match]?.nom) {
                nomInput.placeholder = `Suggestion: ${rgDatabase[match].nom}`;
            }

            return match;
        }

        function autoFillRGFromName(nomValue, row, tabName, options = {}) {
            if (Object.keys(rgDatabase).length === 0) return null;

            const matchCode = findBestRGNameMatch(nomValue);
            if (!matchCode) return null;

            if (options.commit) {
                return commitRGSelection(matchCode, row, tabName);
            }

            const rgInput = getRGInput(row, tabName);
            if (rgInput && !rgInput.value) {
                rgInput.placeholder = rgDatabase[matchCode]?.codeAffiche || matchCode;
            }

            return matchCode;
        }

        function autoFillNomFromUT(utValue, input, options = {}) {
            if (Object.keys(utDatabase).length === 0) return null;

            const match = findBestUTMatch(utValue);
            if (!match) return null;

            if (options.commit && input) {
                input.value = utDatabase[match]?.codeAffiche || match;
                addColumnSuggestion('UT-BAT', input.value);
            } else if (input && !input.value && utDatabase[match]?.codeAffiche) {
                input.placeholder = utDatabase[match].codeAffiche;
            }

            return match;
        }

        function autoFillUTFromName(nomValue, input, options = {}) {
            if (Object.keys(utDatabase).length === 0) return null;

            const match = findBestUTNameMatch(nomValue);
            if (!match) return null;

            if (options.commit && input) {
                input.value = utDatabase[match]?.codeAffiche || match;
                addColumnSuggestion('UT-BAT', input.value);
            } else if (input && !input.value && utDatabase[match]?.codeAffiche) {
                input.placeholder = utDatabase[match].codeAffiche;
            }

            return match;
        }

        function getRGSuggestionCandidates(value) {
            const normalized = normalizeRGValue(value || '');
            const entries = Object.entries(rgDatabase).map(([code, data]) => ({
                code,
                display: data.codeAffiche || code,
                name: data.nom || ''
            }));

            if (!normalized) return entries.slice(0, 6);

            return entries
                .filter(entry => normalizeRGValue(entry.code).includes(normalized) || normalizeRGValue(entry.display).includes(normalized))
                .sort((a, b) => normalizeRGValue(a.code).indexOf(normalized) - normalizeRGValue(b.code).indexOf(normalized))
                .slice(0, 8);
        }

        function positionSuggestionPanel(panel, input) {
            const rect = input.getBoundingClientRect();
            panel.style.top = `${rect.bottom + window.scrollY + 6}px`;
            panel.style.left = `${rect.left + window.scrollX}px`;
            panel.style.minWidth = `${rect.width}px`;
        }

        function hideRGSuggestionPanel() {
            if (currentRGSuggestionPanel && currentRGSuggestionPanel.parentNode) {
                currentRGSuggestionPanel.parentNode.removeChild(currentRGSuggestionPanel);
            }
            currentRGSuggestionPanel = null;
        }

        function showRGSuggestionPanel(input, suggestions, tabName, row) {
            hideRGSuggestionPanel();

            if (!suggestions || suggestions.length === 0) return;

            const panel = document.createElement('div');
            panel.className = 'rg-suggestion-panel';

            panel.innerHTML = suggestions.map((s, index) => `
                <div class="rg-suggestion-item ${index === 0 ? 'active' : ''}" data-code="${s.code}">
                    <span class="rg-suggestion-code">${s.display}</span>
                    <span class="rg-suggestion-name">${s.name || 'Nom manquant'}</span>
                </div>
            `).join('');

            panel.addEventListener('mousedown', (event) => {
                event.preventDefault();
                const item = event.target.closest('.rg-suggestion-item');
                if (!item) return;
                commitRGSelection(item.dataset.code, row, tabName);
            });

            document.body.appendChild(panel);
            positionSuggestionPanel(panel, input);
            currentRGSuggestionPanel = panel;
        }

        function setupRGAutoCompletion(input, row, tabName) {
            input.setAttribute('list', 'rgDatalist');

            input.addEventListener('input', () => {
                input.dataset.autoFilled = 'false';
                const suggestions = getRGSuggestionCandidates(input.value);
                showRGSuggestionPanel(input, suggestions, tabName, row);
            });

            input.addEventListener('keydown', (event) => {
                if (event.key === 'Enter') {
                    event.preventDefault();
                    const suggestions = getRGSuggestionCandidates(input.value);
                    if (suggestions[0]) {
                        commitRGSelection(suggestions[0].code, row, tabName);
                    } else {
                        autoFillNomFromRG(input.value, row, tabName, { commit: true });
                    }
                }
            });

            input.addEventListener('blur', () => {
                setTimeout(() => {
                    const normalized = normalizeRGValue(input.value);
                    const match = normalized ? findBestRGMatch(normalized) : null;
                    if (match && normalizeRGValue(match) === normalized) {
                        commitRGSelection(match, row, tabName);
                    }
                    hideRGSuggestionPanel();
                }, 120);
            });
        }

        function setupNomRGAutoCompletion(input, row, tabName) {
            input.setAttribute('list', 'rgNomDatalist');

            input.addEventListener('input', () => {
                input.dataset.autoFilled = 'false';
                autoFillRGFromName(input.value, row, tabName);
            });

            input.addEventListener('keydown', (event) => {
                if (event.key === 'Enter') {
                    event.preventDefault();
                    autoFillRGFromName(input.value, row, tabName, { commit: true });
                }
            });

            input.addEventListener('blur', () => {
                const match = autoFillRGFromName(input.value, row, tabName, { commit: true });
                if (match) hideRGSuggestionPanel();
            });
        }

        function applyIntelligentRGFill(row, tabName) {
            if (tabName === 'baserg') return;

            const rgInput = getRGInput(row, tabName);
            const nomInput = getNomRGInput(row, tabName);

            if (rgInput && rgInput.value && nomInput && !nomInput.value) {
                autoFillNomFromRG(rgInput.value, row, tabName, { commit: true });
            }

            if (nomInput && nomInput.value && rgInput && !rgInput.value) {
                autoFillRGFromName(nomInput.value, row, tabName, { commit: true });
            }
        }

        function applyIntelligentRGFillAll() {
            Object.keys(tabConfigs).forEach(tabName => {
                if (tabName === 'baserg' || tabName === 'baseut') return;

                const tbody = document.getElementById(`${tabName}TableBody`);
                if (!tbody) return;

                tbody.querySelectorAll('tr').forEach(row => applyIntelligentRGFill(row, tabName));
            });
        }

        function applyIntelligentUTFill(row, tabName) {
            if (tabName === 'baserg' || tabName === 'baseut') return;

            const utInput = getUTInput(row, tabName);
            if (!utInput) return;

            if (utInput.value) {
                const match = findBestUTMatch(utInput.value) || autoFillUTFromName(utInput.value, utInput, { commit: true });
                if (match) {
                    utInput.value = utDatabase[match]?.codeAffiche || match;
                    addColumnSuggestion('UT-BAT', utInput.value);
                }
            } else if (utInput.dataset.nomUt) {
                autoFillUTFromName(utInput.dataset.nomUt, utInput, { commit: true });
            }
        }

        function applyIntelligentUTFillAll() {
            Object.keys(tabConfigs).forEach(tabName => {
                if (tabName === 'baserg' || tabName === 'baseut') return;

                const tbody = document.getElementById(`${tabName}TableBody`);
                if (!tbody) return;

                tbody.querySelectorAll('tr').forEach(row => applyIntelligentUTFill(row, tabName));
            });
        }

        function getColumnListId(column) {
            return `suggest-${column.toLowerCase().replace(/[^a-z0-9]+/g, '-')}`;
        }

        function ensureColumnSuggestionList(column) {
            const listId = getColumnListId(column);
            let datalist = document.getElementById(listId);

            if (!datalist) {
                datalist = document.createElement('datalist');
                datalist.id = listId;
                document.body.appendChild(datalist);
            }

            return datalist;
        }

        function addColumnSuggestion(column, value) {
            if (!value || !column) return;

            const cleanedValue = value.trim();
            if (!cleanedValue) return;

            if (!columnSuggestions[column]) {
                columnSuggestions[column] = new Set();
            }

            const suggestions = columnSuggestions[column];
            if (suggestions.has(cleanedValue)) return;

            suggestions.add(cleanedValue);

            const datalist = ensureColumnSuggestionList(column);
            const option = document.createElement('option');
            option.value = cleanedValue;
            datalist.appendChild(option);
        }

        function refreshColumnSuggestionLists() {
            Object.entries(columnSuggestions).forEach(([column, values]) => {
                const datalist = ensureColumnSuggestionList(column);
                datalist.innerHTML = '';

                values.forEach(value => {
                    const option = document.createElement('option');
                    option.value = value;
                    datalist.appendChild(option);
                });
            });
        }

        function rebuildColumnSuggestions() {
            columnSuggestions = {};

            Object.keys(tabConfigs).forEach(tabName => {
                const tbody = document.getElementById(`${tabName}TableBody`);
                if (!tbody) return;

                const rows = tbody.querySelectorAll('tr');
                rows.forEach(row => {
                    const inputs = row.querySelectorAll('input, textarea, select');
                    inputs.forEach((input, index) => {
                        const column = tabConfigs[tabName]?.columns[index];

                        if (!column) return;

                        addColumnSuggestion(column, input.value);
                    });
                });
            });

            refreshColumnSuggestionLists();
        }

        function getColumnSuggestions(column) {
            return Array.from(columnSuggestions[column] || []);
        }

        function applySmartSuggestion(input, column) {
            if (!column) return;

            const currentValue = (input.value || '').toString();
            if (!currentValue || currentValue.length < 2) return;

            const suggestions = getColumnSuggestions(column)
                .filter(value => value.toLowerCase().startsWith(currentValue.toLowerCase()))
                .sort((a, b) => a.length - b.length);

            const bestMatch = suggestions.find(value => value.length > currentValue.length);
            if (!bestMatch) return;

            const selectionStart = currentValue.length;
            input.value = bestMatch;
            if (input.setSelectionRange) {
                input.setSelectionRange(selectionStart, bestMatch.length);
            }
        }

        function attachColumnAutocomplete(input, column) {
            if (input.tagName !== 'INPUT') return;

            if (!column) return;

            const existingList = input.getAttribute('list');
            const datalistId = existingList || getColumnListId(column);
            ensureColumnSuggestionList(column);
            if (!existingList) {
                input.setAttribute('list', datalistId);
            }

            if (input.value) {
                addColumnSuggestion(column, input.value);
            }

            input.addEventListener('input', () => addColumnSuggestion(column, input.value));
        }

        function buildRGDatabase() {
            try {
                updateRGDatabase();
                showNotification('üîÑ Index RG reconstruit avec succ√®s');
                logActivity('Reconstruction de l\'index RG', 'success');
            } catch (error) {
                console.error('Erreur reconstruction base RG:', error);
                showNotification('‚ùå Erreur lors de la reconstruction de l\'index RG', 'error');
            }
        }

        function buildUTDatabase() {
            try {
                updateUTDatabase();
                showNotification('üîÑ Index UT reconstruit avec succ√®s');
                logActivity('Reconstruction de l\'index UT', 'success');
            } catch (error) {
                console.error('Erreur reconstruction base UT:', error);
                showNotification('‚ùå Erreur lors de la reconstruction de l\'index UT', 'error');
            }
        }

        function updateStatsDashboard() {
            try {
                const statsData = getTabStatistics();
                const qualityCounts = getQualityCounts();
                const rgInsights = getRGChangeInsights();

                document.getElementById('totalGeneral').textContent = statsData.general.total;
                document.getElementById('traitesGeneral').textContent = statsData.general.traites;
                document.getElementById('attenteGeneral').textContent = statsData.general.attente;
                document.getElementById('tauxGeneral').textContent = statsData.general.taux + '%';
                document.getElementById('progressGeneral').style.width = statsData.general.taux + '%';

                updateIndividualStats(statsData.perTab);
                updateQualityStatus(qualityCounts);
                updateRGChangeWidget(rgInsights);
                updateStatChips(statsData.general, rgInsights, qualityCounts);
                updateCharts();

                filterStatsCards(document.getElementById('statsSearch')?.value || '');

            } catch (error) {
                console.error('Erreur mise √† jour dashboard statistiques:', error);
            }
        }

        function toggleStatsCard(headerElement) {
            const card = headerElement.closest('.stats-card');
            if (!card) return;

            const body = card.querySelector('.stats-card-body');
            const isCollapsed = card.classList.toggle('collapsed');

            if (body) {
                body.style.display = isCollapsed ? 'none' : 'block';
            }
        }

        function filterStatsCards(searchTerm = '') {
            const individualStatsContainer = document.getElementById('individualStats');
            const emptyState = document.getElementById('statsSearchEmpty');
            if (!individualStatsContainer) return;

            const normalizedTerm = searchTerm.trim().toLowerCase();
            let visibleCount = 0;

            individualStatsContainer.querySelectorAll('.stats-card').forEach(card => {
                const tabName = (card.dataset.tabName || '').toLowerCase();
                const displayName = (card.dataset.displayName || '').toLowerCase();
                const matches = !normalizedTerm || tabName.includes(normalizedTerm) || displayName.includes(normalizedTerm);

                card.style.display = matches ? '' : 'none';
                if (matches) visibleCount++;
            });

            if (emptyState) {
                emptyState.style.display = visibleCount === 0 ? 'block' : 'none';
            }
        }

        function updateIndividualStats(perTabStats) {
            try {
                const individualStatsContainer = document.getElementById('individualStats');
                if (!individualStatsContainer) return;

                individualStatsContainer.innerHTML = '';

                const statsToDisplay = perTabStats || getTabStatistics().perTab;

                statsToDisplay.forEach(stat => {
                    const rate = stat.total > 0 ? Math.round((stat.processed / stat.total) * 100) : 0;
                    const pendingRows = collectPendingRows(stat.tabName).slice(0, 4);
                    const displayName = getTabDisplayName(stat.tabName);
                    const subtitle = `${stat.total} total ‚Ä¢ ${stat.pending} en attente`;

                    const card = document.createElement('div');
                    card.className = 'stats-card collapsible collapsed';
                    card.dataset.tabName = stat.tabName;
                    card.dataset.displayName = displayName;
                    card.innerHTML = `
                        <div class="collapsible-header" onclick="toggleStatsCard(this)">
                            <div class="header-left">
                                <span class="stat-toggle" aria-hidden="true">‚ñ∏</span>
                                <div class="header-texts">
                                    <div class="header-title">${getTabIcon(stat.tabName)} ${displayName}</div>
                                    <div class="header-subtitle">${subtitle}</div>
                                </div>
                            </div>
                            <div class="header-chip">${rate}%</div>
                        </div>
                        <div class="stats-card-body">
                            <div style="display: flex; justify-content: space-between; margin-bottom: 15px;">
                                <div style="text-align: center;">
                                    <div class="preview-stat-number">${stat.total}</div>
                                    <div class="preview-stat-label">Total</div>
                                </div>
                                <div style="text-align: center;">
                                    <div class="preview-stat-number success">${stat.processed}</div>
                                    <div class="preview-stat-label">Trait√©s</div>
                                </div>
                                <div style="text-align: center;">
                                    <div class="preview-stat-number warning">${stat.pending}</div>
                                    <div class="preview-stat-label">En attente</div>
                                </div>
                            </div>
                            <div class="progress-bar">
                                <div class="progress-fill" style="width: ${rate}%"></div>
                            </div>
                            <div style="text-align: center; margin-top: 10px; font-weight: 600; color: #667eea;">
                                ${rate}% compl√©t√©
                            </div>
                            <div style="margin-top: 12px;">
                                <div style="display: flex; justify-content: space-between; align-items: center; gap: 8px;">
                                    <span style="font-weight: 600; color: #444;">En attente</span>
                                    <button class="btn btn-secondary btn-compact" onclick="goToNextPending('${stat.tabName}')">
                                        üìç Ouvrir la prochaine
                                    </button>
                                </div>
                                <div style="margin-top: 6px; display: grid; gap: 6px;">
                                    ${pendingRows.length === 0
                                        ? '<div style="color: #777; font-size: 12px;">Aucune ligne en attente</div>'
                                        : pendingRows.map(row => `
                                            <div class="pending-link" onclick="focusPendingRow('${stat.tabName}', ${row.index});">
                                                <span>${row.title}</span>
                                                <small>${row.subtitle}</small>
                                            </div>
                                        `).join('')}
                                </div>
                            </div>
                        </div>
                    `;

                    individualStatsContainer.appendChild(card);
                });

                filterStatsCards(document.getElementById('statsSearch')?.value || '');

            } catch (error) {
                console.error('Erreur mise √† jour statistiques individuelles:', error);
            }
        }

        function getQualityCounts() {
            const counts = { errors: 0, warnings: 0 };

            try {
                Object.keys(tabConfigs).forEach(tabName => {
                    if (tabName === 'baserg' || tabName === 'baseut') return;

                    const tbody = document.getElementById(`${tabName}TableBody`);
                    if (!tbody) return;

                    const rows = tbody.querySelectorAll('tr');

                    rows.forEach(row => {
                        const inputs = row.querySelectorAll('input, textarea, select');
                        inputs.forEach(input => {
                            if (input.classList.contains('has-error')) {
                                counts.errors++;
                            } else if (input.classList.contains('has-warning')) {
                                counts.warnings++;
                            }
                        });
                    });
                });
            } catch (error) {
                console.error('Erreur comptage qualit√©:', error);
            }

            return counts;
        }

        function getQualityIssues() {
            const issues = [];

            try {
                Object.keys(tabConfigs).forEach(tabName => {
                    if (tabName === 'baserg' || tabName === 'baseut') return;

                    const tbody = document.getElementById(`${tabName}TableBody`);
                    if (!tbody) return;

                    const rows = tbody.querySelectorAll('tr');

                    rows.forEach((row, rowIndex) => {
                        const inputs = row.querySelectorAll('input, textarea, select');

                        inputs.forEach((input, colIndex) => {
                            const columnName = tabConfigs[tabName]?.columns[colIndex];
                            if (!columnName) return;

                            let severity = null;
                            if (input.classList.contains('has-error')) {
                                severity = 'error';
                            } else if (input.classList.contains('has-warning')) {
                                severity = 'warning';
                            }

                            if (severity) {
                                issues.push({
                                    tabName,
                                    rowIndex,
                                    columnIndex: colIndex,
                                    columnName,
                                    severity,
                                    message: input.title || 'Anomalie d√©tect√©e',
                                    value: input.value
                                });
                            }
                        });
                    });
                });
            } catch (error) {
                console.error('Erreur collecte alertes qualit√©:', error);
            }

            return issues.sort((a, b) => {
                const order = { error: 0, warning: 1 };
                return (order[a.severity] ?? 2) - (order[b.severity] ?? 2);
            });
        }

        function toggleQualityAlerts() {
            qualityAlertsExpanded = !qualityAlertsExpanded;
            updateQualityStatus();
        }

        function renderQualityAlerts(issues) {
            const container = document.getElementById('qualityAlertsContainer');
            if (!container) return;

            if (!issues || issues.length === 0) {
                container.innerHTML = '<div class="quality-alert-empty">Pas d\'alerte √† afficher</div>';
                return;
            }

            const visibleIssues = qualityAlertsExpanded ? issues : issues.slice(0, 5);

            const alertsHtml = visibleIssues.map(issue => {
                const icon = issue.severity === 'error' ? '‚ùå' : '‚ö†Ô∏è';
                const label = issue.severity === 'error' ? 'Erreur' : 'Avertissement';

                return `
                    <div class="quality-alert-item" onclick="focusQualityIssue('${issue.tabName}', ${issue.rowIndex}, ${issue.columnIndex})">
                        <div>
                            <div><strong>${icon} ${label}</strong> - ${getTabDisplayName(issue.tabName)} (${issue.columnName})</div>
                            <div class="alert-meta">${issue.message}</div>
                        </div>
                        <div class="alert-meta">Ligne ${issue.rowIndex + 1}</div>
                    </div>
                `;
            }).join('');

            const toggleButton = issues.length > 5
                ? `<button class="btn btn-secondary" style="width: 100%; margin-top: 8px;" onclick="toggleQualityAlerts()">${qualityAlertsExpanded ? 'R√©duire la liste' : 'Afficher toutes les alertes'} (${issues.length})</button>`
                : '';

            container.innerHTML = alertsHtml + toggleButton;
        }

        function focusQualityIssue(tabName, rowIndex, columnIndex) {
            try {
                switchTab(tabName);

                requestAnimationFrame(() => {
                    const tbody = document.getElementById(`${tabName}TableBody`);
                    if (!tbody) return;

                    const rows = tbody.querySelectorAll('tr');
                    const targetRow = rows[rowIndex];
                    if (targetRow) {
                        targetRow.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        targetRow.classList.add('highlight-result');
                        setTimeout(() => targetRow.classList.remove('highlight-result'), 2000);

                        const inputs = targetRow.querySelectorAll('input, textarea, select');
                        const targetInput = inputs[columnIndex];
                        if (targetInput) {
                            targetInput.focus();
                        }
                    }
                });

            } catch (error) {
                console.error('Erreur lors du focus sur une alerte qualit√©:', error);
            }
        }

        
        function updateQualityStatus(counts) {
            try {
                const container = document.getElementById('qualityStatus');
                if (!container) return;

                const issues = getQualityIssues();
                const { errors = 0, warnings = 0 } = counts || getQualityCounts();

                let status, icon, color;

                if (errors === 0 && warnings === 0) {
                    status = 'Vos donn√©es sont coh√©rentes !';
                    icon = '‚úÖ';
                    color = '#28a745';
                } else if (errors > 0) {
                    status = `${errors} erreur(s) d√©tect√©e(s)`;
                    icon = '‚ùå';
                    color = '#dc3545';
                } else {
                    status = `${warnings} avertissement(s)`;
                    icon = '‚ö†Ô∏è';
                    color = '#ffc107';
                }

                container.innerHTML = `
                    <div style="font-size: 48px; margin-bottom: 15px;">${icon}</div>
                    <div style="font-size: 18px; font-weight: 600; color: ${color};">${status}</div>
                    <div style="color: #666; margin-top: 10px;">Derni√®re v√©rification: ${new Date().toLocaleTimeString('fr-FR')}</div>
                `;

                renderQualityAlerts(issues);

            } catch (error) {
                console.error('Erreur mise √† jour qualit√©:', error);
            }
        }

        function updateCharts() {
            try {
                updateTabsChart();
                updateEvolutionChart();
                updateVerificationChart();
                updateSurfaceChart();
            } catch (error) {
                console.error('Erreur mise √† jour graphiques:', error);
            }
        }

function updateTabsChart() {
            try {
                const ctx = document.getElementById('tabsChart');
                if (!ctx) return;
                
                const labels = [];
                const data = [];
                const backgroundColors = [
                    '#667eea', '#764ba2', '#f093fb', '#f5576c',
                    '#4facfe', '#00f2fe', '#43e97b', '#38f9d7'
                ];
                
                Object.keys(tabConfigs).forEach((tabName, index) => {
                    if (tabName === 'baserg' || tabName === 'baseut') return;
                    
                    const tbody = document.getElementById(`${tabName}TableBody`);
                    if (tbody) {
                        const rowCount = tbody.querySelectorAll('tr').length;
                        if (rowCount > 0) {
                            labels.push(getTabDisplayName(tabName));
                            data.push(rowCount);
                        }
                    }
                });
                
                if (chartInstances.tabsChart) {
                    chartInstances.tabsChart.destroy();
                }
                
                if (data.length > 0 && window.Chart) {
                    chartInstances.tabsChart = new Chart(ctx, {
                        type: 'doughnut',
                        data: {
                            labels: labels,
                            datasets: [{
                                data: data,
                                backgroundColor: backgroundColors.slice(0, data.length),
                                borderWidth: 2,
                                borderColor: '#fff'
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    position: 'right',
                                    labels: {
                                        boxWidth: 12,
                                        font: {
                                            size: 12
                                        }
                                    }
                                }
                            }
                        }
                    });
                }
                
            } catch (error) {
                console.error('Erreur graphique r√©partition:', error);
            }
        }

        function getMonthlyTreatmentCounts(tabName) {
            const counts = new Map();

            try {
                const tbody = document.getElementById(`${tabName}TableBody`);
                if (!tbody) return counts;

                const rows = tbody.querySelectorAll('tr');
                const dateIndex = tabConfigs[tabName]?.columns.indexOf('Date Traitement');
                if (dateIndex === undefined || dateIndex < 0) return counts;

                rows.forEach(row => {
                    const inputs = row.querySelectorAll('input, textarea, select');
                    const dateValue = inputs[dateIndex] ? inputs[dateIndex].value : '';
                    const date = reviveDate(dateValue);

                    if (date) {
                        const key = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                        counts.set(key, (counts.get(key) || 0) + 1);
                    }
                });

            } catch (error) {
                console.error('Erreur collecte donn√©es √©volution:', error);
            }

            return counts;
        }

        function formatMonthLabel(monthKey) {
            const [year, month] = monthKey.split('-').map(Number);
            const date = new Date(year, month - 1, 1);
            return date.toLocaleDateString('fr-FR', { month: 'short', year: '2-digit' });
        }

        function updateEvolutionChart() {
            try {
                const ctx = document.getElementById('evolutionChart');
                if (!ctx || !window.Chart) return;

                const creationCounts = getMonthlyTreatmentCounts('creation');
                const modificationCounts = getMonthlyTreatmentCounts('modification');

                const monthKeys = Array.from(new Set([
                    ...creationCounts.keys(),
                    ...modificationCounts.keys()
                ])).sort();

                const selectedMonths = monthKeys.length > 0 ? monthKeys.slice(-6) : [];
                const labels = selectedMonths.length > 0 ? selectedMonths.map(formatMonthLabel) : ['Aucune donn√©e'];
                const creationData = selectedMonths.length > 0 ? selectedMonths.map(key => creationCounts.get(key) || 0) : [0];
                const modificationData = selectedMonths.length > 0 ? selectedMonths.map(key => modificationCounts.get(key) || 0) : [0];

                if (chartInstances.evolutionChart) {
                    chartInstances.evolutionChart.destroy();
                }

                chartInstances.evolutionChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'Cr√©ation',
                            data: creationData,
                            borderColor: '#667eea',
                            backgroundColor: 'rgba(102, 126, 234, 0.1)',
                            tension: 0.4,
                            fill: true
                        }, {
                            label: 'Modification',
                            data: modificationData,
                            borderColor: '#764ba2',
                            backgroundColor: 'rgba(118, 75, 162, 0.1)',
                            tension: 0.4,
                            fill: true
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: true
                            }
                        },
                        plugins: {
                            legend: {
                                position: 'top'
                            }
                        }
                    }
                });

            } catch (error) {
                console.error('Erreur graphique √©volution:', error);
            }
        }

        function updateVerificationChart() {
            try {
                const ctx = document.getElementById('verificationChart');
                if (!ctx || !window.Chart) return;
                
                const tbody = document.getElementById('verifbauxTableBody');
                if (!tbody) return;
                
                let ok = 0, nok = 0, enCours = 0;
                
                const rows = tbody.querySelectorAll('tr');
                rows.forEach(row => {
                    const inputs = row.querySelectorAll('input, textarea, select');
                    const etatIndex = tabConfigs['verifbaux'].columns.indexOf('√âtat');
                    const etatInput = inputs[etatIndex];
                    const etat = etatInput ? etatInput.value.toUpperCase() : '';
                    
                    if (etat === 'OK') ok++;
                    else if (etat === 'NOK') nok++;
                    else if (etat === 'EN COURS') enCours++;
                });
                
                if (chartInstances.verificationChart) {
                    chartInstances.verificationChart.destroy();
                }
                
                if (ok + nok + enCours > 0) {
                    chartInstances.verificationChart = new Chart(ctx, {
                        type: 'pie',
                        data: {
                            labels: ['OK', 'NOK', 'En cours'],
                            datasets: [{
                                data: [ok, nok, enCours],
                                backgroundColor: ['#28a745', '#dc3545', '#ffc107'],
                                borderWidth: 2,
                                borderColor: '#fff'
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    position: 'bottom'
                                }
                            }
                        }
                    });
                }
                
            } catch (error) {
                console.error('Erreur graphique v√©rification:', error);
            }
        }

        function updateSurfaceChart() {
            try {
                const ctx = document.getElementById('surfaceChart');
                if (!ctx || !window.Chart) return;
                
                const tbody = document.getElementById('modifsurfaceTableBody');
                if (!tbody) return;
                
                const rows = tbody.querySelectorAll('tr');
                const surfaceData = [];
                const labels = [];
                
                rows.forEach((row, index) => {
                    const inputs = row.querySelectorAll('input, textarea, select');
                    const differenceIndex = tabConfigs['modifsurface'].columns.indexOf('Diff√©rence');
                    const difference = inputs[differenceIndex] ? parseFloat(inputs[differenceIndex].value) || 0 : 0;
                    
                    if (difference !== 0) {
                        surfaceData.push(difference);
                        labels.push(`Modification ${index + 1}`);
                    }
                });
                
                if (chartInstances.surfaceChart) {
                    chartInstances.surfaceChart.destroy();
                }
                
                if (surfaceData.length > 0) {
                    chartInstances.surfaceChart = new Chart(ctx, {
                        type: 'bar',
                        data: {
                            labels: labels,
                            datasets: [{
                                label: 'Diff√©rence de surface (m¬≤)',
                                data: surfaceData,
                                backgroundColor: surfaceData.map(val => val > 0 ? '#28a745' : '#dc3545'),
                                borderWidth: 1
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                y: {
                                    beginAtZero: true
                                }
                            },
                            plugins: {
                                legend: {
                                    display: false
                                }
                            }
                        }
                    });
                }
                
            } catch (error) {
                console.error('Erreur graphique surface:', error);
            }
        }

        // üîç SYST√àME DE FILTRAGE
        function filterTable(tabName) {
            try {
                const tbody = document.getElementById(`${tabName}TableBody`);
                if (!tbody) return;
                
                const rows = tbody.querySelectorAll('tr');
                const filters = getFiltersForTab(tabName);
                
                rows.forEach(row => {
                    let showRow = true;
                    const inputs = row.querySelectorAll('input, textarea, select');
                    
                    Object.keys(filters).forEach(filterName => {
                        const filterValue = filters[filterName].toLowerCase();
                        if (!filterValue) return;
                        
                        const columnIndex = getColumnIndex(tabName, filterName);
                        if (columnIndex >= 0 && columnIndex < inputs.length) {
                            const cellValue = inputs[columnIndex].value.toLowerCase();
                            
                            if (filterName.includes('Date')) {
                                if (!filterDateRange(cellValue, filterValue, filterName)) {
                                    showRow = false;
                                }
                            } else if (filterName === 'Status') {
                                const hasDateTraitement = inputs[tabConfigs[tabName].columns.indexOf('Date Traitement')] && 
                                                         inputs[tabConfigs[tabName].columns.indexOf('Date Traitement')].value;
                                const isProcessed = hasDateTraitement ? 'traite' : 'attente';
                                if (filterValue !== isProcessed) {
                                    showRow = false;
                                }
                            } else {
                                if (!cellValue.includes(filterValue)) {
                                    showRow = false;
                                }
                            }
                        }
                    });
                    
                    row.style.display = showRow ? '' : 'none';
                });
                
            } catch (error) {
                console.error('Erreur filtrage tableau:', error);
            }
        }

        function getFiltersForTab(tabName) {
            const filters = {};
            const filterElements = document.querySelectorAll(`[id^="filter${tabName.charAt(0).toUpperCase() + tabName.slice(1)}"]`);
            
            filterElements.forEach(element => {
                const filterId = element.id;
                const filterName = filterId.replace(`filter${tabName.charAt(0).toUpperCase() + tabName.slice(1)}`, '');
                filters[filterName] = element.value;
            });
            
            return filters;
        }

        function getColumnIndex(tabName, filterName) {
            const columns = tabConfigs[tabName]?.columns || [];
            const columnMap = {
                'GA': 'GA',
                'DateFrom': 'Date Demande',
                'DateTo': 'Date Demande',
                'RG': 'RG',
                'UTBAT': 'UT-BAT',
                'Status': 'Date Traitement',
                'Etat': '√âtat',
                'Region': 'R√©gion',
                'Type': 'Type Modification',
                'Code': tabName === 'baseut' ? 'Code UT' : 'Code RG',
                'Nom': tabName === 'baseut' ? 'Nom UT' : 'Nom de RG',
                'Usage': 'Utilisations',
                'Bail': 'Num√©ro de Bail',
                'Lieu': 'Lieu'
            };
            
            const columnName = columnMap[filterName];
            return columnName ? columns.indexOf(columnName) : -1;
        }

        function filterDateRange(cellValue, filterValue, filterType) {
            if (!cellValue || !filterValue) return true;
            
            const cellDate = new Date(cellValue);
            const filterDate = new Date(filterValue);
            
            if (filterType.includes('From')) {
                return cellDate >= filterDate;
            } else if (filterType.includes('To')) {
                return cellDate <= filterDate;
            }
            
            return true;
        }

        // üîç SYST√àME DE RECHERCHE AVANC√âE
        function performSearch() {
            try {
                const startTime = performance.now();
                
                const searchParams = {
                    ga: document.getElementById('searchGA').value.toLowerCase(),
                    rg: document.getElementById('searchRG').value.toLowerCase(),
                    utbat: document.getElementById('searchUTBAT').value.toLowerCase(),
                    bail: document.getElementById('searchBail').value.toLowerCase(),
                    advancedBail: (document.getElementById('advancedSearchBail')?.value || '').toLowerCase(),
                    dateFrom: document.getElementById('searchDateFrom').value,
                    dateTo: document.getElementById('searchDateTo').value,
                    tab: document.getElementById('searchTab').value,
                    keyword: document.getElementById('searchKeyword').value.toLowerCase()
                };
                
                searchResults = [];
                
                const tabsToSearch = searchParams.tab ? [searchParams.tab] :
                    Object.keys(tabConfigs).filter(t => t !== 'baserg' && t !== 'baseut');
                
                tabsToSearch.forEach(tabName => {
                    const tbody = document.getElementById(`${tabName}TableBody`);
                    if (!tbody) return;
                    
                    const rows = tbody.querySelectorAll('tr');
                    const columns = tabConfigs[tabName]?.columns || [];
                    
                    rows.forEach((row, rowIndex) => {
                        const inputs = row.querySelectorAll('input, textarea, select');
                        let matchFound = false;
                        const rowData = [];
                        
                        inputs.forEach((input, inputIndex) => {
                            const value = input.value.toLowerCase();
                            rowData.push(input.value);
                            
                            if (searchParams.ga && columns[inputIndex] === 'GA' && value.includes(searchParams.ga)) matchFound = true;
                            if (searchParams.rg && (columns[inputIndex] === 'RG' || columns[inputIndex] === 'Code RG') && value.includes(searchParams.rg)) matchFound = true;
                            if (searchParams.utbat && columns[inputIndex] === 'UT-BAT' && value.includes(searchParams.utbat)) matchFound = true;
                            if (searchParams.bail && columns[inputIndex].includes('Bail') && value.includes(searchParams.bail)) matchFound = true;
                            if (searchParams.advancedBail && columns[inputIndex].includes('Bail') && value.includes(searchParams.advancedBail)) matchFound = true;
                            if (searchParams.keyword && value.includes(searchParams.keyword)) matchFound = true;
                            
                            if (searchParams.dateFrom || searchParams.dateTo) {
                                if (columns[inputIndex] && columns[inputIndex].includes('Date') && input.value) {
                                    const cellDate = new Date(input.value);
                                    let dateMatches = true;
                                    if (searchParams.dateFrom && cellDate < new Date(searchParams.dateFrom)) dateMatches = false;
                                    if (searchParams.dateTo && cellDate > new Date(searchParams.dateTo)) dateMatches = false;
                                    if (dateMatches && (searchParams.dateFrom || searchParams.dateTo)) matchFound = true;
                                }
                            }
                        });
                        
                        if (matchFound) {
                            searchResults.push({
                                tabName: tabName,
                                tabDisplayName: getTabDisplayName(tabName),
                                rowIndex: rowIndex,
                                data: rowData,
                                columns: columns
                            });
                        }
                    });
                });
                
                const endTime = performance.now();
                const searchTime = Math.round(endTime - startTime);
                
                displaySearchResults(searchTime, searchParams);
                
            } catch (error) {
                console.error('Erreur recherche:', error);
                showNotification('‚ùå Erreur lors de la recherche', 'error');
            }
        }

        function performAdvancedSearch() {
            try {
                const advancedOptions = document.getElementById('advancedSearchOptions');
                if (advancedOptions.style.display === 'none') {
                    advancedOptions.style.display = 'block';
                    showNotification('üéØ Options de recherche avanc√©e activ√©es', 'info');
                } else {
                    advancedOptions.style.display = 'none';
                }
            } catch (error) {
                console.error('Erreur recherche avanc√©e:', error);
            }
        }

        function displaySearchResults(searchTime, searchParams) {
            try {
                const resultsContainer = document.getElementById('searchResults');
                const resultsHead = document.getElementById('searchResultsHead');
                const resultsBody = document.getElementById('searchResultsBody');
                const resultsCount = document.getElementById('searchResultsCount');
                const searchTimeElement = document.getElementById('searchTime');
                const searchCriteriaElement = document.getElementById('searchCriteria');
                
                resultsCount.textContent = searchResults.length;
                searchTimeElement.textContent = searchTime;
                
                // Construire les crit√®res
                const criteria = [];
                if (searchParams.ga) criteria.push(`GA: ${searchParams.ga}`);
                if (searchParams.rg) criteria.push(`RG: ${searchParams.rg}`);
                if (searchParams.utbat) criteria.push(`UT-BAT: ${searchParams.utbat}`);
                if (searchParams.bail) criteria.push(`Bail: ${searchParams.bail}`);
                if (searchParams.advancedBail) criteria.push(`Bail (avanc√©): ${searchParams.advancedBail}`);
                if (searchParams.keyword) criteria.push(`Mot-cl√©: ${searchParams.keyword}`);
                searchCriteriaElement.textContent = criteria.length > 0 ? criteria.join(', ') : 'Tous';
                
                if (searchResults.length === 0) {
                    resultsContainer.style.display = 'none';
                    showNotification('‚ÑπÔ∏è Aucun r√©sultat trouv√©', 'warning');
                    document.getElementById('saveSearchBtn').disabled = true;
                    return;
                }
                
                // En-t√™te
                resultsHead.innerHTML = '';
                const headerRow = document.createElement('tr');
                headerRow.innerHTML = `
                    <th style="width: 40px;">#</th>
                    <th style="width: 150px;">Onglet</th>
                    <th style="width: 80px;">GA</th>
                    <th style="width: 120px;">Date</th>
                    <th style="width: 80px;">RG</th>
                    <th style="width: 120px;">Bail</th>
                    <th style="width: 100px;">UT-BAT</th>
                    <th style="width: 200px;">D√©tails</th>
                    <th style="width: 100px;">Action</th>
                `;
                resultsHead.appendChild(headerRow);
                
                // Corps
                resultsBody.innerHTML = '';
                searchResults.forEach((result, index) => {
                    const row = document.createElement('tr');
                    row.className = 'result-row';
                    
                    const ga = result.data[result.columns.indexOf('GA')] || '';
                    const date = result.data[result.columns.indexOf('Date Demande')] || result.data[result.columns.indexOf('Date')] || '';
                    const rg = result.data[result.columns.indexOf('RG')] || result.data[result.columns.indexOf('Code RG')] || '';
                    const bail = result.data[result.columns.findIndex(col => col.includes('Bail'))] || '';
                    const utbat = result.data[result.columns.indexOf('UT-BAT')] || '';
                    const details = result.data.slice(0, 3).join(' | ');
                    
                    row.innerHTML = `
                        <td class="row-number">${index + 1}</td>
                        <td><span style="color: #667eea;">${getTabIcon(result.tabName)} ${result.tabDisplayName}</span></td>
                        <td>${ga}</td>
                        <td>${date}</td>
                        <td>${rg}</td>
                        <td>${bail}</td>
                        <td>${utbat}</td>
                        <td style="font-size: 12px; color: #666;">${details}</td>
                        <td>
                            <button class="btn" style="padding: 4px 8px; font-size: 11px;" 
                                    onclick="goToResult('${result.tabName}', ${result.rowIndex})">
                                üîó Aller √†
                            </button>
                        </td>
                    `;
                    
                    resultsBody.appendChild(row);
                });
                
                resultsContainer.style.display = 'block';
                document.getElementById('saveSearchBtn').disabled = false;
                showNotification(`üîç ${searchResults.length} r√©sultat(s) trouv√©(s) en ${searchTime}ms`);
                
            } catch (error) {
                console.error('Erreur affichage r√©sultats:', error);
                showNotification('‚ùå Erreur lors de l\'affichage des r√©sultats', 'error');
            }
        }

        function goToResult(tabName, rowIndex) {
            try {
                switchTab(tabName);
                
                setTimeout(() => {
                    const tbody = document.getElementById(`${tabName}TableBody`);
                    if (tbody) {
                        const rows = tbody.querySelectorAll('tr');
                        if (rows[rowIndex]) {
                            rows[rowIndex].scrollIntoView({ behavior: 'smooth', block: 'center' });
                            rows[rowIndex].classList.add('highlight-result');
                            setTimeout(() => {
                                rows[rowIndex].classList.remove('highlight-result');
                            }, 3000);
                        }
                    }
                }, 200);
                
            } catch (error) {
                console.error('Erreur navigation vers r√©sultat:', error);
                showNotification('‚ùå Erreur lors de la navigation', 'error');
            }
        }

        function clearSearch() {
            try {
                document.getElementById('searchGA').value = '';
                document.getElementById('searchRG').value = '';
                document.getElementById('searchUTBAT').value = '';
                document.getElementById('searchBail').value = '';
                const advancedBailInput = document.getElementById('advancedSearchBail');
                if (advancedBailInput) advancedBailInput.value = '';
                document.getElementById('searchDateFrom').value = '';
                document.getElementById('searchDateTo').value = '';
                document.getElementById('searchTab').value = '';
                document.getElementById('searchKeyword').value = '';
                
                document.getElementById('searchResults').style.display = 'none';
                document.getElementById('saveSearchBtn').disabled = true;
                searchResults = [];
                
                showNotification('üóëÔ∏è Crit√®res de recherche effac√©s');
                
            } catch (error) {
                console.error('Erreur effacement recherche:', error);
            }
        }

        function saveCurrentSearch() {
            try {
                if (searchResults.length === 0) {
                    showNotification('‚ùå Aucune recherche √† sauvegarder', 'error');
                    return;
                }
                
                const searchName = prompt('Nom de la recherche sauvegard√©e:');
                if (!searchName) return;
                
                const searchParams = {
                    ga: document.getElementById('searchGA').value,
                    rg: document.getElementById('searchRG').value,
                    utbat: document.getElementById('searchUTBAT').value,
                    bail: document.getElementById('searchBail').value,
                    advancedBail: document.getElementById('advancedSearchBail')?.value || '',
                    dateFrom: document.getElementById('searchDateFrom').value,
                    dateTo: document.getElementById('searchDateTo').value,
                    tab: document.getElementById('searchTab').value,
                    keyword: document.getElementById('searchKeyword').value
                };
                
                const savedSearch = {
                    id: generateUniqueId(),
                    name: searchName,
                    params: searchParams,
                    createdAt: new Date(),
                    resultCount: searchResults.length
                };
                
                savedSearches.push(savedSearch);
                updateSavedSearchesDisplay();
                saveAllData();
                
                showNotification(`üíæ Recherche "${searchName}" sauvegard√©e`);
                
            } catch (error) {
                console.error('Erreur sauvegarde recherche:', error);
                showNotification('‚ùå Erreur lors de la sauvegarde', 'error');
            }
        }

        function updateSavedSearchesDisplay() {
            try {
                const container = document.getElementById('savedSearches');
                if (!container) return;
                
                if (savedSearches.length === 0) {
                    container.innerHTML = '<p style="color: #666; text-align: center; padding: 20px;">Aucune recherche sauvegard√©e.</p>';
                    return;
                }
                
                const html = savedSearches.map(search => {
                    const date = search.createdAt.toLocaleDateString('fr-FR');
                    return `
                        <div style="display: flex; justify-content: space-between; align-items: center; padding: 10px; border: 1px solid #eee; border-radius: 6px; margin-bottom: 10px;">
                            <div>
                                <div style="font-weight: 600;">${search.name}</div>
                                <div style="font-size: 12px; color: #666;">${search.resultCount} r√©sultat(s) ‚Ä¢ ${date}</div>
                            </div>
                            <div>
                                <button class="btn" style="padding: 4px 8px; font-size: 11px; margin-right: 5px;" onclick="loadSavedSearch('${search.id}')">
                                    üîç Charger
                                </button>
                                <button class="btn btn-danger" style="padding: 4px 8px; font-size: 11px;" onclick="deleteSavedSearch('${search.id}')">
                                    üóëÔ∏è
                                </button>
                            </div>
                        </div>
                    `;
                }).join('');
                
                container.innerHTML = html;
                
            } catch (error) {
                console.error('Erreur affichage recherches sauvegard√©es:', error);
            }
        }

        function loadSavedSearch(searchId) {
            try {
                const search = savedSearches.find(s => s.id === searchId);
                if (!search) return;
                
                // Charger les param√®tres
                document.getElementById('searchGA').value = search.params.ga || '';
                document.getElementById('searchRG').value = search.params.rg || '';
                document.getElementById('searchUTBAT').value = search.params.utbat || '';
                document.getElementById('searchBail').value = search.params.bail || '';
                const advancedBailInput = document.getElementById('advancedSearchBail');
                if (advancedBailInput) advancedBailInput.value = search.params.advancedBail || '';
                document.getElementById('searchDateFrom').value = search.params.dateFrom || '';
                document.getElementById('searchDateTo').value = search.params.dateTo || '';
                document.getElementById('searchTab').value = search.params.tab || '';
                document.getElementById('searchKeyword').value = search.params.keyword || '';
                
                // Ex√©cuter la recherche
                performSearch();
                
                showNotification(`üîç Recherche "${search.name}" charg√©e`);
                
            } catch (error) {
                console.error('Erreur chargement recherche:', error);
                showNotification('‚ùå Erreur lors du chargement', 'error');
            }
        }

        function deleteSavedSearch(searchId) {
            try {
                if (confirm('Supprimer cette recherche sauvegard√©e ?')) {
                    savedSearches = savedSearches.filter(s => s.id !== searchId);
                    updateSavedSearchesDisplay();
                    saveAllData();
                    showNotification('üóëÔ∏è Recherche sauvegard√©e supprim√©e');
                }
            } catch (error) {
                console.error('Erreur suppression recherche:', error);
            }
        }

        function exportSearchResults() {
            try {
                if (searchResults.length === 0) {
                    showNotification('‚ùå Aucun r√©sultat √† exporter', 'error');
                    return;
                }
                
                if (!window.XLSX) {
                    showNotification('‚ùå Biblioth√®que Excel non disponible', 'error');
                    return;
                }
                
                const wsData = [['#', 'Onglet', 'GA', 'Date', 'RG', 'Bail', 'UT-BAT', 'D√©tails']];
                
                searchResults.forEach((result, index) => {
                    const ga = result.data[result.columns.indexOf('GA')] || '';
                    const date = result.data[result.columns.indexOf('Date Demande')] || '';
                    const rg = result.data[result.columns.indexOf('RG')] || '';
                    const bail = result.data[result.columns.findIndex(col => col.includes('Bail'))] || '';
                    const utbat = result.data[result.columns.indexOf('UT-BAT')] || '';
                    const details = result.data.join(' | ');
                    
                    wsData.push([
                        index + 1,
                        result.tabDisplayName,
                        ga,
                        date,
                        rg,
                        bail,
                        utbat,
                        details
                    ]);
                });
                
                const ws = XLSX.utils.aoa_to_sheet(wsData);
                const wb = XLSX.utils.book_new();
                XLSX.utils.book_append_sheet(wb, ws, 'R√©sultats de recherche');
                
                const fileName = `MARTINE_Recherche_${new Date().toISOString().split('T')[0]}.xlsx`;
                XLSX.writeFile(wb, fileName);
                
                showNotification(`üìä R√©sultats export√©s: ${fileName}`);
                
            } catch (error) {
                console.error('Erreur export r√©sultats:', error);
                showNotification('‚ùå Erreur lors de l\'export', 'error');
            }
        }

        // üìù GESTION DES T√ÇCHES COMPL√àTE
        function updateTaskFields() {
            try {
                const targetTab = document.getElementById('taskTargetTab').value;
                const fieldsContainer = document.getElementById('taskFieldsContainer');
                const transferBtn = document.getElementById('transferTaskBtn');
                const pendingBtn = document.getElementById('pendingTaskBtn');
                const batchBtn = document.getElementById('batchTaskBtn');
                const hasActiveBatch = Boolean(getActiveBatch());

                if (!targetTab) {
                    fieldsContainer.innerHTML = '<p style="color: #666; text-align: center; padding: 20px;">S√©lectionnez un onglet pour voir les champs disponibles</p>';
                    transferBtn.disabled = true;
                    pendingBtn.disabled = true;
                    batchBtn.disabled = true;
                    refreshExcelFieldHints();
                    updateExcelImportButtons();
                    return;
                }

                const columns = tabConfigs[targetTab]?.columns || [];
                fieldsContainer.innerHTML = '';

                columns.forEach((column, index) => {
                    const fieldDiv = document.createElement('div');
                    fieldDiv.className = 'task-field';
                    
                    const label = document.createElement('label');
                    label.textContent = column;
                    
                    const input = document.createElement('input');
                    input.type = getInputType(column);
                    input.placeholder = `Saisir ${column.toLowerCase()}...`;
                    input.id = `taskField_${index}`;
                    
                    fieldDiv.appendChild(label);
                    fieldDiv.appendChild(input);
                    fieldsContainer.appendChild(fieldDiv);
                });

                transferBtn.disabled = false;
                pendingBtn.disabled = false;
                batchBtn.disabled = !hasActiveBatch;
                if (excelPreviewData.length && excelAssignmentsTab !== targetTab) {
                    initializeExcelFieldAssignments(true);
                    renderExcelMappingWorkbench();
                }
                refreshExcelFieldHints();
                updateExcelImportButtons();

            } catch (error) {
                console.error('Erreur mise √† jour champs t√¢che:', error);
            }
        }

        // üìã Import Excel par copier/coller
        function handleExcelPastePreview() {
            try {
                const targetTab = document.getElementById('taskTargetTab').value;
                if (!targetTab) {
                    showNotification('S√©lectionnez un onglet cible avant de coller vos donn√©es.', 'warning');
                    return;
                }

                const textarea = document.getElementById('excelPasteArea');
                const rawValue = (textarea?.value || '').trim();
                if (!rawValue) {
                    showNotification('Collez des lignes copi√©es depuis Excel pour continuer.', 'info');
                    return;
                }

                const rows = rawValue
                    .split(/\r?\n/)
                    .map(line => line.split('\t').map(cell => cell.trim()))
                    .filter(row => row.some(cell => cell !== ''));

                if (rows.length === 0) {
                    showNotification('Impossible de d√©tecter des donn√©es exploitables.', 'warning');
                    return;
                }

                excelPreviewData = rows;
                const maxColumns = rows.reduce((max, row) => Math.max(max, row.length), 0);
                excelPreviewColumnOrder = Array.from({ length: maxColumns }, (_, index) => index);
                initializeExcelFieldAssignments(true);
                renderExcelPreview();
                updateExcelImportButtons();

                showNotification(`üìã ${rows.length} ligne(s) pr√™te(s) pour import. Faites glisser les ent√™tes si besoin.`);
            } catch (error) {
                console.error('Erreur pr√©paration import Excel:', error);
                showNotification('‚ùå Erreur lors de l\'analyse des donn√©es coll√©es', 'error');
            }
        }

        function renderExcelPreview() {
            const container = document.getElementById('excelPreviewContainer');
            const meta = document.getElementById('excelPreviewMeta');
            const targetTab = document.getElementById('taskTargetTab').value;

            if (!container) return;

            if (!excelPreviewData.length) {
                container.innerHTML = '<div class="excel-preview-empty">Collez vos donn√©es pour voir un aper√ßu interactif.</div>';
                if (meta) meta.textContent = 'Aucun aper√ßu pour le moment.';
                refreshExcelFieldHints();
                return;
            }

            const previewLimit = Math.min(excelPreviewData.length, 10);
            const table = document.createElement('table');
            table.className = 'excel-preview-table';

            const thead = document.createElement('thead');
            const headRow = document.createElement('tr');
            excelPreviewColumnOrder.forEach((columnIndex, orderIndex) => {
                const th = document.createElement('th');
                th.setAttribute('draggable', 'true');
                th.dataset.orderIndex = orderIndex;
                const sampleValue = (excelPreviewData[0]?.[columnIndex] || '').slice(0, 25);
                th.innerHTML = `<span class="drag-handle">‚†ø</span>Col ${columnIndex + 1}${sampleValue ? `<div style="font-size:11px;color:#666;">${sampleValue}</div>` : ''}`;
                th.addEventListener('dragstart', handlePreviewDragStart);
                th.addEventListener('dragover', handlePreviewDragOver);
                th.addEventListener('drop', handlePreviewDrop);
                th.addEventListener('dragend', handlePreviewDragEnd);
                headRow.appendChild(th);
            });
            thead.appendChild(headRow);
            table.appendChild(thead);

            const tbody = document.createElement('tbody');
            for (let rowIndex = 0; rowIndex < previewLimit; rowIndex++) {
                const row = excelPreviewData[rowIndex] || [];
                const tr = document.createElement('tr');
                excelPreviewColumnOrder.forEach(columnIndex => {
                    const td = document.createElement('td');
                    td.contentEditable = true;
                    td.draggable = true;
                    td.dataset.rowIndex = rowIndex;
                    td.dataset.columnIndex = columnIndex;
                    td.textContent = row[columnIndex] || '';
                    td.addEventListener('dragstart', handleExcelCellDragStart);
                    td.addEventListener('dragover', handleExcelCellDragOver);
                    td.addEventListener('dragleave', handleExcelCellDragLeave);
                    td.addEventListener('drop', handleExcelCellDrop);
                    td.addEventListener('dragend', handleExcelCellDragEnd);
                    td.addEventListener('input', () => {
                        if (!excelPreviewData[rowIndex]) {
                            excelPreviewData[rowIndex] = [];
                        }
                        excelPreviewData[rowIndex][columnIndex] = td.textContent;
                    });
                    tr.appendChild(td);
                });
                tbody.appendChild(tr);
            }
            table.appendChild(tbody);

            container.innerHTML = '';
            container.appendChild(table);

            if (meta) {
                meta.textContent = `Pr√©visualisation de ${excelPreviewData.length} ligne(s) ‚Äì affichage des ${previewLimit} premi√®res. Faites glisser les ent√™tes pour modifier l'ordre.`;
            }

            refreshExcelFieldHints();
            renderExcelMappingWorkbench();
        }

        function handleExcelCellDragStart(event) {
            const cell = event.currentTarget;
            excelCellDragSource = {
                row: Number(cell.dataset.rowIndex),
                column: Number(cell.dataset.columnIndex)
            };
            event.dataTransfer.effectAllowed = 'move';
            event.dataTransfer.setData('text/plain', 'excel-cell');
            cell.classList.add('dragging');
        }

        function handleExcelCellDragOver(event) {
            event.preventDefault();
            event.currentTarget.classList.add('dragover');
        }

        function handleExcelCellDragLeave(event) {
            event.currentTarget.classList.remove('dragover');
        }

        function handleExcelCellDrop(event) {
            event.preventDefault();
            const targetCell = event.currentTarget;
            targetCell.classList.remove('dragover');
            if (!excelCellDragSource) return;
            const targetRow = Number(targetCell.dataset.rowIndex);
            const targetColumn = Number(targetCell.dataset.columnIndex);
            const sourceRow = excelCellDragSource.row;
            const sourceColumn = excelCellDragSource.column;
            const sourceValue = excelPreviewData[sourceRow]?.[sourceColumn] || '';
            const targetValue = excelPreviewData[targetRow]?.[targetColumn] || '';
            if (excelPreviewData[sourceRow]) {
                excelPreviewData[sourceRow][sourceColumn] = targetValue;
            }
            if (excelPreviewData[targetRow]) {
                excelPreviewData[targetRow][targetColumn] = sourceValue;
            }
            const sourceCell = document.querySelector(`.excel-preview-table td[data-row-index="${sourceRow}"][data-column-index="${sourceColumn}"]`);
            if (sourceCell && sourceCell !== targetCell) {
                sourceCell.textContent = targetValue;
            }
            targetCell.textContent = sourceValue;
            excelCellDragSource = null;
        }

        function handleExcelCellDragEnd(event) {
            event.currentTarget.classList.remove('dragging');
            excelCellDragSource = null;
        }

        function initializeExcelFieldAssignments(force = false) {
            const targetTab = document.getElementById('taskTargetTab').value || null;
            const columns = tabConfigs[targetTab]?.columns || [];
            const hasData = excelPreviewData.length > 0;

            if (!targetTab || !hasData || !columns.length) {
                excelFieldAssignments = [];
                excelAssignmentsTab = targetTab;
                return;
            }

            if (!force && excelAssignmentsTab === targetTab && excelFieldAssignments.length === columns.length) {
                return;
            }

            const totalColumns = excelPreviewData.reduce((max, row) => Math.max(max, row.length), 0);
            const fallbackOrder = excelPreviewColumnOrder.length
                ? [...excelPreviewColumnOrder]
                : Array.from({ length: totalColumns }, (_, index) => index);

            excelFieldAssignments = columns.map((_, index) => {
                if (index < totalColumns) {
                    return typeof fallbackOrder[index] === 'number' ? fallbackOrder[index] : index;
                }
                return null;
            });
            excelAssignmentsTab = targetTab;
        }

        function renderExcelMappingWorkbench() {
            const container = document.getElementById('excelMappingWorkbench');
            if (!container) return;

            const targetTab = document.getElementById('taskTargetTab').value;
            if (!targetTab || !excelPreviewData.length) {
                container.innerHTML = '<div class="excel-mapping-empty">Collez vos donn√©es et choisissez un onglet pour organiser vos colonnes.</div>';
                return;
            }

            const columns = tabConfigs[targetTab]?.columns || [];
            if (!columns.length) {
                container.innerHTML = '<div class="excel-mapping-empty">Aucun champ disponible pour cet onglet.</div>';
                return;
            }

            initializeExcelFieldAssignments();

            const totalColumns = excelPreviewData.reduce((max, row) => Math.max(max, row.length), 0);
            if (!totalColumns) {
                container.innerHTML = '<div class="excel-mapping-empty">Aucune colonne d√©tect√©e dans l\'aper√ßu.</div>';
                return;
            }
            const assignments = new Map();
            excelFieldAssignments.forEach((columnIndex, fieldIndex) => {
                if (typeof columnIndex === 'number') {
                    assignments.set(columnIndex, fieldIndex);
                }
            });

            const wrapper = document.createElement('div');
            wrapper.innerHTML = '';
            wrapper.className = 'excel-mapping-grid';

            const targetsColumn = document.createElement('div');
            targetsColumn.className = 'excel-mapping-column';
            targetsColumn.innerHTML = '<h5>üìã Champs de l\'onglet</h5>';

            const dropZoneList = document.createElement('div');
            dropZoneList.className = 'excel-drop-zones';

            columns.forEach((column, index) => {
                const dropZone = document.createElement('div');
                dropZone.className = 'excel-drop-field';
                dropZone.dataset.fieldIndex = index;
                dropZone.addEventListener('dragover', handleExcelFieldDragOver);
                dropZone.addEventListener('drop', handleExcelFieldDrop);
                dropZone.addEventListener('dragleave', handleExcelFieldDragLeave);

                const label = document.createElement('span');
                label.textContent = column;
                dropZone.appendChild(label);

                const assignedColumn = excelFieldAssignments[index];
                if (typeof assignedColumn === 'number') {
                    dropZone.classList.add('filled');
                    dropZone.appendChild(buildExcelColumnCard(assignedColumn, { showAssignment: false }));
                } else {
                    const hint = document.createElement('small');
                    hint.textContent = 'D√©posez une colonne ici';
                    hint.style.color = '#7a7f9c';
                    dropZone.appendChild(hint);
                }

                dropZoneList.appendChild(dropZone);
            });

            targetsColumn.appendChild(dropZoneList);

            const sourcesColumn = document.createElement('div');
            sourcesColumn.className = 'excel-mapping-column';
            sourcesColumn.innerHTML = '<h5>‚û°Ô∏è Colonnes import√©es</h5>';

            const pool = document.createElement('div');
            pool.className = 'excel-column-pool';
            pool.addEventListener('dragover', handleExcelPoolDragOver);
            pool.addEventListener('drop', handleExcelPoolDrop);
            pool.addEventListener('dragleave', handleExcelPoolDragLeave);

            for (let columnIndex = 0; columnIndex < totalColumns; columnIndex++) {
                const assignedFieldIndex = assignments.get(columnIndex);
                const assignmentLabel = typeof assignedFieldIndex === 'number'
                    ? columns[assignedFieldIndex] || ''
                    : null;
                pool.appendChild(buildExcelColumnCard(columnIndex, {
                    assignmentLabel
                }));
            }

            sourcesColumn.appendChild(pool);

            const unassignZone = document.createElement('div');
            unassignZone.className = 'excel-unassign-zone';
            unassignZone.textContent = 'D√©posez une carte ici pour lib√©rer la colonne';
            unassignZone.addEventListener('dragover', handleExcelPoolDragOver);
            unassignZone.addEventListener('drop', handleExcelUnassignDrop);
            unassignZone.addEventListener('dragleave', handleExcelPoolDragLeave);
            sourcesColumn.appendChild(unassignZone);

            wrapper.appendChild(targetsColumn);
            wrapper.appendChild(sourcesColumn);

            container.innerHTML = '';
            const title = document.createElement('div');
            title.className = 'excel-mapping-title';
            title.innerHTML = 'üéØ Faites glisser chaque colonne import√©e vers le champ correspondant. D√©posez dans la zone rouge pour lib√©rer une colonne.';
            container.appendChild(title);
            container.appendChild(wrapper);
        }

        function buildExcelColumnCard(columnIndex, options = {}) {
            const { assignmentLabel = null, showAssignment = true } = options;
            const card = document.createElement('div');
            card.className = 'excel-column-card';
            card.draggable = true;
            card.dataset.columnIndex = columnIndex;
            card.addEventListener('dragstart', handleExcelColumnDragStart);
            card.addEventListener('dragend', handleExcelColumnDragEnd);

            const title = document.createElement('strong');
            title.textContent = `Colonne ${columnIndex + 1}`;
            card.appendChild(title);

            const sample = document.createElement('small');
            sample.textContent = getExcelColumnSample(columnIndex) || 'Valeur vide';
            card.appendChild(sample);

            if (showAssignment && assignmentLabel) {
                const badge = document.createElement('small');
                badge.textContent = `Affect√©e √† ${assignmentLabel}`;
                badge.style.color = '#2e7d32';
                card.appendChild(badge);
            }

            return card;
        }

        function getExcelColumnSample(columnIndex) {
            const sampleRow = excelPreviewData.find(row => (row[columnIndex] || '').trim() !== '');
            const rawValue = sampleRow ? sampleRow[columnIndex] : (excelPreviewData[0]?.[columnIndex] || '');
            if (!rawValue) return '';
            return rawValue.length > 40 ? `${rawValue.slice(0, 37)}‚Ä¶` : rawValue;
        }

        function assignExcelColumnToField(columnIndex, fieldIndex) {
            if (typeof columnIndex !== 'number' || typeof fieldIndex !== 'number') return;
            excelFieldAssignments = excelFieldAssignments.map((current, idx) => {
                if (idx === fieldIndex) return current;
                return current === columnIndex ? null : current;
            });
            excelFieldAssignments[fieldIndex] = columnIndex;
            renderExcelMappingWorkbench();
            refreshExcelFieldHints();
        }

        function unassignExcelColumn(columnIndex) {
            let updated = false;
            excelFieldAssignments = excelFieldAssignments.map(value => {
                if (value === columnIndex) {
                    updated = true;
                    return null;
                }
                return value;
            });
            if (updated) {
                renderExcelMappingWorkbench();
                refreshExcelFieldHints();
            }
        }

        function handleExcelColumnDragStart(event) {
            const columnIndex = Number(event.currentTarget.dataset.columnIndex);
            excelDraggedColumnIndex = Number.isNaN(columnIndex) ? null : columnIndex;
            event.dataTransfer.effectAllowed = 'move';
            event.dataTransfer.setData('text/plain', `${columnIndex}`);
            event.currentTarget.classList.add('dragging');
        }

        function handleExcelColumnDragEnd(event) {
            event.currentTarget.classList.remove('dragging');
            excelDraggedColumnIndex = null;
        }

        function handleExcelFieldDragOver(event) {
            event.preventDefault();
            event.currentTarget.classList.add('drag-over');
        }

        function handleExcelFieldDragLeave(event) {
            event.currentTarget.classList.remove('drag-over');
        }

        function handleExcelFieldDrop(event) {
            event.preventDefault();
            event.currentTarget.classList.remove('drag-over');
            const fieldIndex = Number(event.currentTarget.dataset.fieldIndex);
            const columnIndex = getDraggedExcelColumnIndex(event);
            if (Number.isNaN(fieldIndex) || columnIndex === null) {
                return;
            }
            assignExcelColumnToField(columnIndex, fieldIndex);
        }

        function handleExcelPoolDragOver(event) {
            event.preventDefault();
            event.currentTarget.classList.add('drag-over');
        }

        function handleExcelPoolDragLeave(event) {
            event.currentTarget.classList.remove('drag-over');
        }

        function handleExcelPoolDrop(event) {
            event.preventDefault();
            event.currentTarget.classList.remove('drag-over');
        }

        function handleExcelUnassignDrop(event) {
            event.preventDefault();
            event.currentTarget.classList.remove('drag-over');
            const columnIndex = getDraggedExcelColumnIndex(event);
            if (columnIndex === null) return;
            unassignExcelColumn(columnIndex);
        }

        function getDraggedExcelColumnIndex(event) {
            const data = event.dataTransfer?.getData('text/plain');
            if (data && !Number.isNaN(Number(data))) {
                return Number(data);
            }
            return excelDraggedColumnIndex;
        }

        function handlePreviewDragStart(event) {
            excelPreviewDragIndex = Number(event.currentTarget.dataset.orderIndex);
            event.dataTransfer.effectAllowed = 'move';
            event.currentTarget.classList.add('dragging');
        }

        function handlePreviewDragOver(event) {
            event.preventDefault();
            event.dataTransfer.dropEffect = 'move';
        }

        function handlePreviewDrop(event) {
            event.preventDefault();
            const targetOrder = Number(event.currentTarget.dataset.orderIndex);
            if (excelPreviewDragIndex === null || excelPreviewDragIndex === targetOrder) {
                return;
            }
            const [moved] = excelPreviewColumnOrder.splice(excelPreviewDragIndex, 1);
            excelPreviewColumnOrder.splice(targetOrder, 0, moved);
            excelPreviewDragIndex = null;
            renderExcelPreview();
            updateExcelImportButtons();
            updateTasksStats();
        }

        function handlePreviewDragEnd(event) {
            event.currentTarget.classList.remove('dragging');
            excelPreviewDragIndex = null;
        }

        function resetExcelImportArea() {
            const textarea = document.getElementById('excelPasteArea');
            if (textarea) textarea.value = '';
            excelPreviewData = [];
            excelPreviewColumnOrder = [];
            excelPreviewDragIndex = null;
            excelFieldAssignments = [];
            excelAssignmentsTab = null;
            renderExcelPreview();
            updateExcelImportButtons();
            renderExcelMappingWorkbench();
            showNotification('‚ôªÔ∏è Import Excel r√©initialis√©', 'info');
        }

        function refreshExcelFieldHints() {
            const container = document.getElementById('excelFieldHints');
            if (!container) return;

            const targetTab = document.getElementById('taskTargetTab').value;
            if (!targetTab) {
                container.innerHTML = '<div class="excel-preview-empty" style="padding: 8px;">S√©lectionnez un onglet pour voir l\'ordre attendu des colonnes.</div>';
                return;
            }

            const columns = tabConfigs[targetTab]?.columns || [];
            if (!columns.length) {
                container.innerHTML = '<div class="excel-preview-empty" style="padding: 8px;">Aucun champ disponible pour cet onglet.</div>';
                return;
            }

            if (excelPreviewData.length) {
                initializeExcelFieldAssignments();
            } else {
                excelFieldAssignments = [];
            }

            container.innerHTML = '';
            columns.forEach((column, index) => {
                const chip = document.createElement('div');
                chip.className = 'mapping-chip';
                const mappedIndex = typeof excelFieldAssignments[index] === 'number'
                    ? excelFieldAssignments[index]
                    : excelPreviewColumnOrder[index];
                const label = typeof mappedIndex === 'number'
                    ? `Colonne ${mappedIndex + 1}`
                    : 'Non d√©fini';
                chip.innerHTML = `<span>${column}</span>${label}`;
                container.appendChild(chip);
            });
        }

        function updateExcelImportButtons() {
            const importBtn = document.getElementById('excelImportBtn');
            const batchBtn = document.getElementById('excelBatchImportBtn');
            const targetTab = document.getElementById('taskTargetTab').value;
            const hasData = excelPreviewData.length > 0 && Boolean(targetTab);
            if (importBtn) {
                importBtn.disabled = !hasData;
            }
            if (batchBtn) {
                batchBtn.disabled = !(hasData && Boolean(getActiveBatch()));
            }
        }

        function createTasksFromExcelImport() {
            try {
                const targetTab = document.getElementById('taskTargetTab').value;
                if (!targetTab) {
                    showNotification('Choisissez d\'abord un onglet de destination.', 'warning');
                    return;
                }
                if (!excelPreviewData.length) {
                    showNotification('Pr√©visualisez vos donn√©es avant de lancer l\'import.', 'info');
                    return;
                }

                const columns = tabConfigs[targetTab]?.columns || [];
                if (!columns.length) {
                    showNotification('Impossible de r√©cup√©rer les colonnes de destination.', 'error');
                    return;
                }

                const skipHeader = document.getElementById('excelSkipHeader')?.checked;
                const rows = skipHeader ? excelPreviewData.slice(1) : [...excelPreviewData];
                const cleanRows = rows.filter(row => row.some(cell => (cell || '').trim() !== ''));

                if (!cleanRows.length) {
                    showNotification('Aucune ligne exploitable √† importer.', 'warning');
                    return;
                }

                const columnMap = columns.map((_, index) => {
                    if (typeof excelFieldAssignments[index] === 'number') {
                        return excelFieldAssignments[index];
                    }
                    if (typeof excelPreviewColumnOrder[index] === 'number') {
                        return excelPreviewColumnOrder[index];
                    }
                    return index;
                });

                cleanRows.forEach(row => {
                    const taskData = {};
                    columns.forEach((column, columnIndex) => {
                        const sourceIndex = columnMap[columnIndex];
                        taskData[column] = typeof sourceIndex === 'number' ? (row[sourceIndex] ?? '') : '';
                    });

                    pendingTasks.push({
                        id: generateUniqueId(),
                        targetTab,
                        targetTabName: getTabDisplayName(targetTab),
                        data: taskData,
                        createdAt: new Date(),
                        priority: 'Normale',
                        summary: generateTaskSummary(taskData)
                    });
                });

                updatePendingTasksDisplay();
                updateTasksStats();
                saveAllData();

                showNotification(`üì• ${cleanRows.length} t√¢che(s) ajout√©e(s) depuis l'import Excel`);
                logActivity(`${cleanRows.length} t√¢che(s) import√©e(s) pour ${getTabDisplayName(targetTab)}`, 'success');
            } catch (error) {
                console.error('Erreur cr√©ation t√¢ches import√©es:', error);
                showNotification('‚ùå Erreur lors de l\'import des t√¢ches', 'error');
            }
        }

        function addImportToBatch() {
            try {
                const targetTab = document.getElementById('taskTargetTab').value;
                const activeBatch = getActiveBatch();
                if (!targetTab || !activeBatch) {
                    showNotification('S√©lectionnez un onglet et un lot actif avant d\'ajouter l\'import.', 'warning');
                    return;
                }
                if (!excelPreviewData.length) {
                    showNotification('Pr√©visualisez vos donn√©es avant d\'alimenter le lot.', 'info');
                    return;
                }
                const columns = tabConfigs[targetTab]?.columns || [];
                if (!columns.length) {
                    showNotification('Impossible de r√©cup√©rer les colonnes de destination.', 'error');
                    return;
                }
                const skipHeader = document.getElementById('excelSkipHeader')?.checked;
                const rows = skipHeader ? excelPreviewData.slice(1) : [...excelPreviewData];
                const cleanRows = rows.filter(row => row.some(cell => (cell || '').trim() !== ''));
                if (!cleanRows.length) {
                    showNotification('Aucune ligne exploitable √† ajouter dans le lot.', 'warning');
                    return;
                }
                const columnMap = columns.map((_, index) => {
                    if (typeof excelFieldAssignments[index] === 'number') {
                        return excelFieldAssignments[index];
                    }
                    if (typeof excelPreviewColumnOrder[index] === 'number') {
                        return excelPreviewColumnOrder[index];
                    }
                    return index;
                });
                cleanRows.forEach(row => {
                    const taskData = {};
                    columns.forEach((column, columnIndex) => {
                        const sourceIndex = columnMap[columnIndex];
                        taskData[column] = typeof sourceIndex === 'number' ? (row[sourceIndex] ?? '') : '';
                    });
                    activeBatch.tasks.push({
                        id: generateUniqueId(),
                        targetTab,
                        targetTabName: getTabDisplayName(targetTab),
                        data: taskData,
                        createdAt: new Date(),
                        priority: 'Normale',
                        summary: generateTaskSummary(taskData)
                    });
                });
                taskDrafts = activeBatch.tasks;
                updateTaskBatchDisplay();
                updateBatchSelectors();
                updateTasksStats();
                saveAllData();
                showNotification(`üì¶ ${cleanRows.length} t√¢che(s) ajout√©e(s) au lot ${activeBatch.name}`);
                logActivity(`${cleanRows.length} t√¢ches import√©es vers le lot ${activeBatch.name}`, 'info');
            } catch (error) {
                console.error('Erreur ajout import au lot:', error);
                showNotification('‚ùå Erreur lors de l\'ajout de l\'import au lot', 'error');
            }
        }

        function getTaskQuantity() {
            const qtyInput = document.getElementById('taskQuantity');
            const parsed = parseInt(qtyInput?.value || '1', 10);
            const safeValue = Math.min(Math.max(parsed || 1, 1), 50);
            if (qtyInput) {
                qtyInput.value = safeValue;
            }
            return safeValue;
        }

        function transferTask() {
            try {
                const targetTab = document.getElementById('taskTargetTab').value;
                if (!targetTab) return;

                const columns = tabConfigs[targetTab]?.columns || [];
                const taskData = [];
                const quantity = getTaskQuantity();

                columns.forEach((column, index) => {
                    const input = document.getElementById(`taskField_${index}`);
                    taskData.push(input ? input.value : '');
                });

                const fragment = document.createDocumentFragment();
                for (let i = 0; i < quantity; i++) {
                    addRowWithData(targetTab, taskData, {
                        fragment,
                        skipStats: true,
                        skipLog: true,
                        skipFocus: true,
                        skipValidation: true
                    });
                }

                const tbody = document.getElementById(`${targetTab}TableBody`);
                if (tbody) {
                    tbody.appendChild(fragment);
                }

                updateStats(targetTab);
                saveAllData();

                clearTaskForm();

                showNotification(`‚úÖ ${quantity} t√¢che(s) transf√©r√©e(s) vers ${getTabDisplayName(targetTab)}`);
                logActivity(`${quantity} t√¢che(s) transf√©r√©e(s) vers ${getTabDisplayName(targetTab)}`, 'success');

            } catch (error) {
                console.error('Erreur transfert t√¢che:', error);
                showNotification('‚ùå Erreur lors du transfert de t√¢che', 'error');
            }
        }

        function saveTaskAsPending() {
            try {
                const targetTab = document.getElementById('taskTargetTab').value;
                if (!targetTab) return;

                const columns = tabConfigs[targetTab]?.columns || [];
                const taskData = {};
                const quantity = getTaskQuantity();

                columns.forEach((column, index) => {
                    const input = document.getElementById(`taskField_${index}`);
                    taskData[column] = input ? input.value : '';
                });

                for (let i = 0; i < quantity; i++) {
                    const task = {
                        id: generateUniqueId(),
                        targetTab: targetTab,
                        targetTabName: getTabDisplayName(targetTab),
                        data: { ...taskData },
                        createdAt: new Date(),
                        priority: 'Normale',
                        summary: generateTaskSummary(taskData)
                    };
                    pendingTasks.push(task);
                }
                updatePendingTasksDisplay();
                updateTasksStats();
                saveAllData();

                clearTaskForm();

                showNotification(`‚è≥ ${quantity} t√¢che(s) mise(s) en attente`);
                logActivity(`${quantity} t√¢che(s) mise(s) en attente pour ${getTabDisplayName(targetTab)}`, 'info');
                
            } catch (error) {
                console.error('Erreur sauvegarde t√¢che en attente:', error);
                showNotification('‚ùå Erreur lors de la sauvegarde de t√¢che', 'error');
            }
        }

        function getActiveBatch() {
            return taskBatches.find(batch => batch.id === activeBatchId) || null;
        }

        function createTaskBatch() {
            try {
                const nameInput = document.getElementById('batchNameInput');
                const batchName = (nameInput?.value || '').trim() || `Lot ${taskBatches.length + 1}`;

                const newBatch = {
                    id: generateUniqueId(),
                    name: batchName,
                    tasks: [],
                    createdAt: new Date()
                };

                taskBatches.push(newBatch);
                activeBatchId = newBatch.id;
                taskDrafts = newBatch.tasks;

                updateBatchSelectors();
                updateTaskBatchDisplay();
                saveAllData();
                updateTasksStats();
                updateExcelImportButtons();

                if (nameInput) nameInput.value = '';

                showNotification(`üì¶ Lot "${batchName}" cr√©√©`);
                logActivity(`Nouveau lot de t√¢ches cr√©√© (${batchName})`, 'success');
            } catch (error) {
                console.error('Erreur cr√©ation lot:', error);
                showNotification('‚ùå Erreur lors de la cr√©ation du lot', 'error');
            }
        }

        function selectTaskBatch(batchId) {
            activeBatchId = batchId || null;
            const activeBatch = getActiveBatch();
            taskDrafts = activeBatch ? activeBatch.tasks : [];
            updateTaskBatchDisplay();
            updateTaskFields();
            saveAllData();
            updateTasksStats();
            updateExcelImportButtons();
        }

        function updateBatchSelectors() {
            const selector = document.getElementById('batchSelector');
            if (!selector) return;

            selector.innerHTML = '<option value="">S√©lectionner un lot...</option>';

            taskBatches.forEach(batch => {
                const option = document.createElement('option');
                option.value = batch.id;
                option.textContent = `${batch.name} (${batch.tasks.length} t√¢che(s))`;
                if (batch.id === activeBatchId) {
                    option.selected = true;
                }
                selector.appendChild(option);
            });

            const createBtn = document.getElementById('createBatchTasksBtn');
            if (createBtn) {
                createBtn.disabled = !getActiveBatch() || getActiveBatch().tasks.length === 0;
            }

            const batchBtn = document.getElementById('batchTaskBtn');
            if (batchBtn) {
                const targetTab = document.getElementById('taskTargetTab').value;
                batchBtn.disabled = !targetTab || !getActiveBatch();
            }

            const label = document.getElementById('activeBatchLabel');
            if (label) {
                if (!getActiveBatch()) {
                    label.textContent = 'Aucun lot s√©lectionn√©';
                } else {
                    const batch = getActiveBatch();
                    label.textContent = `Lot actif : ${batch.name} (${batch.tasks.length} t√¢che(s))`;
                }
            }

            updateExcelImportButtons();
        }

        function deleteActiveBatch() {
            try {
                const batch = getActiveBatch();
                if (!batch) {
                    showNotification('‚ÑπÔ∏è Aucun lot √† supprimer', 'info');
                    return;
                }

                if (!confirm(`Supprimer le lot "${batch.name}" et ses t√¢ches ?`)) return;

                taskBatches = taskBatches.filter(b => b.id !== batch.id);
                activeBatchId = taskBatches[0]?.id || null;
                taskDrafts = getActiveBatch() ? getActiveBatch().tasks : [];

                updateBatchSelectors();
                updateTaskBatchDisplay();
                saveAllData();
                updateTasksStats();
                updateExcelImportButtons();

                showNotification('üóëÔ∏è Lot supprim√©');
                logActivity(`Lot supprim√© (${batch.name})`, 'warning');
            } catch (error) {
                console.error('Erreur suppression lot:', error);
                showNotification('‚ùå Erreur lors de la suppression du lot', 'error');
            }
        }

        function addTaskToBatch() {
            try {
                const targetTab = document.getElementById('taskTargetTab').value;
                if (!targetTab) return;

                const activeBatch = getActiveBatch();
                if (!activeBatch) {
                    showNotification('‚ö†Ô∏è Cr√©ez ou s√©lectionnez un lot avant d\'ajouter des t√¢ches', 'warning');
                    return;
                }

                const columns = tabConfigs[targetTab]?.columns || [];
                const taskData = {};
                const quantity = getTaskQuantity();

                columns.forEach((column, index) => {
                    const input = document.getElementById(`taskField_${index}`);
                    taskData[column] = input ? input.value : '';
                });

                for (let i = 0; i < quantity; i++) {
                    const task = {
                        id: generateUniqueId(),
                        targetTab,
                        targetTabName: getTabDisplayName(targetTab),
                        data: { ...taskData },
                        createdAt: new Date(),
                        priority: 'Normale',
                        summary: generateTaskSummary(taskData)
                    };
                    activeBatch.tasks.push(task);
                }
                taskDrafts = activeBatch.tasks;
                updateTaskBatchDisplay();
                saveAllData();
                updateTasksStats();
                updateExcelImportButtons();

                clearTaskForm();

                showNotification(`‚ûï ${quantity} t√¢che(s) ajout√©e(s) au lot de cr√©ation`);
                logActivity(`${quantity} t√¢che(s) ajout√©e(s) au lot (${getTabDisplayName(targetTab)})`, 'info');

            } catch (error) {
                console.error('Erreur ajout t√¢che au lot:', error);
                showNotification('‚ùå Erreur lors de l\'ajout au lot', 'error');
            }
        }

        function clearTaskForm() {
            try {
                document.getElementById('taskTargetTab').value = '';
                const qtyInput = document.getElementById('taskQuantity');
                if (qtyInput) qtyInput.value = 1;
                updateTaskFields();
            } catch (error) {
                console.error('Erreur effacement formulaire t√¢che:', error);
            }
        }

        function generateTaskSummary(taskData) {
            const importantFields = ['GA', 'RG', 'Code RG', 'Num√©ro de Bail', 'UT-BAT'];
            const summary = [];
            
            importantFields.forEach(field => {
                if (taskData[field]) {
                    summary.push(`${field}: ${taskData[field]}`);
                }
            });
            
            return summary.join(' | ') || 'T√¢che sans d√©tails sp√©cifiques';
        }

        function updatePendingTasksDisplay() {
            try {
                const tbody = document.getElementById('tachesTableBody');
                if (!tbody) return;
                
                tbody.innerHTML = '';
                
                if (pendingTasks.length === 0) {
                    tbody.innerHTML = `
                        <tr>
                            <td colspan="6" style="text-align: center; padding: 40px; color: #666;">
                                üìù Aucune t√¢che en attente. Cr√©ez une nouvelle t√¢che ci-dessus !
                            </td>
                        </tr>
                    `;
                    return;
                }
                
                pendingTasks.forEach((task, index) => {
                    const row = document.createElement('tr');
                    
                    const createdDate = task.createdAt.toLocaleDateString('fr-FR');
                    
                    row.innerHTML = `
                        <td class="row-number">${index + 1}</td>
                        <td>${getTabIcon(task.targetTab)} ${task.targetTabName}</td>
                        <td style="font-size: 13px;">${task.summary}</td>
                        <td>${createdDate}</td>
                        <td><span style="color: #667eea;">${task.priority}</span></td>
                        <td>
                            <button class="btn btn-success" style="padding: 4px 8px; font-size: 11px; margin-right: 5px;" 
                                    onclick="executeTask('${task.id}')">
                                üöÄ Ex√©cuter
                            </button>
                            <button class="btn btn-warning" style="padding: 4px 8px; font-size: 11px; margin-right: 5px;" 
                                    onclick="editTask('${task.id}')">
                                ‚úèÔ∏è Modifier
                            </button>
                            <button class="btn btn-danger" style="padding: 4px 8px; font-size: 11px;" 
                                    onclick="deleteTask('${task.id}')">
                                üóëÔ∏è
                            </button>
                        </td>
                    `;
                    
                    tbody.appendChild(row);
                });
                
            } catch (error) {
                console.error('Erreur mise √† jour affichage t√¢ches:', error);
            }
        }

        function updateTaskBatchDisplay() {
            try {
                const tbody = document.getElementById('taskBatchTableBody');
                const createBtn = document.getElementById('createBatchTasksBtn');
                if (!tbody || !createBtn) return;

                tbody.innerHTML = '';

                const activeBatch = getActiveBatch();

                if (!activeBatch) {
                    tbody.innerHTML = `
                        <tr>
                            <td colspan="5" style="text-align: center; padding: 30px; color: #666;">‚ûï Cr√©ez ou s√©lectionnez un lot pour commencer.</td>
                        </tr>
                    `;
                    createBtn.disabled = true;
                    updateBatchSelectors();
                    return;
                }

                if (activeBatch.tasks.length === 0) {
                    tbody.innerHTML = `
                        <tr>
                            <td colspan="5" style="text-align: center; padding: 30px; color: #666;">‚ûï Ajoutez des t√¢ches pour constituer un lot.</td>
                        </tr>
                    `;
                    createBtn.disabled = true;
                    updateBatchSelectors();
                    return;
                }

                activeBatch.tasks.forEach((task, index) => {
                    const row = document.createElement('tr');
                    const createdDate = task.createdAt.toLocaleDateString('fr-FR');

                    row.innerHTML = `
                        <td class="row-number">${index + 1}</td>
                        <td>${getTabIcon(task.targetTab)} ${task.targetTabName}</td>
                        <td style="font-size: 13px;">${task.summary}</td>
                        <td>${createdDate}</td>
                        <td>
                            <button class="btn btn-success" style="padding: 4px 8px; font-size: 11px; margin-right: 4px;" onclick="createTaskFromBatch('${task.id}')">üöÄ Cr√©er</button>
                            <button class="btn btn-warning" style="padding: 4px 8px; font-size: 11px; margin-right: 4px;" onclick="editBatchTask('${task.id}')">‚úèÔ∏è Modifier</button>
                            <button class="btn btn-danger" style="padding: 4px 8px; font-size: 11px;" onclick="deleteTaskDraft('${task.id}')">üóëÔ∏è Supprimer</button>
                        </td>
                    `;

                    tbody.appendChild(row);
                });

                createBtn.disabled = false;
                updateBatchSelectors();
            } catch (error) {
                console.error('Erreur mise √† jour lot t√¢ches:', error);
            }
        }

        function deleteTaskDraft(taskId) {
            try {
                const activeBatch = getActiveBatch();
                if (!activeBatch) return;

                activeBatch.tasks = activeBatch.tasks.filter(task => task.id !== taskId);
                taskDrafts = activeBatch.tasks;
                updateTaskBatchDisplay();
                saveAllData();
                updateTasksStats();
                updateExcelImportButtons();
            } catch (error) {
                console.error('Erreur suppression t√¢che du lot:', error);
                showNotification('‚ùå Erreur lors de la suppression du lot', 'error');
            }
        }

        function editBatchTask(taskId) {
            try {
                const activeBatch = getActiveBatch();
                if (!activeBatch) {
                    showNotification('‚ÑπÔ∏è S√©lectionnez un lot avant de modifier une t√¢che', 'info');
                    return;
                }

                const task = activeBatch.tasks.find(t => t.id === taskId);
                if (!task) return;

                document.getElementById('taskTargetTab').value = task.targetTab;
                updateTaskFields();

                setTimeout(() => {
                    const columns = tabConfigs[task.targetTab]?.columns || [];
                    columns.forEach((column, index) => {
                        const input = document.getElementById(`taskField_${index}`);
                        if (input && task.data[column]) {
                            input.value = task.data[column];
                        }
                    });
                }, 80);

                activeBatch.tasks = activeBatch.tasks.filter(t => t.id !== taskId);
                taskDrafts = activeBatch.tasks;
                updateTaskBatchDisplay();
                saveAllData();
                updateTasksStats();
                updateExcelImportButtons();

                showNotification('‚úèÔ∏è T√¢che du lot charg√©e pour modification');
            } catch (error) {
                console.error('Erreur modification t√¢che du lot:', error);
                showNotification('‚ùå Erreur lors de la modification de la t√¢che du lot', 'error');
            }
        }

        function createTaskFromBatch(taskId) {
            try {
                const activeBatch = getActiveBatch();
                if (!activeBatch) {
                    showNotification('‚ÑπÔ∏è S√©lectionnez un lot avant de cr√©er la t√¢che', 'info');
                    return;
                }

                const task = activeBatch.tasks.find(t => t.id === taskId);
                if (!task) return;

                const columns = tabConfigs[task.targetTab]?.columns || [];
                const taskDataArray = columns.map(column => task.data[column] || '');

                addRowWithData(task.targetTab, taskDataArray);
                updateStats(task.targetTab);

                completedTasks.push({
                    ...task,
                    completedAt: new Date(),
                    status: 'completed_from_batch',
                    sourceBatch: activeBatch.name
                });

                activeBatch.tasks = activeBatch.tasks.filter(t => t.id !== taskId);
                taskDrafts = activeBatch.tasks;

                updateTaskBatchDisplay();
                updateTasksStats();
                saveAllData();

                showNotification(`üöÄ T√¢che cr√©√©e depuis le lot vers ${task.targetTabName}`);
                logActivity(`T√¢che du lot ex√©cut√©e (${task.targetTabName})`, 'success');
            } catch (error) {
                console.error('Erreur cr√©ation t√¢che depuis lot:', error);
                showNotification('‚ùå Erreur lors de la cr√©ation de la t√¢che du lot', 'error');
            }
        }

        function saveBatchAsPending() {
            try {
                const activeBatch = getActiveBatch();
                if (!activeBatch || activeBatch.tasks.length === 0) return;

                const addedCount = activeBatch.tasks.length;

                activeBatch.tasks.forEach(task => {
                    pendingTasks.push({
                        ...task,
                        createdAt: task.createdAt || new Date()
                    });
                });

                activeBatch.tasks = [];
                taskDrafts = activeBatch.tasks;

                updateTaskBatchDisplay();
                updatePendingTasksDisplay();
                updateTasksStats();
                saveAllData();

                showNotification(`‚úÖ ${addedCount} t√¢che(s) ajout√©e(s) en attente`);
                logActivity(`${addedCount} t√¢che(s) ajout√©e(s) depuis le lot`, 'success');

            } catch (error) {
                console.error('Erreur cr√©ation lot de t√¢ches:', error);
                showNotification('‚ùå Erreur lors de la cr√©ation du lot', 'error');
            }
        }

        function updateTasksStats() {
            try {
                const pendingCount = pendingTasks.length;
                const completedCount = completedTasks.length;
                const lotCount = taskBatches.reduce((sum, batch) => sum + (batch.tasks?.length || 0), 0);
                const totalCount = pendingCount + completedCount + lotCount;
                const completionRate = totalCount > 0 ? Math.round((completedCount / totalCount) * 100) : 0;

                document.getElementById('pendingTasksCount').textContent = pendingCount;
                document.getElementById('completedTasksCount').textContent = completedCount;
                document.getElementById('totalTasksCount').textContent = totalCount;
                const lotElement = document.getElementById('lotTasksCount');
                if (lotElement) {
                    lotElement.textContent = lotCount;
                }
                document.getElementById('tasksProgress').style.width = completionRate + '%';

            } catch (error) {
                console.error('Erreur mise √† jour stats t√¢ches:', error);
            }
        }

        function executeTask(taskId) {
            try {
                const task = pendingTasks.find(t => t.id === taskId);
                if (!task) return;
                
                const columns = tabConfigs[task.targetTab]?.columns || [];
                const taskDataArray = columns.map(column => task.data[column] || '');
                
                addRowWithData(task.targetTab, taskDataArray);
                
                // D√©placer vers les t√¢ches compl√©t√©es
                completedTasks.push({
                    ...task,
                    completedAt: new Date(),
                    status: 'completed'
                });
                
                pendingTasks = pendingTasks.filter(t => t.id !== taskId);
                
                updateStats(task.targetTab);
                updatePendingTasksDisplay();
                updateTasksStats();
                saveAllData();
                
                showNotification(`‚úÖ T√¢che ex√©cut√©e vers ${task.targetTabName}`);
                logActivity(`T√¢che ex√©cut√©e vers ${task.targetTabName}`, 'success');
                
            } catch (error) {
                console.error('Erreur ex√©cution t√¢che:', error);
                showNotification('‚ùå Erreur lors de l\'ex√©cution de t√¢che', 'error');
            }
        }

        function editTask(taskId) {
            try {
                const task = pendingTasks.find(t => t.id === taskId);
                if (!task) return;
                
                // Charger la t√¢che dans le formulaire
                document.getElementById('taskTargetTab').value = task.targetTab;
                updateTaskFields();
                
                // Remplir les champs
                setTimeout(() => {
                    const columns = tabConfigs[task.targetTab]?.columns || [];
                    columns.forEach((column, index) => {
                        const input = document.getElementById(`taskField_${index}`);
                        if (input && task.data[column]) {
                            input.value = task.data[column];
                        }
                    });
                }, 100);
                
                // Supprimer l'ancienne t√¢che
                pendingTasks = pendingTasks.filter(t => t.id !== taskId);
                updatePendingTasksDisplay();
                updateTasksStats();
                
                showNotification('‚úèÔ∏è T√¢che charg√©e pour modification');
                
            } catch (error) {
                console.error('Erreur modification t√¢che:', error);
                showNotification('‚ùå Erreur lors de la modification', 'error');
            }
        }

        function deleteTask(taskId) {
            try {
                if (confirm('√ätes-vous s√ªr de vouloir supprimer cette t√¢che ?')) {
                    pendingTasks = pendingTasks.filter(t => t.id !== taskId);
                    updatePendingTasksDisplay();
                    updateTasksStats();
                    saveAllData();
                    showNotification('üóëÔ∏è T√¢che supprim√©e');
                    logActivity('T√¢che supprim√©e', 'warning');
                }
            } catch (error) {
                console.error('Erreur suppression t√¢che:', error);
                showNotification('‚ùå Erreur lors de la suppression de t√¢che', 'error');
            }
        }

        function executeAllPendingTasks() {
            try {
                if (pendingTasks.length === 0) {
                    showNotification('‚ÑπÔ∏è Aucune t√¢che en attente', 'info');
                    return;
                }
                
                if (!confirm(`Ex√©cuter toutes les ${pendingTasks.length} t√¢che(s) en attente ?`)) {
                    return;
                }
                
                let executed = 0;
                const tasksToExecute = [...pendingTasks];
                
                tasksToExecute.forEach(task => {
                    const columns = tabConfigs[task.targetTab]?.columns || [];
                    const taskDataArray = columns.map(column => task.data[column] || '');
                    
                    addRowWithData(task.targetTab, taskDataArray);
                    updateStats(task.targetTab);
                    
                    completedTasks.push({
                        ...task,
                        completedAt: new Date(),
                        status: 'completed'
                    });
                    
                    executed++;
                });
                
                pendingTasks = [];
                updatePendingTasksDisplay();
                updateTasksStats();
                saveAllData();
                
                showNotification(`üöÄ ${executed} t√¢che(s) ex√©cut√©e(s) avec succ√®s`);
                logActivity(`${executed} t√¢ches ex√©cut√©es en lot`, 'success');
                
            } catch (error) {
                console.error('Erreur ex√©cution toutes t√¢ches:', error);
                showNotification('‚ùå Erreur lors de l\'ex√©cution des t√¢ches', 'error');
            }
        }

        function clearAllPendingTasks() {
            try {
                if (pendingTasks.length === 0) {
                    showNotification('‚ÑπÔ∏è Aucune t√¢che √† effacer', 'info');
                    return;
                }
                
                if (!confirm(`Supprimer toutes les ${pendingTasks.length} t√¢che(s) en attente ?`)) {
                    return;
                }
                
                const count = pendingTasks.length;
                pendingTasks = [];
                updatePendingTasksDisplay();
                updateTasksStats();
                saveAllData();
                
                showNotification(`üóëÔ∏è ${count} t√¢che(s) supprim√©e(s)`);
                logActivity(`${count} t√¢ches supprim√©es`, 'warning');
                
            } catch (error) {
                console.error('Erreur suppression toutes t√¢ches:', error);
                showNotification('‚ùå Erreur lors de la suppression', 'error');
            }
        }

        function exportTasksToExcel() {
            try {
                if (pendingTasks.length === 0 && completedTasks.length === 0) {
                    showNotification('‚ùå Aucune t√¢che √† exporter', 'error');
                    return;
                }

                const buildTaskRow = (task, status) => ({
                    Statut: status,
                    Onglet: getTabDisplayName(task.targetTab),
                    R√©sum√©: task.summary,
                    Priorit√©: task.priority || 'Normale',
                    'Cr√©√©e le': task.createdAt ? new Date(task.createdAt).toLocaleDateString('fr-FR') : '',
                    'Compl√©t√©e le': task.completedAt ? new Date(task.completedAt).toLocaleDateString('fr-FR') : '',
                    D√©tails: Object.entries(task.data || {})
                        .filter(([_, value]) => value)
                        .map(([key, value]) => `${key}: ${value}`)
                        .join(' | ')
                });

                const pendingRows = pendingTasks.map(task => buildTaskRow(task, 'En attente'));
                const completedRows = completedTasks.map(task => buildTaskRow(task, 'Compl√©t√©e'));

                const workbook = XLSX.utils.book_new();

                if (pendingRows.length > 0) {
                    const pendingSheet = XLSX.utils.json_to_sheet(pendingRows);
                    XLSX.utils.book_append_sheet(workbook, pendingSheet, 'En attente');
                }

                if (completedRows.length > 0) {
                    const completedSheet = XLSX.utils.json_to_sheet(completedRows);
                    XLSX.utils.book_append_sheet(workbook, completedSheet, 'Compl√©t√©es');
                }

                const fileName = `taches_${new Date().toISOString().split('T')[0]}.xlsx`;
                XLSX.writeFile(workbook, fileName);

                showNotification(`üì§ T√¢ches export√©es: ${fileName}`);
                logActivity('Export des t√¢ches en Excel', 'info');

            } catch (error) {
                console.error('Erreur export des t√¢ches:', error);
                showNotification('‚ùå Erreur lors de l\'export des t√¢ches', 'error');
            }
        }

        function exportActiveBatch() {
            try {
                const activeBatch = getActiveBatch();
                if (!activeBatch) {
                    showNotification('‚ÑπÔ∏è S√©lectionnez un lot √† exporter', 'info');
                    return;
                }

                if (!activeBatch.tasks || activeBatch.tasks.length === 0) {
                    showNotification('‚ùå Ce lot ne contient aucune t√¢che', 'error');
                    return;
                }

                const rows = activeBatch.tasks.map(task => ({
                    "Lot": activeBatch.name,
                    "Onglet": getTabDisplayName(task.targetTab),
                    "R√©sum√©": task.summary,
                    "Priorit√©": task.priority || 'Normale',
                    "Cr√©√©e le": task.createdAt ? new Date(task.createdAt).toLocaleDateString('fr-FR') : '',
                    "D√©tails": Object.entries(task.data || {})
                        .filter(([_, value]) => value)
                        .map(([key, value]) => `${key}: ${value}`)
                        .join(' | ')
                }));

                const wb = XLSX.utils.book_new();
                const ws = XLSX.utils.json_to_sheet(rows);
                XLSX.utils.book_append_sheet(wb, ws, activeBatch.name.substring(0, 31) || 'Lot');
                const fileName = `lot_${activeBatch.name || 'taches'}_${new Date().toISOString().split('T')[0]}.xlsx`;
                XLSX.writeFile(wb, fileName);
                showNotification(`üì§ Lot export√©: ${fileName}`);
            } catch (error) {
                console.error('Erreur export lot de t√¢ches:', error);
                showNotification('‚ùå Erreur lors de l\'export du lot', 'error');
            }
        }

        // üîß FONCTIONS SP√âCIALIS√âES PAR ONGLET
        function copyVerifRowToPNI(row) {
            try {
                const verifColumns = tabConfigs['verifbaux'].columns;
                const pniColumns = tabConfigs['pni'].columns;
                const inputs = row.querySelectorAll('input, textarea, select');

                const mappedData = pniColumns.map(column => {
                    const sourceIndex = verifColumns.indexOf(column);
                    return sourceIndex >= 0 && inputs[sourceIndex]
                        ? inputs[sourceIndex].value
                        : '';
                });

                addRowWithData('pni', mappedData, { skipLog: true });
                updateStats('pni');
                saveAllData();
                showNotification('üìã Ligne copi√©e vers PNI');
            } catch (error) {
                console.error('Erreur lors de la copie vers PNI:', error);
                showNotification('‚ùå Impossible de copier la ligne vers PNI', 'error');
            }
        }

        function validateAllBauxStates() {
            try {
                const tbody = document.getElementById('verifbauxTableBody');
                if (!tbody) return;
                
                const rows = tbody.querySelectorAll('tr');
                let validated = 0;
                let errors = 0;
                
                rows.forEach(row => {
                    const inputs = row.querySelectorAll('input, textarea, select');
                    const etatIndex = tabConfigs['verifbaux'].columns.indexOf('√âtat');
                    const etatInput = inputs[etatIndex];
                    
                    if (etatInput) {
                        const etat = etatInput.value.toUpperCase();
                        if (['OK', 'NOK', 'EN COURS'].includes(etat)) {
                            etatInput.classList.remove('has-error');
                            etatInput.classList.add('has-success');
                            validated++;
                        } else if (etat) {
                            etatInput.classList.add('has-error');
                            errors++;
                        }
                    }
                });
                
                updateStats('verifbaux');
                
                if (errors > 0) {
                    showNotification(`‚ö†Ô∏è ${validated} √©tat(s) valid√©(s), ${errors} erreur(s) d√©tect√©e(s)`, 'warning');
                } else {
                    showNotification(`‚úÖ ${validated} √©tat(s) valid√©(s) avec succ√®s`);
                }
                
            } catch (error) {
                console.error('Erreur validation √©tats baux:', error);
                showNotification('‚ùå Erreur lors de la validation', 'error');
            }
        }

        function markAllAsOK() {
            try {
                const tbody = document.getElementById('verifbauxTableBody');
                if (!tbody) return;
                
                const rows = tbody.querySelectorAll('tr');
                let marked = 0;
                
                rows.forEach(row => {
                    const inputs = row.querySelectorAll('input, textarea, select');
                    const etatIndex = tabConfigs['verifbaux'].columns.indexOf('√âtat');
                    const etatInput = inputs[etatIndex];
                    
                    if (etatInput && !etatInput.value) {
                        etatInput.value = 'OK';
                        etatInput.classList.remove('has-error', 'has-warning');
                        marked++;
                    }
                });
                
                if (marked > 0) {
                    updateStats('verifbaux');
                    saveAllData();
                    showNotification(`‚úÖ ${marked} ligne(s) marqu√©e(s) comme OK`);
                } else {
                    showNotification('‚ÑπÔ∏è Aucune ligne vide √† marquer', 'info');
                }
                
            } catch (error) {
                console.error('Erreur marquage OK:', error);
                showNotification('‚ùå Erreur lors du marquage', 'error');
            }
        }

        function validateAllRGCodes() {
            try {
                if (Object.keys(rgDatabase).length === 0) {
                    showNotification('‚ö†Ô∏è Base RG vide. Importez d\'abord la base RG.', 'warning');
                    return;
                }
                
                let invalidCodes = [];
                let validCodes = 0;
                let checkedTabs = 0;
                
                ['creation', 'modification', 'verifbaux', 'pni'].forEach(tabName => {
                    const tbody = document.getElementById(`${tabName}TableBody`);
                    if (!tbody) return;
                    
                    checkedTabs++;
                    const rows = tbody.querySelectorAll('tr');
                    const columns = tabConfigs[tabName]?.columns || [];
                    const rgIndex = columns.indexOf('RG');
                    
                    if (rgIndex >= 0) {
                        rows.forEach((row, rowIndex) => {
                            const inputs = row.querySelectorAll('input, textarea, select');
                            const rgInput = inputs[rgIndex];
                            
                            if (rgInput && rgInput.value) {
                                if (rgDatabase[rgInput.value]) {
                                    rgInput.classList.remove('has-error');
                                    rgInput.classList.add('has-success');
                                    validCodes++;
                                } else {
                                    rgInput.classList.add('has-error');
                                    invalidCodes.push({
                                        tab: getTabDisplayName(tabName),
                                        row: rowIndex + 1,
                                        code: rgInput.value
                                    });
                                }
                            }
                        });
                    }
                });
                
                if (invalidCodes.length === 0) {
                    showNotification(`‚úÖ Tous les ${validCodes} code(s) RG sont valides`);
                } else {
                    let message = `‚ö†Ô∏è ${invalidCodes.length} code(s) RG invalide(s), ${validCodes} valide(s):\n\n`;
                    invalidCodes.slice(0, 10).forEach(item => {
                        message += `‚Ä¢ ${item.tab} - Ligne ${item.row}: ${item.code}\n`;
                    });
                    if (invalidCodes.length > 10) {
                        message += `\n... et ${invalidCodes.length - 10} autre(s)`;
                    }
                    alert(message);
                }
                
            } catch (error) {
                console.error('Erreur validation codes RG:', error);
                showNotification('‚ùå Erreur lors de la validation des codes RG', 'error');
            }
        }

        // üìä EXPORT EXCEL COMPLET
        function exportToExcel(tabName) {
            try {
                if (!window.XLSX) {
                    showNotification('‚ùå Biblioth√®que Excel non disponible', 'error');
                    return;
                }
                
                const tbody = document.getElementById(`${tabName}TableBody`);
                if (!tbody) return;
                
                const columns = tabConfigs[tabName]?.columns || [];
                const rows = tbody.querySelectorAll('tr');
                
                if (rows.length === 0) {
                    showNotification('‚ùå Aucune donn√©e √† exporter', 'error');
                    return;
                }
                
                const wsData = [columns];
                
                rows.forEach(row => {
                    const inputs = row.querySelectorAll('input, textarea, select');
                    const rowData = [];
                    inputs.forEach(input => {
                        rowData.push(input.value || '');
                    });
                    if (rowData.some(cell => cell.trim() !== '')) {
                        wsData.push(rowData);
                    }
                });
                
                if (wsData.length <= 1) {
                    showNotification('‚ùå Aucune donn√©e valide √† exporter', 'error');
                    return;
                }
                
                const ws = XLSX.utils.aoa_to_sheet(wsData);
                const wb = XLSX.utils.book_new();
                XLSX.utils.book_append_sheet(wb, ws, getTabDisplayName(tabName));
                
                const fileName = `MARTINE_${getTabDisplayName(tabName).replace(/\s+/g, '_')}_${new Date().toISOString().split('T')[0]}.xlsx`;
                XLSX.writeFile(wb, fileName);
                
                showNotification(`üìä Export Excel r√©ussi: ${fileName}`);
                logActivity(`Export Excel de ${getTabDisplayName(tabName)}`, 'success');
                
            } catch (error) {
                console.error('Erreur export Excel:', error);
                showNotification('‚ùå Erreur lors de l\'export Excel', 'error');
            }
        }

        function exportAllToExcel() {
            try {
                if (!window.XLSX) {
                    showNotification('‚ùå Biblioth√®que Excel non disponible', 'error');
                    return;
                }
                
                const wb = XLSX.utils.book_new();
                let hasData = false;
                
                Object.keys(tabConfigs).forEach(tabName => {
                    const tbody = document.getElementById(`${tabName}TableBody`);
                    if (!tbody) return;
                    
                    const columns = tabConfigs[tabName]?.columns || [];
                    const rows = tbody.querySelectorAll('tr');
                    
                    if (rows.length === 0) return;
                    
                    const wsData = [columns];
                    
                    rows.forEach(row => {
                        const inputs = row.querySelectorAll('input, textarea, select');
                        const rowData = [];
                        inputs.forEach(input => {
                            rowData.push(input.value || '');
                        });
                        if (rowData.some(cell => cell.trim() !== '')) {
                            wsData.push(rowData);
                        }
                    });
                    
                    if (wsData.length > 1) {
                        const ws = XLSX.utils.aoa_to_sheet(wsData);
                        const sheetName = getTabDisplayName(tabName).substring(0, 31); // Limite Excel
                        XLSX.utils.book_append_sheet(wb, ws, sheetName);
                        hasData = true;
                    }
                });
                
                if (!hasData) {
                    showNotification('‚ùå Aucune donn√©e √† exporter', 'error');
                    return;
                }
                
                const fileName = `MARTINE_Export_Global_${new Date().toISOString().split('T')[0]}.xlsx`;
                XLSX.writeFile(wb, fileName);
                
                showNotification(`üìä Export global r√©ussi: ${fileName}`);
                logActivity('Export global Excel de tous les onglets', 'success');
                
            } catch (error) {
                console.error('Erreur export global:', error);
                showNotification('‚ùå Erreur lors de l\'export global', 'error');
            }
        }

        function getChartsSnapshot() {
            const snapshots = [];

            const tabsChart = chartInstances.tabsChart;
            if (tabsChart && tabsChart.data?.labels?.length) {
                const dataset = tabsChart.data.datasets?.[0]?.data || [];
                snapshots.push({
                    title: 'R√©partition par onglet',
                    headers: ['Onglet', 'Entr√©es affich√©es'],
                    rows: tabsChart.data.labels.map((label, idx) => [label, dataset[idx] || 0])
                });
            }

            const evolutionChart = chartInstances.evolutionChart;
            if (evolutionChart && evolutionChart.data?.labels?.length) {
                const creaData = evolutionChart.data.datasets?.[0]?.data || [];
                const modifData = evolutionChart.data.datasets?.[1]?.data || [];
                snapshots.push({
                    title: 'Traitements mensuels',
                    headers: ['Mois', 'Cr√©ation', 'Modification'],
                    rows: evolutionChart.data.labels.map((label, idx) => [label, creaData[idx] || 0, modifData[idx] || 0])
                });
            }

            const verificationChart = chartInstances.verificationChart;
            if (verificationChart && verificationChart.data?.datasets?.[0]) {
                const data = verificationChart.data.datasets[0].data || [];
                snapshots.push({
                    title: '√âtat V√©rification Baux',
                    headers: ['√âtat', 'Entr√©es'],
                    rows: ['OK', 'NOK', 'En cours'].map((label, idx) => [label, data[idx] || 0])
                });
            }

            const surfaceChart = chartInstances.surfaceChart;
            if (surfaceChart && surfaceChart.data?.labels?.length) {
                const data = surfaceChart.data.datasets?.[0]?.data || [];
                snapshots.push({
                    title: 'Diff√©rences de surface',
                    headers: ['Modification', 'Œî m¬≤'],
                    rows: surfaceChart.data.labels.map((label, idx) => [label, data[idx] || 0])
                });
            }

            return snapshots;
        }

        function exportStatsReport() {
            try {
                updateCharts();

                const statsContainer = document.getElementById('statistiques');
                if (!statsContainer) {
                    showNotification('‚ùå Onglet statistiques introuvable', 'error');
                    return;
                }

                const clone = statsContainer.cloneNode(true);
                const originalCanvases = statsContainer.querySelectorAll('canvas');
                const clonedCanvases = clone.querySelectorAll('canvas');

                originalCanvases.forEach((canvas, index) => {
                    const clonedCanvas = clonedCanvases[index];
                    try {
                        const img = document.createElement('img');
                        img.src = canvas.toDataURL('image/png');
                        img.alt = canvas.getAttribute('aria-label') || 'Graphique statistiques';
                        img.style.width = '100%';
                        img.style.maxWidth = '100%';
                        img.style.display = 'block';
                        img.style.margin = '10px auto';
                        clonedCanvas.replaceWith(img);
                    } catch (e) {
                        console.error('Conversion du graphique en image √©chou√©e', e);
                    }
                });

                const styleBlocks = Array.from(document.querySelectorAll('style'))
                    .map(style => style.innerHTML)
                    .join('\n');

                const interactivityScript = `
<script>
document.addEventListener('DOMContentLoaded', () => {
    document.querySelectorAll('.stats-card.collapsible .collapsible-header').forEach(header => {
        header.addEventListener('click', () => {
            const card = header.closest('.stats-card');
            if (card) card.classList.toggle('collapsed');
        });
    });

    document.querySelectorAll('.stats-item.pending-expand').forEach(item => {
        item.addEventListener('click', (event) => {
            const wasOpen = item.classList.contains('open');
            document.querySelectorAll('.stats-item.pending-expand.open').forEach(el => {
                if (el !== item) el.classList.remove('open');
            });
            item.classList.toggle('open', !wasOpen);
            event.stopPropagation();
        });
    });

    document.addEventListener('click', (event) => {
        if (!event.target.closest('.stats-item.pending-expand')) {
            document.querySelectorAll('.stats-item.pending-expand.open').forEach(el => el.classList.remove('open'));
        }
    });

    document.querySelectorAll('.rg-change-toggle').forEach(toggle => {
        toggle.addEventListener('click', (event) => {
            const card = toggle.closest('.rg-change-card');
            if (card) card.classList.toggle('collapsed');
            event.stopPropagation();
        });
    });
});
<\/script>`;

                const exportHtml = `<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Export Statistiques MARTINE</title>
    <style>${styleBlocks}</style>
</head>
<body style="background: white;">
    <div style="max-width: 1280px; margin: 0 auto; padding: 20px;">
        <h1 style="margin-bottom: 20px; color: #2c3e50;">Export de l'onglet Statistiques</h1>
        <div style="margin-bottom: 12px; color: #555; font-size: 13px;">
            G√©n√©r√© le ${new Date().toLocaleString('fr-FR')}
        </div>
        ${clone.innerHTML}
        ${interactivityScript}
    </div>
</body>
</html>`;

                const blob = new Blob([exportHtml], { type: 'text/html' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                const fileName = `MARTINE_Statistiques_${new Date().toISOString().split('T')[0]}.html`;
                link.href = url;
                link.download = fileName;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);

                showNotification(`üìë Export statistiques pr√™t: ${fileName}`);
                logActivity('Export HTML de l\'onglet statistiques', 'success');

            } catch (error) {
                console.error('Erreur export rapport statistiques:', error);
                showNotification('‚ùå Erreur lors de l\'export du rapport', 'error');
            }
        }

        // üíæ SAUVEGARDE ET RESTAURATION COMPL√àTE
        function scheduleIdleTask(callback) {
            if (window.requestIdleCallback) {
                return requestIdleCallback(callback, { timeout: 100 });
            }
            return setTimeout(callback, 0);
        }

        function saveAllData() {
            try {
                const allData = {
                    version: 'live',
                    timestamp: new Date().toISOString(),
                    rowCounters: rowCounters,
                    rgDatabase: rgDatabase,
                    pendingTasks: pendingTasks,
                    taskDrafts: taskDrafts,
                    taskBatches: taskBatches,
                    activeBatchId: activeBatchId,
                    completedTasks: completedTasks,
                    savedSearches: savedSearches,
                    activityLog: activityLog,
                    dismissedRGChanges: Array.from(dismissedRGChanges || []),
                    tabsData: {}
                };
                
                Object.keys(tabConfigs).forEach(tabName => {
                    const tbody = document.getElementById(`${tabName}TableBody`);
                    if (!tbody) return;
                    
                    const rows = tbody.querySelectorAll('tr');
                    const tabData = [];
                    
                    rows.forEach(row => {
                        const inputs = row.querySelectorAll('input, textarea, select');
                        const rowData = [];
                        inputs.forEach(input => {
                            rowData.push(input.value || '');
                        });
                        if (rowData.some(cell => cell.trim() !== '')) {
                            tabData.push(rowData);
                        }
                    });
                    
                    allData.tabsData[tabName] = tabData;
                });
                
                localStorage.setItem('martine_v17_data', JSON.stringify(allData));
                showSaveStatus('üíæ Donn√©es sauvegard√©es');
                
            } catch (error) {
                console.error('Erreur sauvegarde:', error);
                showSaveStatus('‚ùå Erreur sauvegarde', 'error');
            }
        }

        function loadAllData() {
            try {
                const savedData = localStorage.getItem('martine_v17_data');
                if (!savedData) return;

                let data;
                try {
                    data = JSON.parse(savedData);
                } catch (parseError) {
                    console.error('Sauvegarde corrompue, suppression...', parseError);
                    localStorage.removeItem('martine_v17_data');
                    showNotification('‚ö†Ô∏è Sauvegarde corrompue supprim√©e. Nouvelle session propre.', 'warning');
                    return;
                }

                if (!data || typeof data !== 'object') {
                    showNotification('‚ö†Ô∏è Format de sauvegarde invalide. Donn√©es ignor√©es.', 'warning');
                    return;
                }

                scheduleIdleTask(() => applyLoadedState(data));

                showNotification('üíæ Donn√©es restaur√©es avec succ√®s');

            } catch (error) {
                console.error('Erreur chargement:', error);
                showNotification('‚ùå Erreur lors du chargement des donn√©es', 'error');
            }
        }

        function exportCompleteBackup() {
            try {
                const allData = {
                    version: '17.0',
                    timestamp: new Date().toISOString(),
                    rowCounters: rowCounters,
                    rgDatabase: rgDatabase,
                    pendingTasks: pendingTasks,
                    taskDrafts: taskDrafts,
                    taskBatches: taskBatches,
                    activeBatchId: activeBatchId,
                    completedTasks: completedTasks,
                    savedSearches: savedSearches,
                    activityLog: activityLog,
                    dismissedRGChanges: Array.from(dismissedRGChanges || []),
                    tabsData: {}
                };
                
                Object.keys(tabConfigs).forEach(tabName => {
                    const tbody = document.getElementById(`${tabName}TableBody`);
                    if (!tbody) return;
                    
                    const rows = tbody.querySelectorAll('tr');
                    const tabData = [];
                    
                    rows.forEach(row => {
                        const inputs = row.querySelectorAll('input, textarea, select');
                        const rowData = [];
                        inputs.forEach(input => {
                            rowData.push(input.value || '');
                        });
                        if (rowData.some(cell => cell.trim() !== '')) {
                            tabData.push(rowData);
                        }
                    });
                    
                    allData.tabsData[tabName] = tabData;
                });
                
                const dataStr = JSON.stringify(allData, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                
                const link = document.createElement('a');
                link.href = URL.createObjectURL(dataBlob);
                link.download = `MARTINE_Sauvegarde_Compl√®te_${new Date().toISOString().split('T')[0]}.json`;
                link.click();
                
                showNotification('üì§ Sauvegarde compl√®te t√©l√©charg√©e');
                logActivity('Sauvegarde compl√®te export√©e', 'success');
                
            } catch (error) {
                console.error('Erreur export sauvegarde:', error);
                showNotification('‚ùå Erreur lors de l\'export de sauvegarde', 'error');
            }
        }

        function importCompleteBackup() {
            const fileInput = document.getElementById('backupFileInput');
            if (fileInput) {
                fileInput.click();
            }
        }

        function handleBackupImport() {
            try {
                const fileInput = document.getElementById('backupFileInput');
                const file = fileInput.files[0];
                
                if (!file) return;
                
                if (!file.name.endsWith('.json')) {
                    showNotification('‚ùå Veuillez s√©lectionner un fichier JSON de sauvegarde', 'error');
                    return;
                }
                
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const data = JSON.parse(e.target.result);
                        
                        if (!data.version || !data.tabsData) {
                            showNotification('‚ùå Fichier de sauvegarde invalide', 'error');
                            return;
                        }
                        
                        if (!confirm('‚ö†Ô∏è Cette action remplacera toutes les donn√©es actuelles. Continuer ?')) {
                            return;
                        }
                        
                        // Effacer les donn√©es actuelles
                        Object.keys(tabConfigs).forEach(tabName => {
                            clearAll(tabName, false);
                        });

                        applyLoadedState(data);
                        
                        showNotification(`‚úÖ Sauvegarde import√©e avec succ√®s (v${data.version})`);
                        logActivity('Sauvegarde compl√®te import√©e', 'success');
                        
                    } catch (parseError) {
                        console.error('Erreur parsing JSON:', parseError);
                        showNotification('‚ùå Erreur lors de la lecture du fichier de sauvegarde', 'error');
                    }
                };
                
                reader.readAsText(file);
                fileInput.value = '';
                
            } catch (error) {
                console.error('Erreur import sauvegarde:', error);
                showNotification('‚ùå Erreur lors de l\'import de sauvegarde', 'error');
            }
        }

        function applyLoadedState(data) {
            if (!data) return;

            columnSuggestions = {};

            // R√©initialiser les tableaux avant rechargement
            Object.keys(tabConfigs).forEach(tabName => {
                const tbody = document.getElementById(`${tabName}TableBody`);
                if (tbody) {
                    tbody.innerHTML = '';
                }
            });

            // R√©initialiser les compteurs pour √©viter les d√©calages
            rowCounters = Object.keys(tabConfigs).reduce((acc, tab) => {
                acc[tab] = 0;
                return acc;
            }, {});

            if (data.rowCounters) {
                Object.keys(data.rowCounters).forEach(tabName => {
                    if (typeof data.rowCounters[tabName] === 'number') {
                        rowCounters[tabName] = 0; // sera recalcul√© lors du chargement
                    }
                });
            }

            rgDatabase = data.rgDatabase || {};
            dismissedRGChanges = new Set(data.dismissedRGChanges || []);
            refreshRGSuggestions();

            pendingTasks = (data.pendingTasks || []).map(task => ({
                ...task,
                createdAt: reviveDate(task.createdAt) || new Date(),
                completedAt: reviveDate(task.completedAt)
            }));

            taskBatches = (data.taskBatches || []).map(batch => ({
                ...batch,
                createdAt: reviveDate(batch.createdAt) || new Date(),
                tasks: (batch.tasks || []).map(task => ({
                    ...task,
                    createdAt: reviveDate(task.createdAt) || new Date(),
                    completedAt: reviveDate(task.completedAt)
                }))
            }));

            // Compatibilit√© avec l'ancien format taskDrafts
            if (taskBatches.length === 0 && Array.isArray(data.taskDrafts) && data.taskDrafts.length > 0) {
                const migratedBatch = {
                    id: generateUniqueId(),
                    name: 'Lot import√©',
                    tasks: data.taskDrafts.map(task => ({
                        ...task,
                        createdAt: reviveDate(task.createdAt) || new Date(),
                        completedAt: reviveDate(task.completedAt)
                    })),
                    createdAt: new Date()
                };
                taskBatches.push(migratedBatch);
            }

            activeBatchId = data.activeBatchId || (taskBatches[0]?.id || null);
            taskDrafts = getActiveBatch() ? getActiveBatch().tasks : [];

            completedTasks = (data.completedTasks || []).map(task => ({
                ...task,
                createdAt: reviveDate(task.createdAt) || new Date(),
                completedAt: reviveDate(task.completedAt) || new Date(),
                status: task.status || 'completed'
            }));

            savedSearches = (data.savedSearches || []).map(search => ({
                ...search,
                createdAt: reviveDate(search.createdAt) || new Date()
            }));

            activityLog = (data.activityLog || []).map(entry => ({
                ...entry,
                timestamp: reviveDate(entry.timestamp) || new Date()
            }));

            if (data.tabsData) {
                Object.keys(data.tabsData).forEach(tabName => {
                    const tabData = data.tabsData[tabName];
                    if (!tabData || tabData.length === 0) return;

                    rowCounters[tabName] = 0;
                    const fragment = document.createDocumentFragment();
                    tabData.forEach(rowData => {
                        addRowWithData(tabName, rowData, {
                            fragment,
                            skipStats: true,
                            skipLog: true,
                            skipFocus: true,
                            skipValidation: true
                        });
                    });

                    const tbody = document.getElementById(`${tabName}TableBody`);
                    if (tbody) {
                        tbody.appendChild(fragment);
                    }

                    updateStats(tabName);
                });
            }

            applyIntelligentRGFillAll();

            updatePendingTasksDisplay();
            updateTaskBatchDisplay();
            updateBatchSelectors();
            updateTasksStats();
            updateSavedSearchesDisplay();
            updateRecentActivity();
            rebuildColumnSuggestions();
            saveAllData();
        }

        function reviveDate(value) {
            if (!value) return null;
            const date = new Date(value);
            return isNaN(date.getTime()) ? null : date;
        }

        // üóëÔ∏è NETTOYAGE
        function clearAll(tabName, confirm = true) {
            try {
                if (confirm && !window.confirm(`√ätes-vous s√ªr de vouloir effacer toutes les donn√©es de l'onglet ${getTabDisplayName(tabName)} ?`)) {
                    return;
                }
                
                const tbody = document.getElementById(`${tabName}TableBody`);
                if (tbody) {
                    tbody.innerHTML = '';
                    rowCounters[tabName] = 0;
                    clearRowSelection(tabName);
                    updateStats(tabName);
                    saveAllData();
                    
                    if (confirm) {
                        showNotification(`üóëÔ∏è Toutes les donn√©es de ${getTabDisplayName(tabName)} ont √©t√© effac√©es`);
                        logActivity(`Donn√©es effac√©es dans ${getTabDisplayName(tabName)}`, 'warning');
                    }
                }
            } catch (error) {
                console.error('Erreur effacement:', error);
                showNotification('‚ùå Erreur lors de l\'effacement', 'error');
            }
        }

        // üîß INITIALISATION COMPL√àTE
        function initializeApp() {
            try {
                loadAllData();
                refreshRGSuggestions();

                autoSaveInterval = setInterval(saveAllData, 60000); // Toutes les minutes

                window.addEventListener('beforeunload', () => {
                    saveAllData();
                });

                setupFileDropZones();
                setupClipboardAutoPreview();
                updateStatsDashboard();

                showNotification('üöÄ MARTINE - Tous onglets fonctionnels', 'success');
                showSaveStatus('üíæ Application pr√™te - Auto-sauvegarde activ√©e');
                logActivity('Application MARTINE initialis√©e', 'success');
                
            } catch (error) {
                console.error('Erreur initialisation:', error);
                showNotification('‚ùå Erreur lors de l\'initialisation', 'error');
            }
        }

        function setupFileDropZones() {
            try {
                Object.keys(tabConfigs).forEach(tabName => {
                    const fileInput = document.getElementById(`fileInput${tabName.charAt(0).toUpperCase() + tabName.slice(1)}`);
                    if (!fileInput) return;
                    
                    const dropZone = fileInput.closest('.file-drop-zone');
                    if (!dropZone) return;
                    
                    // Supprimer les anciens listeners pour √©viter les doublons
                    const newDropZone = dropZone.cloneNode(true);
                    dropZone.parentNode.replaceChild(newDropZone, dropZone);
                    
                    const newFileInput = newDropZone.querySelector('input[type="file"]');
                    
                    newDropZone.addEventListener('dragover', (e) => {
                        e.preventDefault();
                        newDropZone.classList.add('dragover');
                    });
                    
                    newDropZone.addEventListener('dragleave', () => {
                        newDropZone.classList.remove('dragover');
                    });
                    
                    newDropZone.addEventListener('drop', (e) => {
                        e.preventDefault();
                        newDropZone.classList.remove('dragover');

                        const files = e.dataTransfer.files;
                        if (files.length > 0) {
                            newFileInput.files = files;
                            handleFileImport(tabName, newFileInput);
                        }
                    });

                    newFileInput.addEventListener('click', (e) => {
                        e.stopPropagation();
                        newFileInput.value = '';
                    });

                    newDropZone.addEventListener('click', (e) => {
                        if (e.target === newDropZone || e.target.closest('.file-drop-zone') === newDropZone) {
                            openFilePicker(newFileInput);
                        }
                    });
                });
            } catch (error) {
                console.error('Erreur configuration drop zones:', error);
            }
        }

        // üöÄ D√âMARRAGE APPLICATION
        document.addEventListener('DOMContentLoaded', function() {
            initializeApp();
        });

        // üîß EXPOSITION DES FONCTIONS GLOBALES
        window.switchTab = switchTab;
        window.addRow = addRow;
        window.deleteRow = deleteRow;
        window.exportToExcel = exportToExcel;
        window.exportAllToExcel = exportAllToExcel;
        window.exportStatsReport = exportStatsReport;
        window.clearAll = clearAll;
        window.triggerFileInput = triggerFileInput;
        window.handleFileImport = handleFileImport;
        window.togglePasteArea = togglePasteArea;
        window.analyzePastedData = analyzePastedData;
        window.showPreview = showPreview;
        window.closePreview = closePreview;
        window.makeEditable = makeEditable;
        window.fixAllErrors = fixAllErrors;
        window.removeErrorRows = removeErrorRows;
        window.importPreviewedData = importPreviewedData;
        window.importIgnoreErrors = importIgnoreErrors;
        window.filterTable = filterTable;
        window.performSearch = performSearch;
        window.performAdvancedSearch = performAdvancedSearch;
        window.clearSearch = clearSearch;
        window.saveCurrentSearch = saveCurrentSearch;
        window.loadSavedSearch = loadSavedSearch;
        window.deleteSavedSearch = deleteSavedSearch;
        window.exportSearchResults = exportSearchResults;
        window.goToResult = goToResult;
        window.updateTaskFields = updateTaskFields;
        window.transferTask = transferTask;
        window.saveTaskAsPending = saveTaskAsPending;
        window.createTaskBatch = createTaskBatch;
        window.selectTaskBatch = selectTaskBatch;
        window.addTaskToBatch = addTaskToBatch;
        window.deleteActiveBatch = deleteActiveBatch;
        window.saveBatchAsPending = saveBatchAsPending;
        window.deleteTaskDraft = deleteTaskDraft;
        window.clearTaskForm = clearTaskForm;
        window.executeTask = executeTask;
        window.editTask = editTask;
        window.deleteTask = deleteTask;
        window.executeAllPendingTasks = executeAllPendingTasks;
        window.clearAllPendingTasks = clearAllPendingTasks;
        window.exportTasksToExcel = exportTasksToExcel;
        window.exportActiveBatch = exportActiveBatch;
        window.validateAllBauxStates = validateAllBauxStates;
        window.markAllAsOK = markAllAsOK;
        window.validateAllRGCodes = validateAllRGCodes;
        window.buildRGDatabase = buildRGDatabase;
        window.buildUTDatabase = buildUTDatabase;
        window.recalculateAllSurfaces = recalculateAllSurfaces;
        window.exportCompleteBackup = exportCompleteBackup;
        window.importCompleteBackup = importCompleteBackup;
        window.handleBackupImport = handleBackupImport;
        window.toggleQualityAlerts = toggleQualityAlerts;
        window.focusQualityIssue = focusQualityIssue;
        window.focusRGChange = focusRGChange;
        window.exportRGChange = exportRGChange;
        window.exportRGChanges = exportRGChanges;
        window.openClipboardPreview = openClipboardPreview;
        window.closeClipboardPreview = closeClipboardPreview;
        window.copyClipboardSelection = copyClipboardSelection;
        window.filterClipboardLeft = filterClipboardLeft;
        window.resetClipboardSearch = resetClipboardSearch;
        window.deleteSelectedRows = deleteSelectedRows;
        window.addImportToBatch = addImportToBatch;
    </script>
</body>
</html>